<!DOCTYPE html>
<html lang="fi">
<head>
  <meta charset="UTF-8" />
  <title>Kartta 2</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="manifest" href="manifest.json">
  <link rel="icon" href="data:,">
  <!-- Leaflet CSS -->
  <!--<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>-->
  <link rel="stylesheet" href="js/leaflet.css"/>

  <style>
    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
    }

    .errorClass {
      color:#ff0000;
      font-weight: bold;
    }

    #searchCombo {
      max-width: 250px;      /* Adjust as needed */
      width: 100%;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .popup {
      padding: 5%;
      position: absolute;
      z-index: 400;
      background-color: lightyellow;
      visibility: hidden;
      top: 30pt;
      left: 5%;
      /*width: calc(100% - 72px);
      height: calc(100% - 120px);*/
      right: 5%;
      bottom: 10pt;
      border-color: steelblue;
      border-radius: 20px;
      border-style: solid;
      max-width: 800px;
      /* overflow:auto; */
    }

    .popupIn {
      padding: 5%;
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      overflow:auto;
      border-radius: 20px;
    }

    .ui-menu li {
        margin: 0;
        cursor: pointer;
        list-style-image: url(data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7);
        position: relative;
        padding: 3px 2em 3px 0;
        font-family: Arial, Helvetica, sans-serif;
        font-size: 1em;
    }

    .ui-menu li:hover {
      background-color: #007bff;
      color: #fff;
    }
    .ui-menu li span {
      color: inherit; /* Ensure span inherits the hover color */
    }

    .ui-menu {
        background: #ffffff;
        /* width: 230px; */
        margin-left: 25px;
        /* margin-top: 40px; */
        margin-right: 20px;
        height: auto !important;
        display: block;
        list-style-type: none;
        margin-block-start: 1em;
        margin-block-end: 1em;
        padding-inline-start: 6px;
    }

    li a.help {
        padding: unset !important;
        display: inline !important;
        /* float: right; */
        position: absolute !important;
        right: 10px;
    }

    a.help {
        text-decoration: none !important;
    }


    #map {
      height: 100%;
      /* position: relative; */
      cursor: default;
      /* flex: 1 1 auto; */
      width: 100%;
      /* height: auto; */
      /*min-height: 100px; */
      overflow: hidden; /* Prevent scrolling */
    }
    #mapModeSelect {
      /* position: absolute;
      top: 0px;
      left: 35px;

       */
      z-index: 1000;
      background: white;
      padding: 0;
      border-radius: 3px;
      /* box-shadow: 0 0 5px rgba(0,0,0,0.3); */
      font-family: Arial, Helvetica, sans-serif;
      font-size: 1.0em;
    }
    #distance {
      background-color: white;
      align-self: baseline;
    }

    #editPinLoc {
      width: 250px; /* desktop default */
    }

    @media (max-width: 600px) {
      #editPinLoc {
        width: 170px; /* smaller for mobile */
      }
    }

    .closebtn {
        z-index: 1000;
        position: absolute;
        top: 0;
        width: 20px;
        right: 5px;
        font-size: 36px;
        /*margin-left: 50px; */
    }

    .layout-container {
      display: flex;
      flex-direction: column;
      height: 100dvh;
    }

    .ui-layout-north {
      z-index: 2000;
      height: 22px;
      position: relative;
      background: #f8f9fa;
      border-bottom: 1px solid #dee2e6;
      flex-shrink: 0;
    }

    .ui-layout-center {
      flex: 1 1 auto;
      position: relative;
      display: flex;
      flex-direction: column;
      overflow: hidden; /* Prevent scrolling */

    }

    .ui-widget {
      display: flex;
      /* align-items: center; */
      gap: 5px; /* optional spacing */
    }

    .mapType {
      position: absolute;
      top: 0;
      left: 0;
      z-index: 1100;
      background: rgba(255,255,255,0.9);
      padding: 0;
      border-radius: 0;
      /* width: 100%; */
    }

    .hamburgerSpace {
      margin-left: 35px;
    }

    .area1CBcopy {
      align-items: center;
      position: absolute;
      top: 0;
      right: 0;
      z-index: 3000;
    }
    button.icon-btn {
      background: none;
      border: none;
      padding: 0;
      margin: 0;
      width: auto;
      height: auto;
      box-shadow: none;
      outline: none;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      justify-content: center;
    }
  </style>
<!--<script src="https://cdnjs.cloudflare.com/ajax/libs/idb-keyval/3.0.1/idb-keyval-iife.min.js"></script>!-->
<script src="KeyValStore.js"></script>
<script>
if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('offline-worker.js');
}
</script>
</head>
<body>

<!-- Pick next files to your js-directory -->
<!-- Leaflet JS -->
<!-- <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script> -->
<!-- <script src="https://unpkg.com/leaflet-textpath/leaflet.textpath.js"></script>-->

<script src="js/leaflet.js"></script>
<script src="js/leaflet.textpath.js"></script>
<script src="MapWrapperLeafLet.js"></script>
<script>

// Globass for databases
const tileStore = new KeyValStore('kartta-db', 'tiles');
// const settingsStore = new KeyValStore('kartta-db', 'settings');


function sanitizeInput(input, type = "html") {
  if (typeof input !== "string") return "";

  switch (type) {
    case "html": // Näytetään HTML:ssä tekstinä
      return input
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#039;");

    case "attr": // HTML-attribuuteissa
      return input
        .replace(/&/g, "&amp;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#039;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;");

    case "url": // URL-parametreissa
      return encodeURIComponent(input);

    case "alnum": // Vain kirjaimet ja numerot
      return input.replace(/[^a-z0-9]/gi, '');

    default:
      return input;
  }
}

const cycloServerUrl = "https://www.mit.jyu.fi/demowww/cyclo";
const helpServerUrl = "https://tim.jyu.fi/view/users/vesal/riippu/cyclo/kartta";

function prefixHelpLinks() {
    document.querySelectorAll('a.help').forEach(link => {
        link.target = "help";
        link.innerText = " ?";
        const hash = link.getAttribute('data-href');
        if (hash && hash.startsWith('#')) {
            link.setAttribute('href',  helpServerUrl + hash);
        }
    });
}





 // Simulation of C# string.Format, only {n} works.
 if (!String.format) {
  String.format = function(format) {
    const args = Array.prototype.slice.call(arguments, 1);
    return format.replace(/{(\d+)}/g, function(match, number) {
      return typeof args[number] != 'undefined'
        ? args[number]
        : match
      ;
    });
  };
}

// Converts tile XY coordinates into a QuadKey at a specified level of detail.
function TileXYToQuadKey(tile) {
  let quadKey = "";
  for (let i = tile.zoom; i > 0; i--)  {
    let digit = '0';
    const mask = 1 << (i - 1);
    if ((tile.x & mask) !== 0) {
            digit++;
    }
    if ((tile.y & mask) !== 0) {
        digit++;
        digit++;
    }
    quadKey += digit;
  }
  return quadKey;
}


const belectro = {
  link: "https://tanger.belectro.fi/tiles/mmltopo/v9/256/{0}/{2}/{1}?ref=7f2d",
  ok: false,
  init: async function () {
    if (this.ok) return;
    this.ok = true;
    const response = await fetch(cycloServerUrl + "/bbark.php");
    const data = await response.text();
    const bbarkObj = JSON.parse(data);
    // noinspection JSUnresolvedReference
    let url = bbarkObj.base_map_groups[0].maps[0].url;
    url = url.replace("{W}", "256");
    url = url.replace("{Z}", "{0}");
    url = url.replace("{Y}", "{2}");
    url = url.replace("{X}", "{1}");
    belectro.link = url;
  }
};

 // noinspection CheckImageSize
const mapModes = {
  "Bing Maps normal"   : { f:function(tile) {
	                            return String.format("https://ecn.t1.tiles.virtualearth.net/tiles/r{0}?g=1135",TileXYToQuadKey(tile));
							}, c:""},
	"Bing Maps aerial"   : { f:function(tile) {
	                            return String.format("https://ecn.t1.tiles.virtualearth.net/tiles/h{0}?g=1135",TileXYToQuadKey(tile));
							}, c:""},
	"Google street"      : { f:function(tile) { return String.format("https://mt1.google.com/vt/lyrs=m&z={0}&x={1}&y={2}",tile.zoom ,tile.x, tile.y ); },
	                         c:'(c) <a href="https://maps.google.com/help/terms_maps.html" target="_blank">Google Maps</a>'},
	"Google satellite"   : { f:function(tile) { return String.format("https://mt1.google.com/vt/lyrs=y&z={0}&x={1}&y={2}",tile.zoom ,tile.x, tile.y ); },
	                         c:'(c) <a href="https://maps.google.com/help/terms_maps.html" target="_blank">Google Maps</a>'},
//  "Google Street"      : { f:function(tile) { tile = nokiaConvert(tile); return String.format("https://maps.googleapis.com/maps/api/staticmap?center={1},{2}&zoom={0}&size=256x256&key=AIzaSyCpXjAoV19MUbpGd6e6YD9IketR2Gu-tqc",tile.zoom ,tile.x, tile.y); }, c:""},
//  "Google satellite"   : { f:function(tile) { tile = nokiaConvert(tile); return String.format("https://maps.googleapis.com/maps/api/staticmap?center={1},{2}&zoom={0}&size=256x256&key=AIzaSyCpXjAoV19MUbpGd6e6YD9IketR2Gu-tqc&maptype=hybrid",tile.zoom ,tile.x, tile.y); }, c:""},
//    "Nokia"              : { f:function(tile) { tile = nokiaConvert(tile); return String.format("http://m.nok.it/?app_id=_peU-uCkp-j8ovkzFGNU&app_code=gBoUkAMoxoqIWfxWA5DuMQ&h=256&w=256&ctr={1},{2}&z={0}&t=0&nord",tile.zoom ,tile.x, tile.y); }, c:""},
//	"MapQuest"           : { f:function(tile) { return String.format("http://otile1.mqcdn.com/tiles/1.0.0/map/{0}/{1}/{2}.png",Clip(tile.zoom,0,19) ,tile.x, tile.y); },
//	                         c:'(c) <a href="http://info.mapquest.com/terms-of-use/" target="_blank">MapQuest</a>'},
	"OpenStreet"         : { f:function(tile) { return String.format("https://tile.openstreetmap.org/{0}/{1}/{2}.png",tile.zoom,tile.x,tile.y); },
	                         c:'(c) <a href="https://www.openstreetmap.org/copyright" target="_blank">OpenStreetMap</a>'},
	"OpenCycle"          : //{ f:function(tile) { return String.format("http://a.tile.opencyclemap.org/cycle/{0}/{1}/{2}.png",tile.zoom ,tile.x, tile.y ); },
	                         { f:function(tile) { return String.format("https://tile.thunderforest.com/cycle/{0}/{1}/{2}.png?apikey=4e1589f40d3049469a043e2ec917dc88",tile.zoom ,tile.x, tile.y ); },
	                         c:'(c) <a href="https://www.opencyclemap.org/docs/" target="_blank">OpenCycleMap</a>'},
	"Landscape"          : { f:function(tile) { return String.format("https://tile.thunderforest.com/landscape/{0}/{1}/{2}.png?apikey=4e1589f40d3049469a043e2ec917dc88",tile.zoom ,tile.x, tile.y ); },
	                         c:'(c) <a href="https://www.opencyclemap.org/docs/" target="_blank">OpenCycleMap</a>'},
	"Transport"          : { f:function(tile) { return String.format("https://tile.thunderforest.com/transport/{0}/{1}/{2}.png?apikey=4e1589f40d3049469a043e2ec917dc88",tile.zoom ,tile.x, tile.y ); },
	                         c:'(c) <a href="https://www.opencyclemap.org/docs/" target="_blank">OpenCycleMap</a>'},
	"Outdoors"           : { f:function(tile) { return String.format("https://tile.thunderforest.com/outdoors/{0}/{1}/{2}.png?apikey=4e1589f40d3049469a043e2ec917dc88",tile.zoom ,tile.x, tile.y ); },
	                         c:'(c) <a href="https://www.opencyclemap.org/docs/" target="_blank">OpenCycleMap</a>'},
	/* Ei voi käyttää, koska ei ole enää saatavilla WGS84, vaan vain EPSG:3067
  "Kapsi peruskartta"  : { f:function(tile) { return getKapsiTilePath(tile); },
	                         c:'(c) <a href="http://www.maanmittauslaitos.fi/avoindata_lisenssi_versio1_20120501" target="_blank">Maanmittauslaitos</a>'},
	"Kapsi Tausta"       : { f:function(tile) { return String.format("http://tiles.kartat.kapsi.fi/taustakartta_3067/{0}/{1}/{2}.jpg",tile.zoom ,tile.x, tile.y); },
	                         c:'(c) <a href="http://www.maanmittauslaitos.fi/avoindata_lisenssi_versio1_20120501" target="_blank">Maanmittauslaitos</a>'},
	"Kapsi Ilma"         : { f:function(tile) { return String.format("http://tiles.kartat.kapsi.fi/ortokuva_3067/{0}/{1}/{2}.jpg",tile.zoom ,tile.x, tile.y); },
	                         c:'(c) <a href="http://www.maanmittauslaitos.fi/avoindata_lisenssi_versio1_20120501" target="_blank">Maanmittauslaitos</a>'

                             },
https://avoin-karttakuva.maanmittauslaitos.fi/avoin/wmts/1.0.0/taustakartta/default/WGS84_Pseudo-Mercator/18/72651/149809.png?api-key=
https://avoin-karttakuva.maanmittauslaitos.fi/avoin/wmts/1.0.0/ortokuva/default/WGS84_Pseudo-Mercator/12/1116/2297.png?api-key=
	 */
  "MML maasto"         : {   f:function(tile) { return String.format("https://avoin-karttakuva.maanmittauslaitos.fi/avoin/wmts/1.0.0/maastokartta/default/WGS84_Pseudo-Mercator/{0}/{2}/{1}.png?api-key=4c0b6a7d-aa24-4b2c-913c-66d3823d7445",tile.zoom ,tile.x, tile.y); },
	                         c:'(c) <a href="https://www.maanmittauslaitos.fi/avoindata_lisenssi_versio1_20120501" target="_blank">Maanmittauslaitos</a>'},
  "MML tausta"         : {   f:function(tile) { return String.format("https://avoin-karttakuva.maanmittauslaitos.fi/avoin/wmts/1.0.0/taustakartta/default/WGS84_Pseudo-Mercator/{0}/{2}/{1}.png?api-key=4c0b6a7d-aa24-4b2c-913c-66d3823d7445",tile.zoom ,tile.x, tile.y); },
	                         c:'(c) <a href="https://www.maanmittauslaitos.fi/avoindata_lisenssi_versio1_20120501" target="_blank">Maanmittauslaitos</a>'},
  "MML selko"         : {   f:function(tile) { return String.format("https://avoin-karttakuva.maanmittauslaitos.fi/avoin/wmts/1.0.0/selkokartta/default/WGS84_Pseudo-Mercator/{0}/{2}/{1}.png?api-key=4c0b6a7d-aa24-4b2c-913c-66d3823d7445",tile.zoom ,tile.x, tile.y); },
	                         c:'(c) <a href="https://www.maanmittauslaitos.fi/avoindata_lisenssi_versio1_20120501" target="_blank">Maanmittauslaitos</a>'},
  "MML ilma"           : {   f:function(tile) { return String.format("https://avoin-karttakuva.maanmittauslaitos.fi/avoin/wmts/1.0.0/ortokuva/default/WGS84_Pseudo-Mercator/{0}/{2}/{1}.png?api-key=4c0b6a7d-aa24-4b2c-913c-66d3823d7445",tile.zoom ,tile.x, tile.y); },
	                         c:'(c) <a href="https://www.maanmittauslaitos.fi/avoindata_lisenssi_versio1_20120501" target="_blank">Maanmittauslaitos</a>'},
	"b-bark SuomiTopo"   : { f:function(tile) {
                            return String.format(belectro.link, tile.zoom, tile.x, tile.y);
						               },
	                         c:'<span>Render:</span> <a href="https://www.b-bark.com" target="_blank"><img style="vertical-align:middle" src="css/b_bark_logo.png" width="10%" height="10%"  alt=""/></a> (c) <a href="https://www.maanmittauslaitos.fi/avoindata_lisenssi_versio1_20120501" target="_blank">Maanmittauslaitos</a>',
                             i: belectro.init },
  "World Topo Map":      {f: function(tile) {
                            return String.format("https://services.arcgisonline.com/ArcGIS/rest/services/World_Topo_Map/MapServer/tile/{0}/{2}/{1}", tile.zoom, tile.x, tile.y);
                          },
                          c: '(c) <a href="https://www.esri.com/" target="_blank">Esri</a>'
                          },
  "World Imagery"      : { f:function(tile) { return String.format("https://services.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{0}/{2}/{1}",tile.zoom ,tile.x, tile.y);},
	                         c:'(c) <a href="https://www.esri.com/en-us/home" target="_blank">ArgGIS</a>'},
	/*
  "Ilmailu merged"      : { f:function(tile) {
                              const airac = "1806";
                              return String.format('https://snapshots.openflightmaps.org/live/' + airac + '/tiles/world/noninteractive/epsg3857/merged/256/latest/{0}/{1}/{2}.png', tile.zoom, tile.x, tile.y);
                              },
	                         c:'(c) <a href="https://openflightmaps.org/live/ef-finland/" target="_blank">openflightmaps.org</a>'},
	"Ilmailu aero"      : { f:function(tile) {
	                             const airac = "1806";
	                             return String.format('https://snapshots.openflightmaps.org/live/' + airac + '/tiles/world/noninteractive/epsg3857/aero/256/latest/{0}/{1}/{2}.png',tile.zoom ,tile.x, tile.y);
	                             },
	                         c:'(c) <a href="https://openflightmaps.org/live/ef-finland/" target="_blank">openflightmaps.org</a>'},
*/
/*
	"Ilmailu base"      : { f:function(tile) {
	                             var airac = "1806";
	                             var url = String.format('https://snapshots.openflightmaps.org/live/' + airac + '/tiles/world/noninteractive/epsg3857/base/256/latest/{0}/{1}/{2}.png',tile.zoom ,tile.x, tile.y);
	                             return url},
	                         c:'(c) <a href="https://openflightmaps.org/live/ef-finland/" target="_blank">openflightmaps.org</a>'},
*/
};

class Ellipsoid {
  constructor(name, a, invf) {
    this.name = name;
    this.a = a;
    this.invf = invf;
  }
}

const ells = [
  new Ellipsoid("WGS84", 6378.137 / 1.852, 298.257223563),
  new Ellipsoid("FAI sphere", 6371.0 / 1.852, 1000000000.)
];


function getEllipsoid(selection){
//  document.spheroid.major_radius.value=ells[selection.selectedIndex+1].a*1.852
//  document.spheroid.inverse_f.value=ells[selection.selectedIndex+1].invf
  return ells[selection.selectedIndex];
}

function atan2(y,x) {
  let out;
  if (x <0)            { out= Math.atan(y/x)+Math.PI;}
  if ((x >0) && (y>=0)){ out= Math.atan(y/x);}
  if ((x >0) && (y<0)) { out= Math.atan(y/x)+2*Math.PI;}
  if ((x===0) && (y>0)) { out= Math.PI/2;}
  if ((x===0) && (y<0)) { out= 3*Math.PI/2;}
  if ((x===0) && (y===0)) {
  //alert("atan2(0,0) undefined")
      out= 0.
  }
  return out
}

function bearingDegrees(from, to) {
  // from and to: [lat, lon]
  const toRad = deg => deg * Math.PI / 180;
  const toDeg = rad => rad * 180 / Math.PI;

  const lat1 = toRad(from[0]);
  const lat2 = toRad(to[0]);
  const dLon = toRad(to[1] - from[1]);

  const y = Math.sin(dLon) * Math.cos(lat2);
  const x = Math.cos(lat1) * Math.sin(lat2) -
            Math.sin(lat1) * Math.cos(lat2) * Math.cos(dLon);
  let brng = Math.atan2(y, x);
  brng = toDeg(brng);
  return (brng + 360) % 360; // Normalize to 0–360
}

function WGS84_distance(p1,p2) {
  if (Array.isArray(p1) && p1.length === 2) {
    p1 = { latitude: p1[0], longitude: p1[1] };
  }
  if (Array.isArray(p2) && p2.length === 2) {
    p2 = { latitude: p2[0], longitude: p2[1] };
  }
  const selection = {selectedIndex: 0};
  const m = Math.PI / 180;
  return crsdist_ell(p1.latitude*m,p1.longitude*m,p2.latitude*m,p2.longitude*m,getEllipsoid(selection));
}

function crsdist_ell(glat1,glon1,glat2,glon2,ellipse){
  // glat1 initial geodetic latitude in radians N positive
  // glon1 initial geodetic longitude in radians E positive
  // glat2 final geodetic latitude in radians N positive
  // glon2 final geodetic longitude in radians E positive
  const a = ellipse.a
  const f = 1/ellipse.invf
  //alert("a="+a+" f="+f)
  let r, tu1, tu2, cu1, su1, cu2, s1, b1, f1;
  let x, sx, cx, sy, cy, y, sa, c2a, cz, e, c, d;
  const EPS = 0.00000000005;
  let s;
  let iter = 1;
  const MAXITER = 100;
  if ((glat1+glat2===0.) && (Math.abs(glon1-glon2)===Math.PI)){
    alert("Course and distance between antipodal points is undefined")
    glat1=glat1+0.00001 // allow algorithm to complete
    }
  if ( glat1===glat2 && (glon1===glon2 || Math.abs(Math.abs(glon1-glon2)-2*Math.PI) <  EPS) ) {
    //alert("Points 1 and 2 are identical- course undefined")
    return 0.0; // don't care???
  }
  r = 1 - f
  tu1 = r * Math.tan (glat1)
  tu2 = r * Math.tan (glat2)
  cu1 = 1. / Math.sqrt (1. + tu1 * tu1)
  su1 = cu1 * tu1
  cu2 = 1. / Math.sqrt (1. + tu2 * tu2)
  s1 = cu1 * cu2
  b1 = s1 * tu2
  f1 = b1 * tu1
  x = glon2 - glon1
  d = x + 1 // force one pass
  while ((Math.abs(d - x) > EPS) && (iter < MAXITER))
    {
      iter=iter+1
      sx = Math.sin (x)
//       alert("sx="+sx)
      cx = Math.cos (x)
      tu1 = cu2 * sx
      tu2 = b1 - su1 * cu2 * cx
      sy = Math.sqrt(tu1 * tu1 + tu2 * tu2)
      cy = s1 * cx + f1
      y = atan2 (sy, cy)
      sa = s1 * sx / sy
      c2a = 1 - sa * sa
      cz = f1 + f1
      if (c2a > 0.)
     cz = cy - cz / c2a
      e = cz * cz * 2. - 1.
      c = ((-3. * c2a + 4.) * f + 4.) * c2a * f / 16.
      d = x
      x = ((e * cy * c + cz) * sy * c + y) * sa
      x = (1. - c) * x * f + glon2 - glon1
    }
  x = Math.sqrt ((1 / (r * r) - 1) * c2a + 1)
  x +=1
  x = (x - 2.) / x
  c = 1. - x
  c = (x * x / 4. + 1.) / c
  d = (0.375 * x * x - 1.) * x
  x = e * cy
  s = ((((sy*sy*4.-3.)*(1.-e-e)*cz*d/6.-x)*d/4.+cz)*sy*d+y)*c*a*r

  return s*1.852;
  /*
  let faz, baz;
  faz = modcrs(atan2(tu1, tu2))
  baz = modcrs(atan2(cu1 * sx, b1 * cx - su1 * cu2) + Math.PI)
  out=new MakeArray(0)
  out.d=s
  out.crs12=faz
  out.crs21=baz
  if (Math.abs(iter-MAXITER)<EPS){
    alert("Algorithm did not converge")
  }
  return out
  */
} // crsdist_ell ends

// Globals:
// let lastSelected = null;
let myPin = null;
let hitPin = null;
let mapWrapper = null;
let pinNr = 1;
let dstTextElem = null;
let lastHitPoint = null;
let hitPinXY = [100,100];
let searchPins = [];

const options = {
  email: "",
  id: "",
  logname: "",
  interval: "5000",
  usersTofollow: "",
  send: false,
  readGPS: true,
  resend: false,
  follow: false,
  followMe: false,
  showTime: true,
  selectNewPin: true,
  useDummyRect: false,
  preventSleep: true,
  smallRaport: false,
  drawLogLine: false,
  HStationary: true,
  HCenter: false,
  showAccuracy: true,
  extra: false,
  tpR: "0",
  hasWakeLock: false,
  useComps: false,
  useCompsWindow: false,
  useCache: true,
  drawDistanceLine: true,
  calcDistanceSum: true,
};

const areaDatas = [
  {name: "Ilmatilat", url: "https://flyk.com/api/airspaces.geojson", cb: "area1cb"},
  {name: "Suplementit", url: "https://flyk.com/api/supplements.geojson", cb: "area2cb"},
  {name: "Varaukset", url: "https://flyk.com/api/reservations.geojson", cb: "area3cb"},
];

const params = getUrlVars();

function getUrlVars()
 {
   let vars = [], hash;
   const hashes = window.location.href.slice(window.location.href.indexOf('?') + 1).split('&');
   for (let i = 0; i < hashes.length; i++) {
        hash = hashes[i].split('=');
        vars.push(hash[0]);
        vars[hash[0]] = hash[1];
    }
    return vars;
 }

const timers = {
 follow : { t:null,f:getfollow,interval:1000 },
 showPosition : { t:null, f:showCurrentPosition,interval:1000},
 send : { t:null,f:sendPosition,interval:5000 },
 resend : { t:null,f:sendPosition,interval:200000 },
 showTime: { t:null,f:setTimeCompsValues,interval:1000 },
};

function checkTimer(timer, clear) {
  // if ( timer=="send" && !options.sendPos) return;
  const tim = timers[timer];
  if ( options[timer] && !clear)
     tim.t = setInterval(function(){ tim.f();	}, tim.interval);
  else
     clearInterval(tim.t);
}

function setTimeCompsValues() {
    const now = new Date();
    for (let comp of timecomponents) {
        let v = comp.f(comp, now);
        if (v === null) continue;
        comp.span.innerText = v;
        comp.value = v;
    }
}

function displayLoc(e) {
	if (e.targetType === 'pushpin') displayLocPin(e.target);
}

function displayLocPin(pin) {
  if ( !pin ) return;
  const pinLoc = mapWrapper.getPinLocation(pin);
  const alt = pinLoc.altitude;
  let alts = "";
  if ( !(alt === undefined) ) alts = " " + (alt/3.280839895).toFixed(0) + " m";
  setPinInputText(pinLoc[0].toFixed(5) + " " + pinLoc[1].toFixed(5) + " " + mapWrapper.getPinLabel(pin) + alts);
  calcDistance(-1, -1);
}


function mapMove() {
  mouseDown = true;
  const pos = mapWrapper.getCenter();
  localStorage.lon = pos.longitude;
  localStorage.lat = pos.latitude;
  localStorage.zoom = mapWrapper.getZoom();
  if ( options.HCenter ) {
     setHitPinLoc(mapWrapper.getCenter(),-1, -1);
     displayLocPin(hitPin);
  } else if (options.HStationary) {
     const loc = mapWrapper.getXYCoord(hitPinXY);
     setHitPinLoc(loc, -1, -1);
     displayLocPin(hitPin);
  }
}

function showCurrentPosition() {

}

function postCyclo(data, callback) {
  fetch(cycloServerUrl, {
    method: "POST",
    headers: {
      "Content-Type": "application/x-www-form-urlencoded"
    },
    body: Object.keys(data)
      .map(key => encodeURIComponent(key) + "=" + encodeURIComponent(data[key]))
      .join("&")
  })
  .then(response => response.text())
  .then(callback);
}

function getfollow()  {
  if ( !options.id || !options.email ) return;

  clearError();
  postCyclo({id: options.id, e: getEmailTag(), f : options.usersTofollow}, setPins(data));
}

function postPosition(position) {
    if ( sending ) return;
    if ( !options.id || !options.email ) return;
    sending = true;
   clearError();
   // var position ="62.4596956,25.7324266,0,433,41478.4036846991,2.390,254.9,3.0,3.0";
  const pos = fixed(position.coords.latitude, 7) + "," +
    fixed(position.coords.longitude, 7) + "," +
    "0" + "," +
    fixed(((position.coords.altitude) * 3.280839895), 0) + "," +
    fixed((position.timestamp / 1000 / 3600 / 24) + 25569.00, 10) + "," +
    fixed(position.coords.speed, 1) + "," +
    fixed(position.coords.heading, 1) + "," +
    fixed(position.coords.accuracy, 1) + "," +
    fixed(position.coords.altitudeAccuracy, 1);
  const posmsg = fixed(position.coords.latitude, 4) + "," +
    fixed(position.coords.longitude, 4);

  // let tag = "";
  // if ( options.tag ) tag = "+" + options.tag;

   if ( lastSend === posmsg ) {
      setError("");
      // timers["send"].interval = options.interval;
      // checkTimer("send",false);
      // checkTimer("resend",true);
      sending = false;
      return;
   }

   sendCyclo({id: options.id, e: getEmailTag(), d : pos, log:getLogname()},
    function( data ) {
      setError(data);
      // timers["send"].interval = options.interval;
      // checkTimer("send",false);
      // checkTimer("resend",true);
      sending = false;
      lastSend = posmsg;
	  }
	);
  const c = document.getElementById('coord');
  c.innerHTML = " " + posmsg;
}


let sending = false;
let lastGPSCoord;

function sendPosition() {
   // checkTimer("send",true);
   // checkTimer("resend",true);
   clearError();
   // getLocation();
   if ( options.send ) {
       if ( lastGPSCoord )
          postPosition(lastGPSCoord);
       else
          navigator.geolocation.getCurrentPosition(postPosition, errorCallBack, geo_options);
   }
 }


function isCoordinate(s) {
     if ( s === "" ) return false;
     return "0123456789-".indexOf(s[0]) >= 0;
}

function geocodeQuery(query) {

  const select = document.getElementById('searchCombo');
  select.innerText = "";
  toggleDiv("searchSpan", true);

  if (isCoordinate(query)) {
    const loc = getCoordinateFromText(query);
    const pin = addPinAt(loc)
    searchPins.push(pin);
    // map.entities.push([pin]);
    // map.setView({center: loc});
    return;
  }
  fetch(`https://nominatim.openstreetmap.org/search?q=${query}&format=json`)
    .then(response => response.json())
    .then(data => {
      const opt0 = document.createElement('option');
      opt0.value = "0";
      let text = "Ei löytynyt";
      if (data.length === 1) {
        text = "Löytyi 1 kohde: ";
      }
      if (data.length > 1) {
        text = "Löytyi " + data.length + " kohdetta: ";
      }
      opt0.text = text;
      select.appendChild(opt0);

      if (data.length > 0) {
        // console.log('Löytyi useita tuloksia:', data.length);
        data.forEach((item, i) => {
          // console.log(`${i + 1}: ${item.display_name} — lat: ${item.lat}, lon: ${item.lon}`);
          // noinspection JSUnresolvedReference
          const pin = createPin([item.lat,item.lon], `s${i+1}`, 'violet', item.display_name);
          searchPins.push(pin)
          // noinspection JSUnresolvedReference
          const opt = (i + 1) + ') ' + item.display_name;
          const option = document.createElement('option');
          option.value = "" + (i + 1);
          option.text = opt;
          select.appendChild(option);
        });
      }
    })
    .catch(err => console.error('Virhe:', err));
}

let _lastSelected = null;

Object.defineProperty(window, 'lastSelected', {
  get() {
    return _lastSelected;
  },
  set(pin) {
    setLastSelected(pin);
  }
});

function setLastSelected(pin) {
  _lastSelected = pin;
  // Tee tässä mitä haluat, esim. loggaa tai muuta logiikkaa
  const pinButtonsDiv = document.getElementById('pinButtons');
  if (pin && pin !== myPin && pin !== hitPin) {
    pinButtonsDiv.style.display = 'inline-block';
  } else {
    pinButtonsDiv.style.display = 'none';
  }
}

function removePin(pin = lastSelected) {
  if (pin === myPin || pin === hitPin)  return;
  if (pin === lastSelected) lastSelected = null;
  mapWrapper.removePin(pin);
}

function clearSearchResults() {
    if (searchPins.length > 0) {
        searchPins.forEach(pin => {
            if (pin === lastSelected) lastSelected = null;
            mapWrapper.removePin(pin);
        });
        searchPins = [];
    }
    toggleDiv('searchSpan', false)
}

function search() {
    //Remove any previous results from the map.
    clearSearchResults();
    //Get the users query and geocode it.
    const query = getPinInputText();
    geocodeQuery(query);
}

function getCoordinateFromText(s) {
  // Etsitään koordinaatit tekstistä
  const latLongArray = s.split(/[\s,]+/);
  if (latLongArray.length < 2) return null;
  const lat = parseFloat(latLongArray[0]);
  const lng = parseFloat(latLongArray[1]);
  if (isNaN(lat) || isNaN(lng)) return null;
  return [lat, lng];
}

let distanceLines = [];

function calcDistance(idx1 = -1000, idx2 = -1000) {
  let d = 0;
  let sum = 0;
  if ( !hitPin ) return;
  let from = null;
  if (idx1 === -1) {
    if (distanceLines.length >= 1) {
        lastHitPoint = distanceLines[distanceLines.length - 1].from;
    }
  }
  const to = mapWrapper.getPinLocation(hitPin);
  if ( lastSelected ) {
    from = mapWrapper.getPinLocation(lastSelected);
    mapWrapper.removeLines(distanceLines);
  } else {
    if (!lastHitPoint) return;
    from = lastHitPoint;
  }
  if (!options.calcDistanceSum) {
    mapWrapper.removeLines(distanceLines);
  }
  d = WGS84_distance(from, to);
  const deg = bearingDegrees(from, to);
  const s  = `${d.toFixed(3)} km, ${deg.toFixed(1)}°`;
  if (idx1 >= -1) mapWrapper.removeLines(distanceLines, idx1, idx2);
  distanceLines = mapWrapper.addLines(distanceLines, from, to, {
    color: 'red',
    weight: 1,
    opacity: 0.8
  }, s, options.drawDistanceLine);
  const line = distanceLines[distanceLines.length - 1];
  line.d = d;
  line.deg = deg;
  for (let i = 0; i < distanceLines.length; i++) {
    if (distanceLines[i].d) sum += distanceLines[i].d;
  }
  if (!dstTextElem) dstTextElem = document.getElementById("distance");
  if (sum !== d) dstTextElem.innerText = s + ` = ${sum.toFixed(3)} km`;
  else dstTextElem.innerText = s;
}


function selectActivePin(pin, calcDist) {
  changeSelected(pin, true);
  mapWrapper.selectPin(pin, true);
  if ( calcDist ) {
    mapWrapper.setPinOn(pin, 'drag', calcDistance);
    calcDistance();
  }
}

function getPinValues(pinLoc, defLoc=null, defLabel=null) {
  if (!pinLoc) return [defLoc, defLabel];
  let name = defLabel;
  const latLongArray = pinLoc.split(/[\s,]+/);
  let loc = getCoordinateFromText(pinLoc);
  if (!loc) loc = defLoc;
  if (latLongArray.length >= 3) name = latLongArray[2];
  if ( name === undefined || name === "H" || name === "" )
      name = defLabel;
  return [loc, name];
}


function addPinAt(pinLoc, label = null) {
  /*
  let loc = mapWrapper.getPinLocation(hitPin);
  let name = "" + pinNr;
  if (pinLoc) {
    const latLongArray = (pinLoc).split(/[\s,]+/);
    loc = getCoordinateFromText(pinLoc);
    if (latLongArray.length >= 3) name = latLongArray[2];
    if ( name === undefined || name === "H" || name === "" )
      if (label) name = label; else name = ""+pinNr++;
  }
  else pinNr++;
  */
  let [loc, name] = getPinValues(pinLoc, mapWrapper.getPinLocation(hitPin), label);
  if (!loc) return null;
  if (!name) name = "" + pinNr++;

  return createPin(loc, name, 'blue');
}


function changePinData(pin = lastSelected, s = null) {
    if (pin === myPin || pin === hitPin) return;
    if (s == null) s = getPinInputText();
    if (isCoordinate(s)) {
      const [loc, label] = getPinValues(s, null, null);
      if (loc) mapWrapper.setPinLocation(pin, loc);
      if (label) mapWrapper.setPinLabel(pin, label);
    } else {
       mapWrapper.setPinLabel(pin, s);
    }
}



function addPin() {
   const s = getPinInputText();
   if ( s !== "" && !isCoordinate(s) ) return search();
   const pin = addPinAt(s);
   mapWrapper.setPinDragging(pin, true);
   if (options.selectNewPin) {
     selectActivePin(pin, true);
   }
}


function checkAddPinText() {
   let text = "Lisää pinni";
   if (window.innerWidth < 400) text = "Lisää";
   const s = getPinInputText()
   if ( s !== "" && !isCoordinate(s) ) text = "Etsi";
   document.getElementById('buttonAddPin').innerText = text;
}

function getPinInputText() {
  let s = sanitizeInput(document.getElementById('editPinLoc').value.trim());
  return s;
}

function setPinInputText(s) {
    document.getElementById('editPinLoc').value = s.trim();
    checkAddPinText();
}

function setHitPinLoc(loc, idx1 = -1000, idx2 = -1000) {
  if (!hitPin) return;
  mapWrapper.setPinLocation(hitPin, loc);
  calcDistance(idx1, idx2);
}


function initializeMapPage() {

  checkSavedValues();

  mapWrapper = new MapWrapper('map', mapModes, options.useCache);
  // Täytetään select-valikko
  const mapSelect = document.getElementById('mapModeSelect');
  for (const key in mapModes) {
    const option = document.createElement('option');
    option.value = key;
    option.textContent = key;
    mapSelect.appendChild(option);
  }

  // Alustetaan valinta ja kartta
  mapSelect.value = "OpenStreet";
  mapWrapper.setMapMode(mapSelect.value);

  // Kuunnellaan valikon muutosta
  mapSelect.addEventListener('change', (e) => {
    mapWrapper.setMapMode(e.target.value);
  });

  // Ensimmäinen sijainnin hakukutsu, tarkalla sijainnilla
  navigator.geolocation.getCurrentPosition(function(position) {
    const lat = position.coords.latitude;
    const lng = position.coords.longitude;

    myPin = createPin([lat, lng], 'I', 'green', "Olet tässä");

    // Siirretään kartta käyttäjän sijaintiin
    mapWrapper.setView([lat, lng]);
  }, function(err) {
    console.error("Sijainnin haku epäonnistui:", err);
  }, {
    enableHighAccuracy: true,
    timeout: 10000,
    maximumAge: 0
  });

  // Seurataan sijainnin muutoksia
  navigator.geolocation.watchPosition(function(pos) {
    const lat = pos.coords.latitude;
    const lng = pos.coords.longitude;
    mapWrapper.setPinLocation([lat, lng]);
  }, function(err) {
    console.error("Sijainnin päivitys epäonnistui:", err);
  }, {
    enableHighAccuracy: true,
    timeout: 10000,
    maximumAge: 0
  });

  async function getElevation(loc) {
  // Hae korkeus OpenTopoDatasta
    const url = cycloServerUrl + `/index.php?elev=${loc[0]},${loc[1]}`;
    let elevation = ''

    try {
      const response = await fetch(url);
      const data = await response.text();
      const ndata = Number(data);

      if (!isNaN(ndata)) {
        elevation = ndata.toFixed(0) + " m";
        // console.log("Korkeus:", elevation);

        // Päivitä pinin teksti näyttämään korkeus (pyöristetty)
        // hitPin.setIcon(customPin(`${Math.round(elevation)}m`, 'red', 'black'));
      }
    } catch (err) {
      // console.error("Korkeuden haku epäonnistui:", err);
    }
    return elevation;
  }


  mapWrapper.on('click', async (e) => {
    closeNav();
    if (e.originalEvent && e.originalEvent.target.id === 'mapModeSelect') return;
    const { lat, lng } = e.latlng;
    const loc = [lat, lng];
    if (!hitPin) {
      // Luo hitPin ensimmäisellä klikkauksella
      hitPin = mapWrapper.createPin(loc, 'H', 'red', function() {
        lastHitPoint = mapWrapper.getPinLocation(hitPin);
        calcDistance();
        // setPinText(`${lastHitPoint[0].toFixed(5)} ${lastHitPoint[1].toFixed(5)} Hi`);
        // calcDistance();
        // lastHitPoint = mapWrapper.getPinLocation(hitPin);
      });
      mapWrapper.setPinDragging(hitPin, true);
      mapWrapper.setPinOn(hitPin, 'dragend', function() {
        // Kun hitPin on siirretty, päivitetään sen sijainti
        calcDistance(-1, -1);
        lastHitPoint = mapWrapper.getPinLocation(hitPin);
        if (options.HCenter && options.HStationary) {
          // preventMapMove = true;
          mapWrapper.setView(lastHitPoint);
        }
        hitPinXY = mapWrapper.getCoordXY(lastHitPoint);
      });
      mapWrapper.setPinOn(hitPin, 'drag', function() {
        // Kun hitPin on siirretty, päivitetään sen sijainti
        const loc = mapWrapper.getPinLocation(hitPin);
        setPinInputText(`${loc[0].toFixed(5)} ${loc[1].toFixed(5)} H`);
        calcDistance(-1, -1);
      });
      mapWrapper.setPinOn(hitPin, 'drag', function() {
        // Kun hitPin on siirretty, päivitetään sen sijainti
        const loc = mapWrapper.getPinLocation(hitPin);
        setPinInputText(`${loc[0].toFixed(5)} ${loc[1].toFixed(5)} H`);
        calcDistance(-1, -1);
      });
    } else
    // Siirrä olemassa olevaa hitPiniä uuteen paikkaan
    if (distanceLines.length > 0) {
      lastHitPoint = distanceLines[distanceLines.length - 1].to;
    }
    mapWrapper.setPinLocation(hitPin, loc);
    setHitPinLoc(loc);
    hitPinXY = mapWrapper.getCoordXY(mapWrapper.getPinLocation(hitPin));
    lastHitPoint = loc;

    const elevation = await getElevation(loc);

    setPinInputText(`${lat.toFixed(5)} ${lng.toFixed(5)} H ${elevation}`);
    if (options.HCenter && options.HStationary) {
      mapWrapper.setView(loc);
    }

  });  // mapWarpper.on end

  mapWrapper.on('move', mapMove);

  prefixHelpLinks();

  if ( options.id !== "" )
	  toggleDiv("accountArea", false);
	else
	  toggleDiv("followArea", false);

  document.getElementById('searchCombo').addEventListener('change', function() {
    const idx = this.selectedIndex-1; // first is number of items found
    if (idx >= 0 && idx < searchPins.length) {
      const pin = searchPins[idx];
      mapWrapper.setView(mapWrapper.getPinLocation(pin));
      changeSelected(pin, true);
    }
  });

//if ('serviceWorker' in navigator) {
//  navigator.serviceWorker.register('sw.js');
//}

} // initializeMapPage ends


function changeSelected(pin, selected=true) {
  if (lastSelected === pin) { // Jos sama pin on jo valittu, poistetaan valinta
    mapWrapper.selectPin(pin, false);
    mapWrapper.setPinOn(lastSelected, 'drag', calcDistance, true);
    window.lastSelected = null;
    return;
  }

  if (lastSelected) {
    mapWrapper.selectPin(lastSelected, false);
    mapWrapper.setPinOn(lastSelected, 'drag', calcDistance, true);
  }
  lastSelected = pin;
  if (pin)  {
    mapWrapper.selectPin(pin, selected);
  }
  if (selected) {
    mapWrapper.setPinOn(pin, 'drag', calcDistance);
    displayLocPin(pin);
  }
}

function createPin(coord, label, color, text = null) {
  return mapWrapper.createPin(coord, label, color, function(pin) {
    changeSelected(pin);
  }, text);
}

function closeParent(element) {
  if (element.parentElement) {
    element.parentElement.style.display = 'none';
  }
}

let mySidenavElem = null;
let menuElem = null;

function checkMenuElements() {
  if (menuElem === null) {
    menuElem = document.getElementById("menu");
    mySidenavElem = document.getElementById("mySidenav");
  }
}

function isMenuOpen() {
  checkMenuElements()
  let s = menuElem.style;
  return s.visibility === "visible";
}

function openNav() {
  if ( isMenuOpen() ) { closeNav(); return; }
  let s = menuElem.style;
  // s.width = "300px";
  // s.height = "350px";
  s.visibility = "visible";
  s = mySidenavElem.style;
  s.visibility = "visible";
}


function closeNav() {
  checkMenuElements()
  let s = mySidenavElem.style;
  s.visibility = "hidden";
  s = menuElem.style;
  s.visibility = "hidden";
}

function toggleDiv(divId, force = null) {
  const div = document.getElementById(divId);
  let show = div.style.display !== 'block';
  if (force !== null) {
    show = force;
  }
  if (show) {
    div.style.display = 'block';
    div.style.visibility = 'visible';
  } else {
    div.style.display = 'none';
    div.style.visibility = 'hidden';
  }
}


function findMyPlace() {
  if (!myPin) return;
  // Siirretään kartta käyttäjän sijaintiin
  const center = mapWrapper.getPinLocation(myPin);
  mapWrapper.setView(center);
}

function toggleFullscreen() {
  const elem = document.documentElement; // Käytetään koko sivua

  // noinspection JSUnresolvedReference
  if (document.fullscreenElement || document.mozFullScreenElement || document.webkitFullscreenElement || document.msFullscreenElement) {
    // Poistetaan fullscreen-tila
    if (document.exitFullscreen) {
      document.exitFullscreen();
    } else { // noinspection JSUnresolvedReference
      if (document.mozCancelFullScreen) { // Firefox
            document.mozCancelFullScreen();
      } else { // noinspection JSUnresolvedReference
        if (document.webkitExitFullscreen) { // Chrome, Safari ja Opera
                    document.webkitExitFullscreen();
              } else { // noinspection JSUnresolvedReference
          if (document.msExitFullscreen) { // IE/Edge
                              document.msExitFullscreen();
                        }
        }
      }
    }
  } else {
    openFullscreen(elem);
  }
}

function openFullscreen(elem) {
  if (elem.requestFullscreen) {
    elem.requestFullscreen();
  } else { // noinspection JSUnresolvedReference
    if (elem.mozRequestFullScreen) { // Firefox
        elem.mozRequestFullScreen();
      } else { // noinspection JSUnresolvedReference
      if (elem.webkitRequestFullscreen) { // Chrome, Safari and Opera
              elem.webkitRequestFullscreen();
            } else { // noinspection JSUnresolvedReference
        if (elem.msRequestFullscreen) { // IE/Edge
                      elem.msRequestFullscreen();
                    }
      }
    }
  }
}


function adjustComponents() {
  /*  TODO: korjaa komponenttien muokkaus
   saveComponents();
   const compsdiv = document.getElementById("showComps");
   compsdiv.style.backgroundColor = document.getElementById("editCompsBackground").value;
   compsdiv.style.color = document.getElementById("editCompsColor").value;
   createComps();
   checkTimer("showTime", timecomponents.length === 0 || !options.useComps);
   */
}



window.addEventListener('DOMContentLoaded', initializeMapPage)

function setOption(name,value) {
  options[name] = value;
  localStorage.setItem(name,value);
}


function setOptionInt(name,value,def) {
  const val = parseInt(value) || def;
  options[name] = val;
  localStorage.setItem(name, ""+val);
}


function getOptionValue(name) {
  return localStorage[name];
}


function getOption(name,editName) {
  const edit = document.getElementById(editName);
  if (!edit) return;
  options[name] = params[name] || localStorage.getItem(name) || "";
	if (options[name] !== "")
	  edit.value = options[name]; //document.getElementById(edit).value = options[name];
	// noinspection JSUnusedLocalSymbols
  edit.addEventListener("change", function(event) {
    setOption(name, this.value);
  });
  setOption(name,edit.value);
}


function getOptionInt(name,editName, def) {
  const edit = document.getElementById(editName);
  if (!edit) return;
  const val = parseInt(localStorage.getItem(name)) || def;
  options[name] = params[name] || val || def;
  if (options[name] !== "")
    edit.vallue = options[name];
  // noinspection JSUnusedLocalSymbols
  edit.addEventListener("change", function(event) {
    setOptionInt(name,this.value, def);
  });
  setOptionInt(name,edit.value,def);
}


function getBoolean(s) {
   if (typeof(s) === typeof true) return s;
   if ( s === '1') return true;
   s = s.toUpperCase();
   if ( s === "TRUE") return true;
   return s === "YES";

}


function setCBOption(name,value) {
  if ( value === undefined ) return;
  value = getBoolean(value);
  options[name] = value;
  localStorage.setItem(name,value);
}


function getCBOption(name,f) {
  const cb = document.getElementById(name);
  if (!cb)
    return;
  let value = params[name];
  if ( value === undefined ) value = getBoolean(localStorage.getItem(name) || options[name] || false);
  else value = getBoolean(value);
  options[name]= value;
  if (options[name]) {
     cb.checked = true;
     options[name] = true; // ??? ei kai tarviisi
  } else options[name] = false;

  // noinspection JSUnusedLocalSymbols
  cb.addEventListener("click", function(event) {
    setCBOption(name, this.checked);
    if (typeof f !== "undefined") f(this.checked);
  });
  setCBOption(name,cb.checked);
}

function changeRaportView() {
  // TODO: korjaa raportin näkymä
  /*
  const sb = document.getElementById("editRaport").style;
  const ss = document.getElementById("editSmallRaport").style;
  if ( options.smallRaport ) {
  //      closeDiv("editRaport");
  //      openDiv("editSmallRaport");
    sb.height = "0px";
    sb.visibility = "hidden";
    ss.height = "auto";
    ss.visibility = "inherit";
  } else {
    //      openDiv("editRaport");
    //      closeDiv("editSmallRaport");
    ss.height = "0px";
    ss.visibility = "hidden";
    sb.height = "auto";
    sb.visibility = "inherit";
  }
  */
}


  // Ks: https://github.com/richtr/NoSleep.js/blob/master/src/index.js
// The wake lock sentinel.
if ('wakeLock' in navigator) { options.hasWakeLock = true; }
let wakeLock = null;

// Function that attempts to request a screen wake lock.
// async // IE11 does not like async, but we manage without it using then and teh fact that this is never called in ie
function requestWakeLock()  {
  // alert('Start Wake Lock 2');
  endWakeLock();
  if (document.visibilityState === "hidden") return;
  try {
    // noinspection JSUnresolvedVariable
    // wakeLock = await navigator.wakeLock.request('screen'); // does not work on ie
    // wakeLock.addEventListener('release', function() {/* alert('Screen Wake Lock was released'); */ });
    // alert('Screen Wake Lock is active');
    navigator.wakeLock.request('screen').then(function(wl) {
      wakeLock = wl;
      wakeLock.addEventListener('release', function() {
        // alert('Screen Wake Lock was released'); */
        });
      document.addEventListener('visibilitychange', handleVisibilityChange);
      // alert('Screen Wake Lock is active');
    });
  } catch (err) {
    alert(err.name + err.message);
  }
}

if ('wakeLock' in navigator) {
  options.hasWakeLock = true;
}

function handleVisibilityChange() {
  if (wakeLock !== null && document.visibilityState === 'visible') {
    requestWakeLock();
  }
}


function startWakeLock() {
  // alert('Start Wake Lock 1');
	requestWakeLock();
}



function endWakeLock() {
   if ( !wakeLock ) return;
   wakeLock.release();
   document.removeEventListener('visibilitychange', handleVisibilityChange);
   wakeLock = null;
   // alert('Wake Lock released');
}


function checkSleep() {
   if ( options.preventSleep && options.hasWakeLock ) { startWakeLock(); }
   if ( !options.preventSleep ) { endWakeLock(); }
}


function removeDistance() {
    mapWrapper.removeLines(distanceLines);
    lastHitPoint = mapWrapper.getPinLocation(hitPin);
}

function checkSavedValues() {
  if ( !options.hasWakeLock ) {
    const s = document.getElementById("preventSleepSpan").style;
    s.visibility = "hidden";
  }

  getOption("followMeColor","editFollowMeColor");
  getOptionInt("followMeWidth","editFollowMeWidth", 3);

  getOption("email","editEmail");
  getOption("id","editId");
  getOption("usersTofollow","editUsersTofollow");
  getOption("to","editTo");
  getOption("from","editFrom");
  getOption("tpR","editTPR");

  getOption("tag","editTag");
  getOption("logname","editLog");
  getOption("interval","editInterval");
  getOption("trackColors","editTrackColors");
  getOption("routeColors","editRouteColors");

  getCBOption("follow",function(checked) { checkTimer("follow", !checked); } );
  getCBOption("followMe",function() { /*checkTimer("followMe");*/ } );
  getCBOption("selectNewPin",function() { /*checkTimer("followMe");*/ } );
  // getCBOption("useDummyRect",function() { /*checkTimer("followMe");*/ } );
  getCBOption("preventSleep",function() { checkSleep(); } );
  getCBOption("smallRaport",function() { changeRaportView(); } );
  // getCBOption("showAccuracy");
  getCBOption("useCache",function() { if (mapWrapper) mapWrapper.setUseCache(options.useCache); });
  getCBOption("HStationary");
  getCBOption("HCenter");
  getCBOption("send"); // ,sendPosition);
  getCBOption("drawLogLine");
  // getCBOption("readGPS",function() { checkTimer("readGPS"); });
  getCBOption("readGPS",function() { checkGeoLocation(); });
  getCBOption("useComps",function() { checkShowComponents(); });
  getCBOption("useCompsWindow");
  getCBOption("drawDistanceLine");
  getCBOption("calcDistanceSum");

  const cb1 = document.getElementById('area1cb');
  const cb2 = document.getElementById('area1cbCopy');



  for (let area of areaDatas) {
    getCBOption(area.cb, function() { checkArea(area);});
    getCBOption(area.cb+ "Own", function() { checkAreaColor(area);});
    getOption(area.cb + "Opt", area.cb + "Opt")
  }

  // Sync the two checkboxes
  cb1.addEventListener('change', syncCheckboxes);
  cb2.addEventListener('change', syncCheckboxes);
  function syncCheckboxes(e) {
      cb1.checked = cb2.checked = e.target.checked;
      if (e.target === cb2) {
        // Trigger cb1's change event so all logic runs
        cb1.dispatchEvent(new Event('click', { bubbles: true }));
      }
  }
  cb2.checked = cb1.checked;

  checkTimer("follow", !options.follow);
  // checkTimer("readGPS");
  changeRaportView();

  checkSleep(); // check if use wake lock or not

  /*
  options.follow=getCookie("follow"); if (options.follow=="true") { document.getElementById('follow').checked = true; options.follow = true; } else options.follow = false;
  options.showAccuracy=getCookie("showAccuracy"); if (options.showAccuracy=="true") { document.getElementById('showAccuracy').checked = true; options.showAccuracy = true; } else options.showAccuracy = false;
  options.HCenter=getCookie("HCenter"); if (options.HCenter=="true") { document.getElementById('HCenter').checked = true; options.HCenter = true; } else options.HCenter = false;
  options.showAccuracy=getCookie("showAccuracy"); if (options.showAccuracy=="true") { document.getElementById('showAccuracy').checked = true; options.showAccuracy = true; } else options.showAccuracy = false;
  checkTimer("follow");
  */
}

async function clearServiceWorker() {
  if ('serviceWorker' in navigator) {
    // Unregister all service workers for this origin
    const regs = await navigator.serviceWorker.getRegistrations();
    for (let reg of regs) {
      await reg.unregister();
    }
    // Optionally, clear caches
    if ('caches' in window) {
      const names = await caches.keys();
      for (let name of names) {
        await caches.delete(name);
      }
    }
    location.reload(); // Reload the page to ensure everything is reset
  }
}

</script>
<div id="mySidenavHamburger" style="top: 0; left: 0; width: 30px; height: 35px; position: absolute; z-index:3600;  background-color: lightgray;">
  <span style="font-size:30px;cursor:pointer" onclick="openNav()">&#9776;<br></span>
  <span style="font-size:30px;cursor:pointer" onclick="findMyPlace()">&#9737;</span>
</div>

<div id="mySidenav" style="top: 45px; left: 0;  visibility: hidden; position: absolute; z-index:3500;  background-color: lightgray;" onclick="closeNav()">
  <label class="closebtn" style="visibility: hidden" onclick="closeNav()">&times;</label>

  <ul class="ui-menu" id="menu" style="visibility: hidden">
  <li><span onclick="toggleDiv('settings');">Asetukset...</span> <a class="help" data-href="#settings"></a></li>
  <li><span onclick="toggleDiv('findDiv'); closeNav();">Pinnien lisääminen...</span> <a class="help" data-href="#addpins"></a></li>
  <li><span onclick="showRoutePane(); closeNav()">Ajo-ohjeet...</span> <a class="help" data-href="#directions"></a></li>
  <li><span onclick="toggleDiv('loadTrack'); ">Lataa track-tiedosto...</span> <a class="help" data-href="#loadtrack"></a></li>
  <li><span onclick="toggleDiv('trackDiv'); ">Näytä track-tiedot</span> <a class="help" data-href="#showtrackdetails"></a></li>
  <li><span onclick="toggleDiv('loadRoute'); ">Lataa reittitiedosto...</span>  <a class="help" data-href="#loadroute"></a></li>
  <li><span onclick="toggleDiv('routeDiv'); ">Reitin suunnittelu...</span> <a class="help" data-href="#routeplan"></a></li>
  <li><span onclick="toggleDiv('routeRaport'); ">Reittiraportti...</span> <a class="help" data-href="#routeraport"></a></li>
  <li><span onclick="toggleDiv('loadAreas'); ">Alueet...</span>  <a class="help" data-href="#areas"></a></li>
  <li><span onclick="googleDirections();">Ajo-ohjeet Google Mapsillä</span> <a class="help" data-href="#googledirections"></a></li>
  <li><span onclick="toggleFullscreen()">Fullscreen</span></li>
  <li><span onclick="toggleDiv('about'); ">Pika-apu...</span></li>
  </ul>
  <!--Muista muuttaa korkeus openNav  (tai tee tähän tyyli automaattiseksi) -->
</div>


<div class="layout-container">
<!--suppress HtmlFormInputWithoutLabel -->
<div id="findDiv" class="ui-layout-north">
  <label class="closebtn" style="top: -10px" onclick=closeParent(this)>&times;</label>
  <div id="pinDiv" style="margin-left: 35px">
    <!-- <label class="hamburgerSpace"> </label> -->
    <label><!--suppress JSDeprecatedSymbols -->
      <input type="text" name="editPinLoc" id="editPinLoc" value="Tontuntie"
           onkeyup="checkAddPinText()"
           onkeydown="if(event.key === 'Enter') { addPin(); event.preventDefault(); }" /></label>
    <span class ="clearButton" id="buttonClearText" onclick="setPinInputText('')">x</span>
    <button type="button" id="buttonAddPin" onclick="addPin()">Etsi</button>
    <span id="pinButtons" style="display: none;">
      <button title="Vaihda pinnin tiedot" class="icon-btn" onclick="changePinData()">
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="black" stroke-width="2">
          <path d="M3 17.25V21h3.75l11.06-11.06-3.75-3.75L3 17.25z"/>
          <path d="M20.71 7.04a1 1 0 0 0 0-1.42l-2.34-2.34a1 1 0 0 0-1.42 0l-1.83 1.83 3.75 3.75 1.84-1.82z"/>
        </svg>
      </button>
      <button title="Poista pinni" class="icon-btn"  onclick="removePin()">
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="black" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <rect x="3" y="6" width="18" height="15" rx="2"/>
          <line x1="9" y1="10" x2="9" y2="19"/>
          <line x1="15" y1="10" x2="15" y2="19"/>
          <line x1="4" y1="6" x2="20" y2="6"/>
          <line x1="10" y1="3" x2="14" y2="3"/>
          <line x1="12" y1="3" x2="12" y2="6"/>
        </svg>
      </button>
    </span>
    <a class="help" data-href="#find"></a>
    <div style="display: inline-block; margin-left: 10px; white-space: nowrap;">
      <span id="searchSpan" style="visibility: hidden; display: none;">
        <label><select id="searchCombo" ></select></label>
        <span class="searchClass" id="searchMsg"></span>
        <label class="closebtn2" style="margin-top: 10px;" onclick="clearSearchResults()">&times;</label>
      </span>
    </div>
    <span class="errorClass" id="errorMsg"></span>
  </div>
</div>

<div class="ui-layout-center">
  <div id='map'></div>
  <div class="logo"></div>
  <div class="mapType">
      <div class="ui-widget" style="z-index: 1001;">
        <label class="hamburgerSpace"><select id="mapModeSelect"></select></label>&nbsp;
        <span  id="distance" onclick="removeDistance()">0 km</span>
      </div>
    </div>
    <div class="area1CBcopy">
      <label for="area1cbCopy">✈️</label><br><input type="checkbox" title="Ilmatilat" id="area1cbCopy" name="area1cbCopy" value="area1cbCopy" />
    </div>
</div>
</div>

<div class="popup" id="settings" style="">
  <label class="closebtn" onclick="toggleDiv('settings'); adjustComponents()">&times;</label>
  <div class="popupIn">
    <h2>Asetukset</h2>
    <label><input type="checkbox" id="HStationary" value="HStationary"  />Pidä H paikallaan</label>
    <label><input type="checkbox" id="HCenter" value="HCenter"  />Pidä H keskellä <a class="help" data-href="#othersettings"></a></label><br>
    <!-- <input type="checkbox" id="showAccuracy" value="showAccuray"  />Näytä tarkkuusympyrä<br> -->
    <label><input type="checkbox" id="readGPS" value="readGPS"  />Lue GPS:ää</label><br>
    <label><input type="checkbox" name="followMe" id="followMe" value="followMe"  />Piirrä oma jälki</label>
    <label><input type="text" name="editFollowMeColor" id="editFollowMeColor" value="orange" size="8" /></label>
    <label><input type="text" name="editFollowMeWidth" id="editFollowMeWidth" value="3" size="1" /> pt</label><br>
    <label><input type="checkbox" name="selectNewPin" id="selectNewPin" value="selectNewPin"  />Valitse uusi pin aktiiviseksi</label><br>
    <!-- <input type="checkbox" name="useDummyRect" id="useDummyRect" value="useDummyRect"  />Käytä tyhjää hakualuetta (jos ei osaa hakea)<br> -->
    <span id="preventSleepSpan"><label><input type="checkbox" name="preventSleep" id="preventSleep" value="preventSleep"  />Estä näytön sammuminen</label></span><br>
    <span id="spanUseCache"><label><input type="checkbox" name="useCache" id="useCache" value="useCache"  />Käytä paikallista muistia <a class="help" data-href="#usecache"></a></label></span>
    <button id="clear-worker" onclick="clearServiceWorker()">Tarkista uusi versio</button><br>
    <label><input type="checkbox" id="drawDistanceLine" value="drawDistanceLine"  />Piirrä mittaviivaa</label>
    <label><input type="checkbox" id="calcDistanceSum" value="calcDistanceSum"  />Laske summaa <a class="help" data-href="#addpins"></a></label><br>
    <br><br>


    <div class="ui-widget" id="followDiv">
      <div id="followArea">
        <button type="button" onclick="toggleDiv('followArea', false); toggleDiv('accountArea', true);" >Tilaa käyttäjätunnus (ID)...</button><a class="help" data-href="#userid"></a>
        <hr>
        <div id="accountArea2"><p><b>Oman paikan lähettäminen ja muiden seuraaminen:</b><a class="help" data-href="#followsettings"></a></p>
          <label for="editTag">Kartalla näkyvä tunnus: </label><input type="text" name="editTag" id="editTag" value="" size="5" /><br>
          <label for="editLog">logname: </label><input type="text" name="editLog" id="editLog" value="" size="12" /><br>
          <label for="editInterval">interval/ms: </label><input type="text" name="editInterval" id="editInterval" value="5000" size="8" /><br>
          <label for="editUsersTofollow">Seurattavat käyttäjät: </label><input type="text" name="editUsersTofollow" id="editUsersTofollow" value="" size="15" /><br>
        </div>
        <br>
        <button type="button" onclick="getfollow(); closeDiv('settings');">Hae muiden paikka</button> (jos automaatti ei ole päällä)<br>
        <br>
        <label><input type="checkbox" name="follow" id="follow" value="follow"  />Seuraa muita automaattisesti</label><br>
        <label><input type="checkbox" name="drawLogLine" id="drawLogLine" value="drawLogLine"  />Piirrä viivaa seurattavista</label><br>
        <label><input type="checkbox" id="send" value="send"  />Lähetä omaa paikkaa</label><br>
        <hr>
        <div id="compArea"><p><b>Mittareiden arvot</b> <a class="help" data-href="#gauges"></a></p>
          <label><input type="checkbox" name="useComps" id="useComps" value="useComps"  />Näytä mittarit</label><br>
          <div id="showCompsSettings">
            <label><input type="checkbox" id="useCompsWindow" value="useCompsWindow"  />Näytä ikkunassa</label><br>
            <span><br>Taustan väri: </span> <label><input type="text" id="editCompsBackground" value="rgba(0,0,0,1.0)"  /></label><br>
            <span><br>Fontin väri: </span> <label><input type="text" id="editCompsColor" value="white"  /></label><br>
            <span style="font-size: 10px">Ruksi mittarit joita haluat käyttää</span>
            <table id="tableCompsSettings">
            </table>
          </div>
        </div>
        <button class="close" onclick="toggleDiv('settings'); adjustComponents()">Sulje</button>
      </div>
      <div id="accountArea">
        <br>

        <label for="editEmail">Email: </label><input type="text" name="editEmail" id="editEmail" value="" size="25" /><a class="help" data-href="#userid"></a><br>
        <label for="editId">id: </label><input type="text" name="editId" id="editId" value="" size="15" /><br>
        <br>
        <button id="getId">Hae uusi ID</button><a class="help" data-href="#userid"></a>
        <br>
        <br>
        <span class="idMsg" id = "idMsg"></span>
        <br>
        <button type="button" onclick="toggleDiv('followArea', true); toggleDiv('accountArea', false);" >Palaa seuranta-asetuksiin...</button>
      </div>
    </div>
  </div>
</div>

<div class="popup" id="about" style=" ">
  <label class="closebtn" onclick="toggleDiv('about')">&times;</label>
  <div class="popupIn">
  <h2>Pika-ohjeet</h2>
  <p>Dataa tähän karttaan voit lähettää <a href="https://trac.cc.jyu.fi/projects/dotnet/wiki/CycloLite">CycloLite</a>llä,
  <a href="https://play.google.com/store/apps/details?id=jyu.sendpos&hl=en_IE">SendPos Androidilla</a>
    tai <a href="s.html">Lähetys-sivulla</a>.</p>
  <p>
    Tunnukset voit tehdä <a href="javascript:void(0)" onclick="toggleDiv('about'); toggleDiv('settings')">asetuksista</a> tai
  <a href="account.html">tilien hallinta</a>-sivulla.
  </p>
  <p>
  <a href="https://tim.jyu.fi/view/users/vesal/riippu/cyclo/kartta" target="blank">Ohjeet</a>.
  </p>
   <button class="close" onclick="toggleDiv('about')">Sulje</button>
  </div>
</div>

<div class="popup" id="loadAreas" style=" ">
  <label class="closebtn" onclick="toggleDiv('loadAreas')">&times;</label>
  <div class="popupIn">
    <h2>Alueet</h2>
    <p>Valitse mitä alueita haluat käyttää</p>
    <div id="loadAreasIn">
      <table>
        <tr><th>Alue</th><th>Oma väritys</th><th>Optiot</th></tr>
        <tr><td><label><input type="checkbox" name="area1cb" id="area1cb" value="area1" />Alue 1</label></td>
            <td><label><input type="checkbox" name="area1cbOwn" id="area1cbOwn" value="area1" /></label></td>
            <td><label><input type="text" name="area1cbOpt" id="area1cbOpt" value="c:gray/60,w:8,f:" /></label></td>
        </tr>
        <tr><td><label><input type="checkbox" name="area2cb" id="area2cb" value="area2" />Alue 1</label></td>
            <td><label><input type="checkbox" name="area2cbOwn" id="area2cbOwn" value="area2" /></label></td>
            <td><label><input type="text" name="area2cbOpt" id="area2cbOpt" value="c:red/60,w:8,f:red/30" /></label></td>
        </tr>
        <tr><td><label><input type="checkbox" name="area3cb" id="area3cb" value="area3" />Alue 1</label></td>
            <td><label><input type="checkbox" name="area3cbOwn" id="area3cbOwn" value="area3" /></label></td>
            <td><label><input type="text" name="area3cbOpt" id="area3cbOpt" value="c:red/80,w:8,f:red/30" /></label></td>
        </tr>
      </table>
      <br>
      <p>Tarkista kuitenkin alueiden korkeudet ja voimassaoloajat <a id="flykLink" href="https://flyk.com/map?lang=fi&pilot#p=7.11/60.837/27.172" target="flyk">FLYK-kartasta</a>!</p>
      <!--
      <p>Muut alueet: (kirjoita URL-osoiteet, joista saadaan ladattua alueiden JSONit)</p>
      <textarea  name="editRaport" id="editLoadAreas" class="loadAreasTextArea"  rows="10">
      </textarea>
      -->
   </div>
  </div>
</div>


</body>
</html>
