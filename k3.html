<!DOCTYPE html>
<html lang="fi">
<head>
  <meta charset="UTF-8"/>
  <title>Kartta 3</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link id="manifest-link" rel="manifest" href="manifest.json?v=0.4.27">
  <link rel="icon" href="data:,">
  <!-- Leaflet CSS -->
  <!--<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>-->
  <link rel="stylesheet" href="js/leaflet.css"/>

  <style>
    /* aloitetaan z-indeksit 1000, koska leaflet käyttää 400-800 */
    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
      overflow: hidden;
      /*
      width: 100vw;
      height: 100vh;
      box-sizing: border-box;
      background: #fff;
      /* For notches/cutouts:
      padding-top: env(safe-area-inset-top);
      padding-bottom: env(safe-area-inset-bottom);
      padding-left: env(safe-area-inset-left);
      padding-right: env(safe-area-inset-right);
       */
    }

    .errorClass {
      color: #ff0000;
      font-weight: bold;
    }

    #searchCombo {
      max-width: 250px; /* Adjust as needed */
      width: 100%;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .popup {
      padding: 5%;
      position: absolute;
      z-index: 1030;
      background-color: lightyellow;
      visibility: hidden;
      top: 30pt;
      left: 5%;
      /*width: calc(100% - 72px);
      height: calc(100% - 120px);*/
      right: 5%;
      bottom: 10pt;
      border-color: steelblue;
      border-radius: 20px;
      border-style: solid;
      max-width: 800px;
      /* overflow:auto; */
    }

    .popupIn {
      padding: 5%;
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      overflow: auto;
      border-radius: 20px;
    }

    .ui-menu li {
      margin: 0;
      cursor: pointer;
      list-style-image: url(data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7);
      position: relative;
      padding: 3px 2em 3px 0;
      font-family: Arial, Helvetica, sans-serif;
      font-size: 1em;
    }

    .ui-menu li:hover {
      background-color: #007bff;
      color: #fff;
    }

    .ui-menu li span {
      color: inherit; /* Ensure span inherits the hover color */
      display: block;
      width: 100%;
      box-sizing: border-box;
    }

    .ui-menu {
      background: #ffffff;
      /* width: 230px; */
      margin-left: 25px;
      /* margin-top: 40px; */
      margin-right: 20px;
      height: auto !important;
      display: block;
      list-style-type: none;
      margin-block-start: 1em;
      margin-block-end: 1em;
      padding-inline-start: 6px;
    }

    li a.help {
      padding: unset !important;
      display: inline !important;
      /* float: right; */
      position: absolute !important;
      right: 10px;
    }

    a.help {
      text-decoration: none !important;
    }


    #map {
      height: 100%;
      /* position: relative; */
      cursor: default;
      /* flex: 1 1 auto; */
      width: 100%;
      /* height: auto; */
      /*min-height: 100px; */
      overflow: hidden; /* Prevent scrolling */
    }

    #mapModeSelect {
      /* position: absolute;
      top: 0px;
      left: 35px;

       */
      z-index: 1000;
      background: white;
      padding: 0;
      border-radius: 3px;
      /* box-shadow: 0 0 5px rgba(0,0,0,0.3); */
      font-family: Arial, Helvetica, sans-serif;
      font-size: 1.0em;
    }

    #distance {
      background-color: white;
      align-self: baseline;
    }

    #editPinLoc {
      width: 250px; /* desktop default */
    }

    @media (max-width: 600px) {
      #editPinLoc {
        width: 170px; /* smaller for mobile */
      }
    }

    .closebtn {
      z-index: 1040;
      position: absolute;
      top: 0;
      width: 20px;
      right: 5px;
      font-size: 36px;
      /*margin-left: 50px; */
    }

    .layout-container {
      display: flex;
      flex-direction: column;
      height: 100%;
    }

    .ui-layout-north {
      z-index: 1030;
      /* height: 22px; */
      position: relative;
      background: #f8f9fa;
      border-bottom: 1px solid #dee2e6;
      flex-shrink: 0;
    }

    .ui-layout-center {
      flex: 1 1 auto;
      position: relative;
      display: flex;
      flex-direction: column;
      overflow: hidden; /* Prevent scrolling */

    }

    .ui-layout-center {
      height: 100%;
      overflow: hidden;
    }

    .ui-widget {
      display: flex;
      /* align-items: center; */
      gap: 5px; /* optional spacing */
    }

    .mapType {
      position: absolute;
      top: 0;
      left: 0;
      z-index: 1030;
      /* background: rgba(255, 255, 255, 0.9); */
      padding: 0;
      border-radius: 0;
      /* width: 100%; */
    }

    .hamburgerSpace {
      margin-left: 35px;
    }

    .area1CBcopy {
      align-items: center;
      position: absolute;
      top: 0;
      right: 0;
      z-index: 1030;
    }

    button.icon-btn {
      background: none;
      border: none;
      padding: 0;
      margin: 0;
      width: auto;
      height: auto;
      box-shadow: none;
      outline: none;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      justify-content: center;
    }

    /*noinspection CssUnusedSymbol*/
    .data {
      font-family: sans-serif;
      font-weight: bold;
    }

    /*noinspection CssUnusedSymbol*/
    .comp {
      display: inline-block;
      text-align: center;
      padding: 0 7px 0 7px;
      line-height: 0.9;
      font-size: x-small;
      vertical-align: top;
    }

    /*noinspection CssUnusedSymbol*/
    #compsWindow .wb-body {
        background: black;
    }

    /*noinspection CssUnusedSymbol*/
    .winbox {
      z-index: 1030 !important;
    }

    /*noinspection CssUnusedSymbol*/
    .winbox.min {
        width: 100px !important;
    }

    /*noinspection CssUnusedSymbol*/
    .wb-icon {
      height: 15px;
    }

    /*noinspection CssUnusedSymbol*/
    .wb-title {
      line-height: 15px;
    }

    /*noinspection CssUnusedSymbol*/
    .wb-body {
      overflow: hidden !important;
    }

    /*noinspection CssUnusedSymbol*/
    .leaflet-interactive {
      pointer-events: none;
      user-select: none;
    }

    /*noinspection CssUnusedSymbol*/
    .leaflet-routing-container {
      /* max-height: 30vh !important; /* Näkyy enintään 30% näytöstä */
      overflow-y: auto !important;
      font-size: 0.75em !important;
      padding-top: 0 !important;
      width: unset !important;
    }

    /*noinspection CssUnusedSymbol*/
    .leaflet-routing-alt {
      padding: 0 !important;
      margin-top: 0 !important;
      margin-bottom: 0 !important;
      max-height: unset !important;
      display: block !important;
    }

    .leaflet-routing-alt h2,
    .leaflet-routing-alt h3 {
      display: inline-block;
      vertical-align: middle;
      white-space: nowrap;
      margin: 0 !important;
      margin-right: 0.4em !important;
    }

    .leaflet-routing-alt table {
      display: block !important;
      width: 100% !important;
      margin-top: 5px !important;
    }

    .leaflet-routing-container h2 {
      font-size: 1em !important;;
    }

    /*noinspection CssUnusedSymbol*/
    .leaflet-bar {
      margin-right: 0 !important;
      margin-top: 0 !important;
    }

    /*noinspection CssUnusedSymbol*/
    .leaflet-routing-alt-minimized {
      max-height: 25px !important;
    }

    /*noinspection CssUnusedSymbol*/
    .routing-selected {
      background-color: yellow;
    }

    /*noinspection CssUnusedSymbol*/
    .route-alt.route-alt-selected {
      background-color: yellow;
    }

    /*noinspection CssUnusedSymbol*/
    .itineraryDiv {
      font-size: 0.85em;
    }

    /*noinspection CssUnusedSymbol*/
    p.route-alt {
      margin: 0;
    }


    .routing-main-div {
      /* visibility: hidden;
      width: 360px;
      height: 400px;
      top: 100px;
      position: absolute;
      right: 0;
      z-index: 1030; */
      background: white;
    }

    .routing-main-div .popupIn {
      position: relative; /* or remove position if not needed */
      top: unset;
      bottom: unset;
      left: unset;
      right: unset;
      overflow: auto;
      padding: 0 0 0 3px;
      border-radius: 0;
    }

    .routing-main-div {
      box-sizing: border-box;
      height: 100%;
    }

    .routing-main-div .popupIn {
      box-sizing: border-box;
      width: 100%;
    }

    .driving {
      overflow: hidden;
    }

    /*noinspection CssUnusedSymbol*/
    .leaflet-routing-container {
    }

    /*noinspection CssUnusedSymbol*/
    .route-alt, .route-alt-selected {
      white-space: normal;
      word-break: break-word;
    }

    .routing-main-div .popupIn, .driving {
      display: flex;
      flex-direction: column;
      height: 100%;
    }

    #addressDiv, #routeAlts {
      flex: 0 0 auto;
    }

    #routeAlts {
      font-size: 0.75em;
      border-bottom: 1px solid #ccc;
    }

    #itineraryDiv {
      flex: 1 1 auto;
      overflow-y: auto;
      min-height: 0; /* prevents overflow in flexbox */
    }

    /*noinspection CssUnusedSymbol*/
    #naviInfoText .leaflet-routing-icon {
      transform: scale(3);
      margin: 5px 20px 15px 5px;
    }

    .inner {
      display: flex;
      align-items: center;
      gap: 0.3em;
      flex-wrap: nowrap;
    }

    .inner label {
      flex: 1 1 auto;
      margin: 0;
      white-space: nowrap;
    }

    .inner input[type="text"] {
      width: 100%;
      box-sizing: border-box;
    }

    #addressDiv .instructions {
      font-size: 0.75em;
    }

    .flex-labels {
      display: table;
      width: auto;
      margin-left: 0;
      padding-left: 0;
    }

    .flex-labels > div {
      display: table-row;
    }

    .flex-labels label {
      display: table-cell;
      text-align: left;
      padding-right: 8px;
    }

    .flex-labels input, .flex-labels select {
      display: table-cell;
    }

    #transportChoices {
      display: flex;
      gap: 3px;
      align-items: center;
    }

    .transport-choice {
      font-size: 1.1em;
      cursor: pointer;
      padding: 0;
      border-radius: 3px;
      border: 1px solid transparent;
      background: none;
      transition: border-color 0.2s, background 0.2s;
    }

    /*noinspection CssUnusedSymbol*/
    .transport-choice.selected {
      border-color: #0078D7;
      background: #e0f0ff;
    }

    #addressDiv a.link {
      float: right;
    }

    /*noinspection CssUnusedSymbol*/
    .leaflet-top.leaflet-right {
      margin-right: 2em;
    }

    .draggable {
      cursor: move;
    }

    .noselect {
      user-select: none;
      -webkit-user-select: none;
      -ms-user-select: none;
      -moz-user-select: none;
    }

    .resize-handle {
      width: 22px;
      height: 22px;
      background: transparent;
      position: absolute;
      right: 0;
      bottom: 0;
      cursor: se-resize;
    }

    .draggable:hover .resize-handle, .draggable.show-handle .resize-handle {
      opacity: 1;
      /* background: red; */
      border-bottom: 2px solid #888;
      border-right: 2px solid #888;
      /* Optional: add a diagonal line */
      background-image: linear-gradient(
        135deg,
        transparent 0%,
        transparent 50%,
        #888 50%,
        #888 60%,
        transparent 60%,
        transparent 75%,
        #888 75%,
        #888 100%
      );
      background-size: 16px 16px;
      background-position: right bottom;
      background-repeat: no-repeat;
    }

  </style>
  <script src="KeyValStore.js" defer></script>
  <script>
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.register('offline-worker.js');
      navigator.serviceWorker.addEventListener("message", (event) => {
        if (event.data?.type === "log") {
          console.log(event.data.message);
        }
      });
    }
  </script>
</head>
<body>

<!-- Pick next files to your js-directory -->
<!-- Leaflet JS -->
<!-- <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script> -->
<!-- <script src="https://unpkg.com/leaflet-textpath/leaflet.textpath.js"></script>-->

<script src="js/winbox.bundle.min.js" defer></script>
<script src="js/leaflet.js" defer></script>
<script src="js/leaflet.textpath.js" defer></script>
<script src="js/leaflet-rotate-src.js" defer></script>
<!--<link rel="stylesheet" href="https://unpkg.com/leaflet-routing-machine/dist/leaflet-routing-machine.css" />-->
<!--<script src="https://unpkg.com/leaflet-routing-machine/dist/leaflet-routing-machine.js" defer></script>-->
<script src="MapWrapperLeafLet.js" defer></script>


<script>
  //#region TODO
  /*
    Kartta 3 - Cyclo karttasovelluksen jatke
    (c) 2016-2024 Vesa Lappalainen, vesal,

    Todo:
    - reitit
    - tracks
    - select input when touch
    - z-index
    - meter area south
    - tunnuksen tilaaminen
    - piilota seuranta-asetukset jos ei tunnuksia
    - dialogi pinnin arvoille
    - reititys
    - google route
   */
  //#endregion TODO

  // Globals for databases
  // const tileStore = new KeyValStore('kartta-db', 'tiles');
  // const settingsStore = new KeyValStore('kartta-db', 'settings');


  function sanitizeInput(input, type = "html") {
    if (typeof input !== "string") return "";

    switch (type) {
      case "html": // Näytetään HTML:ssä tekstinä
        return input
          .replace(/&/g, "&amp;")
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;")
          .replace(/"/g, "&quot;")
          .replace(/'/g, "&#039;");

      case "attr": // HTML-attribuuteissa
        return input
          .replace(/&/g, "&amp;")
          .replace(/"/g, "&quot;")
          .replace(/'/g, "&#039;")
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;");

      case "url": // URL-parametreissa
        return encodeURIComponent(input);

      case "alnum": // Vain kirjaimet ja numerot
        return input.replace(/[^a-z0-9]/gi, '');

      default:
        return input;
    }
  }

  const cycloServerUrl = "https://www.mit.jyu.fi/demowww/cyclo";
  const helpServerUrl = "https://tim.jyu.fi/view/users/vesal/riippu/cyclo/kartta";

  //#region Helpper functions

  function decodePolyline(encoded) {
    let points = [], index = 0, lat = 0, lng = 0;
    while (index < encoded.length) {
      let b, shift = 0, result = 0;
      do {
        b = encoded.charCodeAt(index++) - 63;
        result |= (b & 0x1f) << shift;
        shift += 5;
      } while (b >= 0x20);
      let dlat = ((result & 1) ? ~(result >> 1) : (result >> 1));
      lat += dlat;
      shift = 0;
      result = 0;
      do {
        b = encoded.charCodeAt(index++) - 63;
        result |= (b & 0x1f) << shift;
        shift += 5;
      } while (b >= 0x20);
      let dlng = ((result & 1) ? ~(result >> 1) : (result >> 1));
      lng += dlng;
      points.push([lat / 1e5, lng / 1e5]);
    }
    return points;
  }

  function decodeFlexPolyline(encoded) {
    const table = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_';
    let index = 0;

    function getCharCode() {
      if (index >= encoded.length) throw new Error("Out of range");
      return table.indexOf(encoded.charAt(index++));
    }

    function decodeUnsignedVarint() {
      let result = 0, shift = 0, b;
      do {
        b = getCharCode();
        result |= (b & 0x1F) << shift;
        shift += 5;
      } while (b >= 0x20);
      return result;
    }

    function decodeSignedVarint() {
      const res = decodeUnsignedVarint();
      return (res & 1) ? ~(res >> 1) : (res >> 1);
    }

    // Header
    decodeUnsignedVarint(); // headerversion
    const header = decodeUnsignedVarint();
    const precision = header & 0x0F;
    const thirdDim = (header >> 4) & 0x07;
    const thirdDimPrecision = (header >> 7) & 0x0F;
    const factor = Math.pow(10, precision);
    const thirdDimFactor = Math.pow(10, thirdDimPrecision);

    let lastLat = 0, lastLng = 0, lastZ = 0;
    const coordinates = [];

    while (index < encoded.length) {
      lastLat += decodeSignedVarint();
      lastLng += decodeSignedVarint();
      let lat = lastLat / factor;
      let lng = lastLng / factor;
      if (thirdDim) {
        lastZ += decodeSignedVarint();
        let z = lastZ / thirdDimFactor;
        coordinates.push({lat, lng, z});
      } else {
        coordinates.push({lat, lng});
      }
    }
    return coordinates;
  }


  function normalizeLongitude(lon) {
    lon = ((lon + 180) % 360 + 360) % 360 - 180;
    return lon;
  }


  function prefixHelpLinks() {
    document.querySelectorAll('a.help').forEach(link => {
      link.target = "help";
      link.innerText = " ?";
      const hash = link.getAttribute('data-href');
      if (hash && hash.startsWith('#')) {
        link.setAttribute('href', helpServerUrl + hash);
      }
    });
  }


  function fixed(d, n) {
    if (d == null) return "NaN";
    return d.toFixed(n);
  }

  function cleanNumbers(s) {
    return s.replace(/[^0-9]/g, '').trim();
  }

  function d2(d) {
    d = Math.round(d);
    if (d < 10) return "0" + d;
    return "" + d;
  }

function getAspectRatio(aspectRatioStr) {
  if (!aspectRatioStr) return null;
  const parts = aspectRatioStr.split('/');
  if (parts.length === 2) {
    const w = parseFloat(parts[0]);
    const h = parseFloat(parts[1]);
    if (!isNaN(w) && !isNaN(h) && h !== 0) return w / h;
  }
  const num = parseFloat(aspectRatioStr);
  return isNaN(num) ? null : num;
}

function setCompassRotation(heading) {
  const svg = document.querySelector('#compass svg');
  if (svg) {
    svg.style.transform = `rotate(${heading}deg)`;
    svg.style.transformOrigin = '50% 50%';
  }
}


//#endregion Helpper functions

//#region MapModes

  // Simulation of C# string.Format, only {n} works.
  if (!String.format) {
    String.format = function (format) {
      const args = Array.prototype.slice.call(arguments, 1);
      return format.replace(/{(\d+)}/g, function (match, number) {
        return typeof args[number] != 'undefined'
          ? args[number]
          : match
          ;
      });
    };
  }

  // Converts tile XY coordinates into a QuadKey at a specified level of detail.
  function TileXYToQuadKey(tile) {
    let quadKey = "";
    for (let i = tile.zoom; i > 0; i--) {
      let digit = '0';
      const mask = 1 << (i - 1);
      if ((tile.x & mask) !== 0) {
        digit++;
      }
      if ((tile.y & mask) !== 0) {
        digit++;
        digit++;
      }
      quadKey += digit;
    }
    return quadKey;
  }


  const belectro = {
    link: "https://tanger.belectro.fi/tiles/mmltopo/v9/256/{0}/{2}/{1}?ref=7f2d",
    ok: false,
    init: async function () {
      if (this.ok) return;
      this.ok = true;
      const response = await fetch(cycloServerUrl + "/bbark.php");
      const data = await response.text();
      const bbarkObj = JSON.parse(data);
      // noinspection JSUnresolvedReference
      let url = bbarkObj.base_map_groups[0].maps[0].url;
      url = url.replace("{W}", "256");
      url = url.replace("{Z}", "{0}");
      url = url.replace("{Y}", "{2}");
      url = url.replace("{X}", "{1}");
      belectro.link = url;
    }
  };

  // noinspection CheckImageSize
  const mapModes = {
    "Bing Maps normal": {
      f: function (tile) {
        return String.format("https://ecn.t1.tiles.virtualearth.net/tiles/r{0}?g=1135", TileXYToQuadKey(tile));
      }, c: "", mz: 20
    },
    "Bing Maps aerial": {
      f: function (tile) {
        return String.format("https://ecn.t1.tiles.virtualearth.net/tiles/h{0}?g=1135", TileXYToQuadKey(tile));
      }, c: "", mz: 19
    },
    "Google street": {
      f: function (tile) {
        return String.format("https://mt1.google.com/vt/lyrs=m&z={0}&x={1}&y={2}", tile.zoom, tile.x, tile.y);
      },
      c: '(c) <a href="https://maps.google.com/help/terms_maps.html" target="_blank">Google Maps</a>', mz: 22
    },
    "Google satellite": {
      f: function (tile) {
        return String.format("https://mt1.google.com/vt/lyrs=y&z={0}&x={1}&y={2}", tile.zoom, tile.x, tile.y);
      },
      c: '(c) <a href="https://maps.google.com/help/terms_maps.html" target="_blank">Google Maps</a>', mz: 21
    },
//  "Google Street"      : { f:function(tile) { tile = nokiaConvert(tile); return String.format("https://maps.googleapis.com/maps/api/staticmap?center={1},{2}&zoom={0}&size=256x256&key=AIzaSyCpXjAoV19MUbpGd6e6YD9IketR2Gu-tqc",tile.zoom ,tile.x, tile.y); }, c:""},
//  "Google satellite"   : { f:function(tile) { tile = nokiaConvert(tile); return String.format("https://maps.googleapis.com/maps/api/staticmap?center={1},{2}&zoom={0}&size=256x256&key=AIzaSyCpXjAoV19MUbpGd6e6YD9IketR2Gu-tqc&maptype=hybrid",tile.zoom ,tile.x, tile.y); }, c:""},
//    "Nokia"              : { f:function(tile) { tile = nokiaConvert(tile); return String.format("http://m.nok.it/?app_id=_peU-uCkp-j8ovkzFGNU&app_code=gBoUkAMoxoqIWfxWA5DuMQ&h=256&w=256&ctr={1},{2}&z={0}&t=0&nord",tile.zoom ,tile.x, tile.y); }, c:""},
//	"MapQuest"           : { f:function(tile) { return String.format("http://otile1.mqcdn.com/tiles/1.0.0/map/{0}/{1}/{2}.png",Clip(tile.zoom,0,19) ,tile.x, tile.y); },
//	                         c:'(c) <a href="http://info.mapquest.com/terms-of-use/" target="_blank">MapQuest</a>'},
    "OpenStreet": {
      f: function (tile) {
        return String.format("https://tile.openstreetmap.org/{0}/{1}/{2}.png", tile.zoom, tile.x, tile.y);
      },
      c: '(c) <a href="https://www.openstreetmap.org/copyright" target="_blank">OpenStreetMap</a>', mz: 19
    },
    "OpenCycle": //{ f:function(tile) { return String.format("http://a.tile.opencyclemap.org/cycle/{0}/{1}/{2}.png",tile.zoom ,tile.x, tile.y ); },
      {
        f: function (tile) {
          return String.format("https://tile.thunderforest.com/cycle/{0}/{1}/{2}.png?apikey=4e1589f40d3049469a043e2ec917dc88", tile.zoom, tile.x, tile.y);
        },
        c: '(c) <a href="https://www.opencyclemap.org/docs/" target="_blank">OpenCycleMap</a>', mz: 22
      },
    "Landscape": {
      f: function (tile) {
        return String.format("https://tile.thunderforest.com/landscape/{0}/{1}/{2}.png?apikey=4e1589f40d3049469a043e2ec917dc88", tile.zoom, tile.x, tile.y);
      },
      c: '(c) <a href="https://www.opencyclemap.org/docs/" target="_blank">OpenCycleMap</a>', mz: 22
    },
    "Transport": {
      f: function (tile) {
        return String.format("https://tile.thunderforest.com/transport/{0}/{1}/{2}.png?apikey=4e1589f40d3049469a043e2ec917dc88", tile.zoom, tile.x, tile.y);
      },
      c: '(c) <a href="https://www.opencyclemap.org/docs/" target="_blank">OpenCycleMap</a>', mz: 22
    },
    "Outdoors": {
      f: function (tile) {
        return String.format("https://tile.thunderforest.com/outdoors/{0}/{1}/{2}.png?apikey=4e1589f40d3049469a043e2ec917dc88", tile.zoom, tile.x, tile.y);
      },
      c: '(c) <a href="https://www.opencyclemap.org/docs/" target="_blank">OpenCycleMap</a>', mz: 22
    },
    /* Ei voi käyttää, koska ei ole enää saatavilla WGS84, vaan vain EPSG:3067
    "Kapsi peruskartta"  : { f:function(tile) { return getKapsiTilePath(tile); },
                             c:'(c) <a href="http://www.maanmittauslaitos.fi/avoindata_lisenssi_versio1_20120501" target="_blank">Maanmittauslaitos</a>'},
    "Kapsi Tausta"       : { f:function(tile) { return String.format("http://tiles.kartat.kapsi.fi/taustakartta_3067/{0}/{1}/{2}.jpg",tile.zoom ,tile.x, tile.y); },
                             c:'(c) <a href="http://www.maanmittauslaitos.fi/avoindata_lisenssi_versio1_20120501" target="_blank">Maanmittauslaitos</a>'},
    "Kapsi Ilma"         : { f:function(tile) { return String.format("http://tiles.kartat.kapsi.fi/ortokuva_3067/{0}/{1}/{2}.jpg",tile.zoom ,tile.x, tile.y); },
                             c:'(c) <a href="http://www.maanmittauslaitos.fi/avoindata_lisenssi_versio1_20120501" target="_blank">Maanmittauslaitos</a>'

                               },
  https://avoin-karttakuva.maanmittauslaitos.fi/avoin/wmts/1.0.0/taustakartta/default/WGS84_Pseudo-Mercator/18/72651/149809.png?api-key=
  https://avoin-karttakuva.maanmittauslaitos.fi/avoin/wmts/1.0.0/ortokuva/default/WGS84_Pseudo-Mercator/12/1116/2297.png?api-key=
     */
    "MML maasto": {
      f: function (tile) {
        return String.format("https://avoin-karttakuva.maanmittauslaitos.fi/avoin/wmts/1.0.0/maastokartta/default/WGS84_Pseudo-Mercator/{0}/{2}/{1}.png?api-key=4c0b6a7d-aa24-4b2c-913c-66d3823d7445", tile.zoom, tile.x, tile.y);
      },
      c: '(c) <a href="https://www.maanmittauslaitos.fi/avoindata_lisenssi_versio1_20120501" target="_blank">Maanmittauslaitos</a>',
      mz: 18
    },
    "MML tausta": {
      f: function (tile) {
        return String.format("https://avoin-karttakuva.maanmittauslaitos.fi/avoin/wmts/1.0.0/taustakartta/default/WGS84_Pseudo-Mercator/{0}/{2}/{1}.png?api-key=4c0b6a7d-aa24-4b2c-913c-66d3823d7445", tile.zoom, tile.x, tile.y);
      },
      c: '(c) <a href="https://www.maanmittauslaitos.fi/avoindata_lisenssi_versio1_20120501" target="_blank">Maanmittauslaitos</a>',
      mz: 18
    },
    "MML selko": {
      f: function (tile) {
        return String.format("https://avoin-karttakuva.maanmittauslaitos.fi/avoin/wmts/1.0.0/selkokartta/default/WGS84_Pseudo-Mercator/{0}/{2}/{1}.png?api-key=4c0b6a7d-aa24-4b2c-913c-66d3823d7445", tile.zoom, tile.x, tile.y);
      },
      c: '(c) <a href="https://www.maanmittauslaitos.fi/avoindata_lisenssi_versio1_20120501" target="_blank">Maanmittauslaitos</a>',
      mz: 18
    },
    "MML ilma": {
      f: function (tile) {
        return String.format("https://avoin-karttakuva.maanmittauslaitos.fi/avoin/wmts/1.0.0/ortokuva/default/WGS84_Pseudo-Mercator/{0}/{2}/{1}.png?api-key=4c0b6a7d-aa24-4b2c-913c-66d3823d7445", tile.zoom, tile.x, tile.y);
      },
      c: '(c) <a href="https://www.maanmittauslaitos.fi/avoindata_lisenssi_versio1_20120501" target="_blank">Maanmittauslaitos</a>',
      mz: 18
    },
    "b-bark SuomiTopo": {
      f: function (tile) {
        return String.format(belectro.link, tile.zoom, tile.x, tile.y);
      },
      c: '<span>Render:</span> <a href="https://www.b-bark.com" target="_blank"><img style="vertical-align:middle" src="css/b_bark_logo.png" width="39" height="18"  alt=""/></a> (c) <a href="https://www.maanmittauslaitos.fi/avoindata_lisenssi_versio1_20120501" target="_blank">Maanmittauslaitos</a>',
      i: belectro.init, mz: 26
    },
    "World Topo Map": {
      f: function (tile) {
        return String.format("https://services.arcgisonline.com/ArcGIS/rest/services/World_Topo_Map/MapServer/tile/{0}/{2}/{1}", tile.zoom, tile.x, tile.y);
      },
      c: '(c) <a href="https://www.esri.com/" target="_blank">Esri</a>', mz: 19
    },
    "World Imagery": {
      f: function (tile) {
        return String.format("https://services.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{0}/{2}/{1}", tile.zoom, tile.x, tile.y);
      },
      c: '(c) <a href="https://www.esri.com/en-us/home" target="_blank">ArgGIS</a>', mz: 18
    },
    // ks: https://julkinen.traficom.fi/rasteripalvelu/wmts?request=getcapabilities
    "Merikartat": {
      f: function (tile) {
        return String.format("https://julkinen.traficom.fi/rasteripalvelu/wmts/rest/Traficom:Merikarttasarjat public/default/WGS84_Pseudo-Mercator/WGS84_Pseudo-Mercator:{0}/{2}/{1}?format=image/png", tile.zoom, tile.x, tile.y);
      },
      c: '(c) <a href="https://www.traficom.fi/en/news/spatial-dataset-material/download-and-view-service" target="_blank">Traficom</a>',
      mz: 15
    },
    /*
    "Ilmailu merged"      : { f:function(tile) {
                                const airac = "1806";
                                return String.format('https://snapshots.openflightmaps.org/live/' + airac + '/tiles/world/noninteractive/epsg3857/merged/256/latest/{0}/{1}/{2}.png', tile.zoom, tile.x, tile.y);
                                },
                             c:'(c) <a href="https://openflightmaps.org/live/ef-finland/" target="_blank">openflightmaps.org</a>'},
    "Ilmailu aero"      : { f:function(tile) {
                                 const airac = "1806";
                                 return String.format('https://snapshots.openflightmaps.org/live/' + airac + '/tiles/world/noninteractive/epsg3857/aero/256/latest/{0}/{1}/{2}.png',tile.zoom ,tile.x, tile.y);
                                 },
                             c:'(c) <a href="https://openflightmaps.org/live/ef-finland/" target="_blank">openflightmaps.org</a>'},
  */
    /*
      "Ilmailu base"      : { f:function(tile) {
                                   var airac = "1806";
                                   var url = String.format('https://snapshots.openflightmaps.org/live/' + airac + '/tiles/world/noninteractive/epsg3857/base/256/latest/{0}/{1}/{2}.png',tile.zoom ,tile.x, tile.y);
                                   return url},
                               c:'(c) <a href="https://openflightmaps.org/live/ef-finland/" target="_blank">openflightmaps.org</a>'},
    */
  };

  /*
  function tileToWMSRect(tile)  {
    const mapSize = 256 << tile.zoom;
    const pixelX = 256 * tile.x + 128;
    const pixelY = 256 * tile.y + 128;
    const x1 = (Clip(pixelX - 128, 0, mapSize - 1) / mapSize) - 0.5;
    const y1 = 0.5 - (Clip(pixelY+128, 0, mapSize - 1) / mapSize);
    const x2 = (Clip(pixelX+128, 0, mapSize - 1) / mapSize) - 0.5;
    const y2 = 0.5 - (Clip(pixelY-128, 0, mapSize - 1) / mapSize);
    return {
        x1 : 90 - 360 * Math.atan(Math.exp(-y1 * 2 * Math.PI)) / Math.PI,
        y1 : 360 * x1,
        x2 : 90 - 360 * Math.atan(Math.exp(-y2 * 2 * Math.PI)) / Math.PI,
        y2 : 360 * x2
    };
  }
  */

  //#endregion MapModes

  //#region Distance calculation

  class Ellipsoid {
    constructor(name, a, invf) {
      this.name = name;
      this.a = a;
      this.invf = invf;
    }
  }

  const ells = [
    new Ellipsoid("WGS84", 6378.137 / 1.852, 298.257223563),
    new Ellipsoid("FAI sphere", 6371.0 / 1.852, 1000000000.)
  ];


  function getEllipsoid(selection) {
//  document.spheroid.major_radius.value=ells[selection.selectedIndex+1].a*1.852
//  document.spheroid.inverse_f.value=ells[selection.selectedIndex+1].invf
    return ells[selection.selectedIndex];
  }

  function atan2(y, x) {
    let out;
    if (x < 0) {
      out = Math.atan(y / x) + Math.PI;
    }
    if ((x > 0) && (y >= 0)) {
      out = Math.atan(y / x);
    }
    if ((x > 0) && (y < 0)) {
      out = Math.atan(y / x) + 2 * Math.PI;
    }
    if ((x === 0) && (y > 0)) {
      out = Math.PI / 2;
    }
    if ((x === 0) && (y < 0)) {
      out = 3 * Math.PI / 2;
    }
    if ((x === 0) && (y === 0)) {
      //alert("atan2(0,0) undefined")
      out = 0.
    }
    return out
  }

  function bearingDegrees(from, to) {
    // from and to: [lat, lon]
    const toRad = deg => deg * Math.PI / 180;
    const toDeg = rad => rad * 180 / Math.PI;

    const lat1 = toRad(from[0]);
    const lat2 = toRad(to[0]);
    const dLon = toRad(to[1] - from[1]);

    const y = Math.sin(dLon) * Math.cos(lat2);
    const x = Math.cos(lat1) * Math.sin(lat2) -
      Math.sin(lat1) * Math.cos(lat2) * Math.cos(dLon);
    let brng = Math.atan2(y, x);
    brng = toDeg(brng);
    return (brng + 360) % 360; // Normalize to 0–360
  }

  function WGS84_distance(p1, p2) {
    if (Array.isArray(p1) && p1.length === 2) {
      p1 = {latitude: p1[0], longitude: p1[1]};
    }
    if (Array.isArray(p2) && p2.length === 2) {
      p2 = {latitude: p2[0], longitude: p2[1]};
    }
    const selection = {selectedIndex: 0};
    const m = Math.PI / 180;
    return crsdist_ell(p1.latitude * m, p1.longitude * m, p2.latitude * m, p2.longitude * m, getEllipsoid(selection));
  }

  function crsdist_ell(glat1, glon1, glat2, glon2, ellipse) {
    // glat1 initial geodetic latitude in radians N positive
    // glon1 initial geodetic longitude in radians E positive
    // glat2 final geodetic latitude in radians N positive
    // glon2 final geodetic longitude in radians E positive
    const a = ellipse.a
    const f = 1 / ellipse.invf
    //alert("a="+a+" f="+f)
    let r, tu1, tu2, cu1, su1, cu2, s1, b1, f1;
    let x, sx, cx, sy, cy, y, sa, c2a, cz, e, c, d;
    const EPS = 0.00000000005;
    let s;
    let iter = 1;
    const MAXITER = 100;
    if ((glat1 + glat2 === 0.) && (Math.abs(glon1 - glon2) === Math.PI)) {
      alert("Course and distance between antipodal points is undefined")
      glat1 = glat1 + 0.00001 // allow algorithm to complete
    }
    if (glat1 === glat2 && (glon1 === glon2 || Math.abs(Math.abs(glon1 - glon2) - 2 * Math.PI) < EPS)) {
      //alert("Points 1 and 2 are identical- course undefined")
      return 0.0; // don't care???
    }
    r = 1 - f
    tu1 = r * Math.tan(glat1)
    tu2 = r * Math.tan(glat2)
    cu1 = 1. / Math.sqrt(1. + tu1 * tu1)
    su1 = cu1 * tu1
    cu2 = 1. / Math.sqrt(1. + tu2 * tu2)
    s1 = cu1 * cu2
    b1 = s1 * tu2
    f1 = b1 * tu1
    x = glon2 - glon1
    d = x + 1 // force one pass
    while ((Math.abs(d - x) > EPS) && (iter < MAXITER)) {
      iter = iter + 1
      sx = Math.sin(x)
//       alert("sx="+sx)
      cx = Math.cos(x)
      tu1 = cu2 * sx
      tu2 = b1 - su1 * cu2 * cx
      sy = Math.sqrt(tu1 * tu1 + tu2 * tu2)
      cy = s1 * cx + f1
      y = atan2(sy, cy)
      sa = s1 * sx / sy
      c2a = 1 - sa * sa
      cz = f1 + f1
      if (c2a > 0.)
        cz = cy - cz / c2a
      e = cz * cz * 2. - 1.
      c = ((-3. * c2a + 4.) * f + 4.) * c2a * f / 16.
      d = x
      x = ((e * cy * c + cz) * sy * c + y) * sa
      x = (1. - c) * x * f + glon2 - glon1
    }
    x = Math.sqrt((1 / (r * r) - 1) * c2a + 1)
    x += 1
    x = (x - 2.) / x
    c = 1. - x
    c = (x * x / 4. + 1.) / c
    d = (0.375 * x * x - 1.) * x
    x = e * cy
    s = ((((sy * sy * 4. - 3.) * (1. - e - e) * cz * d / 6. - x) * d / 4. + cz) * sy * d + y) * c * a * r

    return s * 1.852;
    /*
    let faz, baz;
    faz = modcrs(atan2(tu1, tu2))
    baz = modcrs(atan2(cu1 * sx, b1 * cx - su1 * cu2) + Math.PI)
    out=new MakeArray(0)
    out.d=s
    out.crs12=faz
    out.crs21=baz
    if (Math.abs(iter-MAXITER)<EPS){
      alert("Algorithm did not converge")
    }
    return out
    */
  } // crsdist_ell ends


  let distanceLines = [];
  let lastHeading = 0;

  function calcDistance(idx1 = -1000, idx2 = -1000) {
    let d = 0;
    let sum = 0;
    if (!hitPin) return;
    let from = null;
    if (idx1 === -1) {
      if (distanceLines.length >= 1) {
        lastHitPoint = distanceLines[distanceLines.length - 1].from;
      }
    }
    const to = mapWrapper.getPinLocation(hitPin);
    if (lastSelected) {
      from = mapWrapper.getPinLocation(lastSelected);
      mapWrapper.removeLines(distanceLines);
    } else {
      if (!lastHitPoint) return;
      from = lastHitPoint;
    }
    if (!options.calcDistanceSum) {
      mapWrapper.removeLines(distanceLines);
    }
    d = WGS84_distance(from, to);
    const deg = bearingDegrees(from, to);
    lastHeading = deg;
    const s = `${d.toFixed(3)} km, ${deg.toFixed(1)}°`;
    if (idx1 >= -1) mapWrapper.removeLines(distanceLines, idx1, idx2);
    distanceLines = mapWrapper.addLines(distanceLines, from, to, {
      color: 'red',
      weight: 1,
      opacity: 0.8
    }, s, options.drawDistanceLine);
    const line = distanceLines[distanceLines.length - 1];
    line.d = d;
    line.deg = deg;
    for (let i = 0; i < distanceLines.length; i++) {
      if (distanceLines[i].d) sum += distanceLines[i].d;
    }
    if (!dstTextElem) dstTextElem = document.getElementById("distance");
    if (sum !== d) dstTextElem.innerText = s + ` = ${sum.toFixed(3)} km`;
    else dstTextElem.innerText = s;
  }

  //#endregion Distance calculation


  //#region Globals
  // let lastSelected = null;
  let myPin = null;
  let hitPin = null;
  let mapWrapper = null;
  let pinNr = 1;
  let dstTextElem = null;
  let lastHitPoint = null;
  let hitPinXY = [100, 100];
  let searchPins = [];

  const isTouch = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);

  const options = {
    email: "",
    id: "",
    logname: "",
    interval: "5000",
    usersTofollow: "",
    send: false,
    readGPS: true,
    resend: false,
    follow: false,
    followMe: false,
    followMeWidth: 3,
    followMeColor: "orange",
    showTime: true,
    selectNewPin: true,
    useDummyRect: false,
    preventSleep: true,
    smallRaport: false,
    drawLogLine: false,
    HStationary: true,
    HCenter2: false,  // korvattu nimi jotta vanhat localstoraget eivät sotke
    showAccuracy: true,
    extra: false,
    tpR: "0",
    hasWakeLock: false,
    useComps: false,
    useCompsWindow: false,
    useCache: true,
    drawDistanceLine: true,
    calcDistanceSum: true,
    flipPins: isTouch,
    showZoomButtons: !isTouch,
    hereApiKey: "",
    graphHopperApiKey: "",
    speechRate: 100,
    dialect: "savo",
    routeMode: "car",
    from: "",
    to: "",
    doubleClickZoom: false,
    showRotate: "none",
    showCompass: "gps",
    simulateSpeed: 0,
    navigate: false,
    lastRouter: 0, // 0=OSRM, 1=graphhopper, 2=here, 3=here sample
    instLeadTime: 10,
    polygonAckRadius: 40,
    routePointAckRadius: 15,

  };

  const areaDatas = [
    {name: "Ilmatilat", url: "https://flyk.com/api/airspaces.geojson", cb: "area1cb"},
    {name: "Suplementit", url: "https://flyk.com/api/supplements.geojson", cb: "area2cb"},
    {name: "Varaukset", url: "https://flyk.com/api/reservations.geojson", cb: "area3cb"},
  ];


  const params = getUrlVars();

  function getUrlVars() {
    let vars = [], hash;
    const hashes = window.location.href.slice(window.location.href.indexOf('?') + 1).split('&');
    for (let i = 0; i < hashes.length; i++) {
      hash = hashes[i].split('=');
      vars.push(hash[0]);
      const val = hash[1] ? decodeURIComponent(hash[1]) : "";
      vars[hash[0]] = val;
    }
    return vars;
  }

  const timers = {
    follow: {t: null, f: getfollow, interval: 1000},
    showPosition: {t: null, f: showCurrentPosition, interval: 1000},
    send: {t: null, f: sendPosition, interval: 5000},
    resend: {t: null, f: sendPosition, interval: 200000},
    showTime: {t: null, f: setTimeCompsValues, interval: 1000},
  };

  //#endregion Globals

  function checkTimer(timer, clear) {
    // if ( timer=="send" && !options.sendPos) return;
    const tim = timers[timer];
    if (options[timer] && !clear)
      tim.t = setInterval(function () {
        tim.f();
      }, tim.interval);
    else
      clearInterval(tim.t);
  }


  function mapMove() {
    mouseDown = true;
    const pos = mapWrapper.getCenter();
    localStorage.lat = pos[0];
    localStorage.lon = pos[1];
    localStorage.zoom = mapWrapper.getZoom();
    if (options.HCenter2) {
      setHitPinLoc(mapWrapper.getCenter(), -1, -1);
      displayLocPin(hitPin);
    } else if (options.HStationary  && !simulationGoing) {
      const loc = mapWrapper.getXYCoord(hitPinXY);
      setHitPinLoc(loc, -1, -1);
      displayLocPin(hitPin);
    }
  }

  function showCurrentPosition() {

  }

  //#region Cyclo server communication

  function postCyclo(data, callback) {
    fetch(cycloServerUrl + "/index.php", {
      method: "POST",
      headers: {
        "Content-Type": "application/x-www-form-urlencoded",
        // "Content-Type": "application/json",
        // "X-Requested-With": "XMLHttpRequest" // jQuery lisää tämän, joskus tarpeen
      },
      body: Object.keys(data)
        .map(key => encodeURIComponent(key) + "=" + encodeURIComponent(data[key]))
        .join("&")
    })
      .then(response => {
        // console.log(response);
        return response.text();
      })
      .then(callback);
  }

  function getfollow() {
    if (!options.id || !options.email) return;

    clearError();
    postCyclo({id: options.id, e: getEmailTag(), f: options.usersTofollow}, function (data) {
      setPins(data)
    });
  }


  //#region Old school POST for Cyclo server
  // jQueryn $.post korvaaja
  /*
  function oldSchoolPost(url, params, callback, extra) {
    // Muutetaan olio URL-enkoodattuun muotoon
    const formBody = Object.keys(params)
      .map(key => encodeURIComponent(key) + "=" + encodeURIComponent(params[key]))
      .join("&");

    const xhr = new XMLHttpRequest();
    xhr.open("POST", url, true);
    // xhr.setRequestHeader("X-Requested-With", "XMLHttpRequest");
    xhr.setRequestHeader("Content-Type", "application/x-www-form-urlencoded;charset=UTF-8");

    // Tämä jäljittelee jQueryn "done"
    xhr.onreadystatechange = function() {
      if (xhr.readyState === 4) {
        if (xhr.status >= 200 && xhr.status < 300) {
          callback(xhr.responseText, extra);
        } else {
          console.error("POST error:", xhr.status, xhr.statusText);
        }
      }
    };

    xhr.send(formBody);
  }

  // Vanha versio, joka käyttää XMLHttpRequest:iä
  function sendCyclo0(command,f, extra) {
    clearError();
    options.id = cleanNumbers(options.id);
    const params = { ...command, id: options.id, e: getEmailTag() };
    oldSchoolPost(cycloServerUrl+"/index.php", params, f, extra);
  }

  // Vanha versio, joka käyttää fetch:ia getin kautta
  function sendCyclo2(command,f, extra) {
    clearError();
    options.id = cleanNumbers(options.id);
    const params = { ...command, id: options.id, e: getEmailTag() };
    const query = new URLSearchParams(params).toString();
    fetch(`${cycloServerUrl}/index.php?${query}`)
    .then(res => res.text())
    .then(data => f(data, extra))
    .catch(err => console.error(err));
  }

   */
  //#endregion Old school POST for Cyclo server


  function sendCyclo(command, f, extra) {
    clearError();
    options.id = cleanNumbers(options.id);
    const params = {...command, id: options.id, e: getEmailTag()};
    postCyclo(params,
      function (data) {
        f(data, extra)
      });
  }


  function getEmailTag() {
    if (!options.tag) return options.email;
    return options.email + "+" + options.tag
  }


  function getLogname() {
    if (options.logname) return options.logname;
    const today = new Date();
    const dd = today.getDate();
    const mm = today.getMonth() + 1; //January is 0!
    const yy = today.getFullYear() - 2000;

    return i2(yy) + i2(mm) + i2(dd);
  }

  let lastSend = "";

  function postPosition(position) {
    if (sending) return;
    if (!options.id || !options.email) return;
    sending = true;
    clearError();
    // var position ="62.4596956,25.7324266,0,433,41478.4036846991,2.390,254.9,3.0,3.0";
    const pos = fixed(position.coords.latitude, 7) + "," +
      fixed(position.coords.longitude, 7) + "," +
      "0" + "," +
      fixed(((position.coords.altitude) * 3.280839895), 0) + "," +
      fixed((position.timestamp / 1000 / 3600 / 24) + 25569.00, 10) + "," +
      fixed(position.coords.speed, 1) + "," +
      fixed(position.coords.heading, 1) + "," +
      fixed(position.coords.accuracy, 1) + "," +
      fixed(position.coords.altitudeAccuracy, 1);
    const posmsg = fixed(position.coords.latitude, 4) + "," +
      fixed(position.coords.longitude, 4);

    // let tag = "";
    // if ( options.tag ) tag = "+" + options.tag;

    if (lastSend === posmsg) {
      setError("");
      // timers["send"].interval = options.interval;
      // checkTimer("send",false);
      // checkTimer("resend",true);
      sending = false;
      return;
    }

    sendCyclo({id: options.id, e: getEmailTag(), d: pos, log: getLogname()},
      function (data) {
        setError(data);
        // timers["send"].interval = options.interval;
        // checkTimer("send",false);
        // checkTimer("resend",true);
        sending = false;
        lastSend = posmsg;
      }
    );
    const c = document.getElementById('coord');
    c.innerHTML = " " + posmsg;
  }


  let sending = false;

  function sendPosition() {
    // checkTimer("send",true);
    // checkTimer("resend",true);
    clearError();
    // getLocation();
    if (options.send) {
      if (lastGPSCoord)
        postPosition(lastGPSCoord);
      else
        navigator.geolocation.getCurrentPosition(postPosition, errorCallBack, geo_options);
    }
  }

  //#endregion Cyclo server communication

  //#region Geocoding
  function isCoordinate(s) {
    if (s === "") return false;
    return "0123456789-".indexOf(s[0]) >= 0;
  }

  /*
  function findAddressCoordinate(addr) {
    fetch(`https://nominatim.openstreetmap.org/search?q=${addr}&format=json`)
      .then(response => response.json())
      .then(data => {
        if (data.length === 0) return null;
        const item = data[0];
        return [item.lat, item.lon];
      })
      .catch(err => null);
  }
  */

  async function findAddressCoordinate(addr) {
    try {
      const response = await fetch(`https://nominatim.openstreetmap.org/search?q=${addr}&format=json`);
      const data = await response.json();
      if (data.length === 0) return null;
      const item = data[0];
      if (data.length === 1) return [item.lat, item.lon];
      let refPos;
      if (lastSelected) refPos = mapWrapper.getPinLocation(lastSelected);
      else if (myPin) refPos = mapWrapper.getPinLocation(myPin);
      else if (hitPin) refPos = mapWrapper.getPinLocation(hitPin);
      if (!refPos) return [item.lat, item.lon];
      let bestDist = 1000000;
      let bestPos = [item.lat, item.lon];
      for (const d of data) {
        // noinspection JSUnresolvedReference
        const pos = [d.lat, d.lon];
        const dist = WGS84_distance(refPos, pos);
        if (dist < bestDist) {
          bestDist = dist;
          bestPos = pos;
        }
      }
      return bestPos;
    } catch (err) {
      return null;
    }
  }

  function geocodeQuery(query) {

    const select = document.getElementById('searchCombo');
    select.innerText = "";
    toggleDiv("searchSpan", true);

    if (isCoordinate(query)) {
      const loc = getCoordinateFromText(query);
      const pin = addPinAt(loc)
      searchPins.push(pin);
      // map.entities.push([pin]);
      // map.setView({center: loc});
      return;
    }
    fetch(`https://nominatim.openstreetmap.org/search?q=${query}&format=json`)
      .then(response => response.json())
      .then(data => {
        const opt0 = document.createElement('option');
        opt0.value = "0";
        let text = "Ei löytynyt";
        if (data.length === 1) {
          text = "Löytyi 1 kohde: ";
        }
        if (data.length > 1) {
          text = "Löytyi " + data.length + " kohdetta: ";
        }
        opt0.text = text;
        select.appendChild(opt0);

        if (data.length > 0) {
          // console.log('Löytyi useita tuloksia:', data.length);
          data.forEach((item, i) => {
            // console.log(`${i + 1}: ${item.display_name} — lat: ${item.lat}, lon: ${item.lon}`);
            // noinspection JSUnresolvedReference
            const pin = createPin([item.lat, item.lon], `s${i + 1}`, 'violet', item.display_name);
            searchPins.push(pin)
            // noinspection JSUnresolvedReference
            const opt = (i + 1) + ') ' + item.display_name;
            const option = document.createElement('option');
            option.value = "" + (i + 1);
            option.text = opt;
            select.appendChild(option);
          });
        }
      })
      .catch(err => console.error('Virhe:', err));
  }

  function search() {
    //Remove any previous results from the map.
    clearSearchResults();
    //Get the users query and geocode it.
    const query = getPinInputText();
    geocodeQuery(query);
  }

  function getCoordinateFromText(s) {
    // Etsitään koordinaatit tekstistä
    const latLongArray = s.split(/[\s,]+/);
    if (latLongArray.length < 2) return null;
    const lat = parseFloat(latLongArray[0]);
    const lng = parseFloat(latLongArray[1]);
    if (isNaN(lat) || isNaN(lng)) return null;
    return [lat, lng];
  }

  //#endregion Geocoding

  //#region Pin management

  let _lastSelected = null;

  Object.defineProperty(window, 'lastSelected', {
    get() {
      return _lastSelected;
    },
    set(pin) {
      setLastSelected(pin);
    }
  });

  function setLastSelected(pin) {
    _lastSelected = pin;
    // Tee tässä mitä haluat, esim. loggaa tai muuta logiikkaa
    const pinButtonsDiv = document.getElementById('pinButtons');
    if (pin && pin !== myPin && pin !== hitPin) {
      pinButtonsDiv.style.display = 'inline-block';
    } else {
      pinButtonsDiv.style.display = 'none';
    }
  }

  function removePin(pin = lastSelected) {
    if (pin === myPin || pin === hitPin) return;
    if (pin === lastSelected) lastSelected = null;
    mapWrapper.removePin(pin);
  }

  function selectActivePin(pin, calcDist) {
    changeSelected(pin, true);
    mapWrapper.selectPin(pin, true);
    if (calcDist) {
      mapWrapper.setPinOn(pin, 'drag', calcDistance);
      calcDistance();
    }
  }

  function getPinValues(pinLoc, defLoc = null, defLabel = null) {
    if (!pinLoc) return [defLoc, defLabel];
    let name = defLabel;
    const latLongArray = pinLoc.split(/[\s,]+/);
    let loc = getCoordinateFromText(pinLoc);
    if (!loc) loc = defLoc;
    if (latLongArray.length >= 3) name = latLongArray[2];
    if (name === undefined || name === "H" || name === "")
      name = defLabel;
    return [loc, name];
  }


  function addPinAt(pinLoc, label = null) {
    /*
    let loc = mapWrapper.getPinLocation(hitPin);
    let name = "" + pinNr;
    if (pinLoc) {
      const latLongArray = (pinLoc).split(/[\s,]+/);
      loc = getCoordinateFromText(pinLoc);
      if (latLongArray.length >= 3) name = latLongArray[2];
      if ( name === undefined || name === "H" || name === "" )
        if (label) name = label; else name = ""+pinNr++;
    }
    else pinNr++;
    */
    let [loc, name] = getPinValues(pinLoc, mapWrapper.getPinLocation(hitPin), label);
    if (!loc) return null;
    if (!name) name = "" + pinNr++;

    return createPin(loc, name, 'blue', null, options.flipPins);
  }


  function changePinData(pin = lastSelected, s = null) {
    if (pin === myPin || pin === hitPin) return;
    if (s == null) s = getPinInputText();
    if (isCoordinate(s)) {
      const [loc, label] = getPinValues(s, null, null);
      if (loc) mapWrapper.setPinLocation(pin, loc);
      if (label) mapWrapper.setPinLabel(pin, label);
    } else {
      mapWrapper.setPinLabel(pin, s);
    }
  }


  function addPin() {
    const s = getPinInputText();
    if (s !== "" && !isCoordinate(s)) return search();
    const pin = addPinAt(s);
    mapWrapper.setPinDragging(pin, true);
    if (options.selectNewPin) {
      selectActivePin(pin, true);
    }
  }


  function checkAddPinText() {
    let text = "Lisää pinni";
    if (window.innerWidth < 400) text = "Lisää";
    const s = getPinInputText()
    if (s !== "" && !isCoordinate(s)) text = "Etsi";
    document.getElementById('buttonAddPin').innerText = text;
  }

  function getInputText(name) {
    const elem = document.getElementById(name);
    if (!elem) return "";
    let s = sanitizeInput(elem.value.trim());
    return s;
  }

  function getPinInputText() {
    let s = getInputText('editPinLoc');
    return s;
  }

  function setPinInputText(s) {
    document.getElementById('editPinLoc').value = s.trim();
    checkAddPinText();
  }

  function setHitPinLoc(loc, idx1 = -1000, idx2 = -1000) {
    if (!hitPin) return;
    mapWrapper.setPinLocation(hitPin, loc);
    calcDistance(idx1, idx2);
  }


  function clearSearchResults() {
    if (searchPins.length > 0) {
      searchPins.forEach(pin => {
        if (pin === lastSelected) lastSelected = null;
        mapWrapper.removePin(pin);
      });
      searchPins = [];
    }
    toggleDiv('searchSpan', false)
  }

  function displayLocPin(pin) {
    if (!pin) return;
    const pinLoc = mapWrapper.getPinLocation(pin);
    const alt = pinLoc.altitude;
    let alts = "";
    if (!(alt === undefined)) alts = " " + (alt / 3.280839895).toFixed(0) + " m";
    setPinInputText(pinLoc[0].toFixed(5) + " " + pinLoc[1].toFixed(5) + " " + mapWrapper.getPinLabel(pin) + alts);
    calcDistance(-1, -1);
  }

  function changeSelected(pin, selected = true) {
    if (lastSelected === pin) { // Jos sama pin on jo valittu, poistetaan valinta
      mapWrapper.selectPin(pin, false);
      mapWrapper.setPinOn(lastSelected, 'drag', calcDistance, true);
      window.lastSelected = null;
      return;
    }

    if (lastSelected) {
      mapWrapper.selectPin(lastSelected, false);
      mapWrapper.setPinOn(lastSelected, 'drag', calcDistance, true);
    }
    lastSelected = pin;
    if (pin) {
      mapWrapper.selectPin(pin, selected);
    }
    if (selected) {
      mapWrapper.setPinOn(pin, 'drag', calcDistance);
      displayLocPin(pin);
    }
  }

  function createPin(coord, label, color, text = null, flip = false) {
    return mapWrapper.createPin(coord, label, color, function (pin) {
      changeSelected(pin);
    }, text, flip);
  }

  const followPinList = {};
  const followPolylineList = {};

  function setPin(line) {
    line = line.trim();
    if (line === "") return;
    if (line[0] !== 'D') return setError(line);
    const parts = line.split(":");
    const n = parts[1].split("=");
    const name = n[0];
    const d = n[1].split(",");
    const latVal = parseFloat(d[0]);
    const longVal = normalizeLongitude(parseFloat(d[1]));
    const alt = parseFloat(d[3]);
    const newLoc = [latVal, longVal, alt];
    newLoc.altitude = alt;
    let pin;
    let pline;
    if (name in followPinList) {
      pin = followPinList[name];
      pline = followPolylineList[name];
      const len = pline.points.length;
      if (len !== 0) {
        const prevLoc = pline.points[len - 1];
        const same = prevLoc[0] === newLoc[0] && prevLoc[1] === newLoc[1];
        if (!same) {
          if (options.drawLogLine) mapWrapper.addPolylinePoint(pline, newLoc);
          // else pline.getLocations().length = 0;
          mapWrapper.setPinLocation(pin, newLoc);
          // if (lineVertices.length % 1 === 0) // To let it draw also with big zoom factors
          //   pline.setLocations(lineVertices);
        }
      }
    } else {
      // var pinInfobox = new Microsoft.Maps.Infobox(center, {title: name, visible: false});
      pin = mapWrapper.createPin(newLoc, name, 'green ', function (pin) {
        changeSelected(pin);
      }, null, false);
      pline = mapWrapper.createPolyline({color: 'green', weight: 2, opacity: 0.7});
      if (options.drawLogLine) mapWrapper.addPolylinePoint(pline, newLoc);
      followPinList[name] = pin;
      followPolylineList[name] = pline;
      // map.entities.push(pinInfobox);
    }
    if (pin === lastSelected) mapWrapper.setView(newLoc);
  }


  function setPins(data) {
    const lines = data.split("\n");
    for (let i = 0; i < lines.length; i++)
      setPin(lines[i]);
  }

  //#endregion Pin management

  //#region Error handling
  function setErrorGen(name, s) {
    const e = document.getElementById(name);
    e.innerHTML += " " + s;
    return s;
  }


  function clearErrorGen(name) {
    const e = document.getElementById(name);
    e.innerHTML = "";
    return "";
  }

  //function setMessage(s) { return setErrorGen('searchMsg', s); }
  function setError(s) {
    return setErrorGen('errorMsg', s);
  }

  // function setErrorTrack(s) { return setErrorGen('errorMsgTrack', s); }
  // function setErrorRoute(s) { return setErrorGen('errorMsgRoute', s); }

  //function clearMessage() { return clearErrorGen('searchMsg'); }
  function clearError() {
    return clearErrorGen('errorMsg');
  }

  // function clearErrorTrack() { return clearErrorGen('errorMsgTrack'); }
  // function clearErrorRoute() { return clearErrorGen('errorMsgRoute'); }
  //#endregion Error handling

  //#region Geolocation
  function errorCallBack() {
    setError("getLocation error");
  }

  let lastGPSCoord;

  const geo_options = {
    enableHighAccuracy: true,
    maximumAge: 500,
    timeout: 27000
  };

  let watcher = null;

  function getGeoLocation() {
    if (watcher) return;
    if (navigator.geolocation) {
      watcher = navigator.geolocation.watchPosition(displayCurrentPosition, errorCallBack, geo_options);
    } else {
      setError("Geolocation is not supported by this browser.");
    }
  }


  function startGeoLocation(enable) {
    if (watcher) navigator.geolocation.clearWatch(watcher);
    watcher = null;
    if (enable) getGeoLocation();
  }


  function checkGeoLocation() {
    if (options.simulateSpeed) return;
    startGeoLocation(document.getElementById("readGPS").checked);
  }

  let myPolyline = null;

  function displayCurrentPosition(position) {
    if (!position || !position.coords) return;
    lastGPSCoord = position;
    const lat = position.coords.latitude;
    const lng = position.coords.longitude;
    const loc = [lat, lng];
    if (options.useComps) {
      setGeoCompsValues(position);
    }

    if (myPin) {
      mapWrapper.setPinLocation(myPin, loc);
    } else {
      myPin = createPin(loc, 'I', 'green', "Olet tässä");
      // jos URLissa ei ole tullut paikkaa, käytä
      if (!params.lat) mapWrapper.setView(loc);
    }
    if (options.followMe) {
      if (!myPolyline) {
        myPolyline = mapWrapper.createPolyline({
          color: options.followMeColor,
          weight: options.followMeWidth,
          opacity: 1
        });
      }
      mapWrapper.addPolylinePoint(myPolyline, loc);
    }
    if (options.send) postPosition(position);
    if (options.showCompass === "gps") {
      const heading = position.coords.heading;
      if (heading !== null && !isNaN(heading)) setCompassRotation(360-heading);
    }
    if (options.showRotate === "gps") {
      const heading = position.coords.heading;
      if (heading !== null && !isNaN(heading)) mapWrapper.setBearing(-heading);
    }
    if (lastSelected === myPin) mapWrapper.setView(loc);

    if (options.navigate) continueNavigation(loc, position.coords.speed);
  }

  let simulationGoing = false;

  // noinspection JSUnusedGlobalSymbols
  function simulateGPS() {
    simulationGoing =true;
    const loc = mapWrapper.getPinLocation(hitPin);
    const lat = loc[0]; // 62.25 + (Math.random() - 0.5) * 0.1;
    const lng = loc[1]; // 25.75 + (Math.random() - 0.5) * 0.1;
    const coords = {
      latitude: lat,
      longitude: lng,
      altitude: 100 + Math.random() * 50,
      accuracy: 5 + Math.random() * 5,
      altitudeAccuracy: 10 + Math.random() * 10,
      heading: lastHeading, // Math.random() * 360,
      speed: options.simulateSpeed // 0.01 + Math.random() * 0.1
    };
    const position = {
      coords: coords,
      timestamp: Date.now()
    };
    displayCurrentPosition(position);
    setTimeout(() => {simulationGoing = false;}, 500);
  }


  //#endregion Geolocation

  //#region LocalStorage and URL parameters
  function getValueFromParamsOrStrore(name, def) {
    const candidates = [params[name], localStorage[name]];
    for (const val of candidates) {
      if (val !== undefined && val !== null && val !== "undefined" && val !== "") {
        return Number(val);
      }
    }
    return def;
  }

  function getStringFromParamsOrStrore(name, def) {
    const candidates = [params[name], localStorage[name]];
    for (const val of candidates) {
      if (val !== undefined && val !== null && val !== "undefined" && val !== "") {
        return val;
      }
    }
    return def;
  }

  //#endregion LocalStorage and URL parameters

  //#region Initialization
  function showVersion() {
    const manifestLink = document.getElementById('manifest-link');
    const href = manifestLink.getAttribute('href'); // esim. "manifest.json?v=0.4.25"

    // Parsitaan query-parametri
    const url = new URL(href, window.location.href);
    const version = url.searchParams.get('v') || "n/a";

    // Näytetään Asetukset-kohtaan
    document.getElementById('version-display').textContent = version;
  }

  function onCompassDirection(event) {
    // noinspection JSUnresolvedReference
    const evc = event.webkitCompassHeading;
    let angle = evc || event.alpha;

    // Safari iOS
    if (!event.absolute && evc) {
        angle = 360 - angle;
    }

    // noinspection JSDeprecatedSymbols
    const wori = window.orientation
    let deviceOrientation =  (screen.orientation && screen.orientation.angle) || wori || 0;

    // Older browsers and iOS
    if (!event.absolute && 'undefined' !== typeof wori) {
         deviceOrientation = wori;
    }
    // const debug = document.getElementById('distance');
    // debug.innerText = `${angle.toFixed(0)}° / ${deviceOrientation}°`;
    const newAngle = angle - deviceOrientation;
    if (options.showCompass === "compass") setCompassRotation(newAngle);
    if (options.showRotate === "compass") mapWrapper.setBearing(newAngle);
  }

  function initCompass() {
    const compassElem = document.getElementById('compass');
    if (options.showCompass === "none")  compassElem.style.display = 'none';
    else compassElem.style.display = 'block';

    let deviceOrientationEvent = null;
    if ('ondeviceorientationabsolute' in window) {
        deviceOrientationEvent = 'deviceorientationabsolute';
    } else if('ondeviceorientation' in window) {
        deviceOrientationEvent = 'deviceorientation';
    }
    window.removeEventListener(deviceOrientationEvent, onCompassDirection);
    if (options.showCompass !== "compass" && options.showRotate !== "compass") return;

    window.addEventListener(deviceOrientationEvent, onCompassDirection);
  }

  function initRotate() {
    initCompass(); // to set/remove listener
    if (!mapWrapper) return;
    if (options.showRotate === "none") {
      mapWrapper.setBearing(0);
    }
    mapWrapper.setRotateControl(options.showRotate);
  }



  function initializeMapPage() {
    showVersion()
    checkSavedValues();
    createCompsSettings();

    const pzoom = parseInt(getValueFromParamsOrStrore("zoom", 8));
    const lat = getValueFromParamsOrStrore("lat", 62.25); // params["lat"] || localStorage.lat || 62.25;
    const lon = getValueFromParamsOrStrore("lon", 25.75); // params["lon"] || localStorage.lon || 25.75;
    const mapName = getStringFromParamsOrStrore("mapName", "OpenStreet");
    localStorage.lat = lat;
    localStorage.lon = lon;
    localStorage.zoom = pzoom;
    localStorage.mapName = mapName;

    mapWrapper = new MapWrapper('map', mapModes,
      {useCache:options.useCache, rotate: options.showRotate !== "none"});
    mapWrapper.setZoomButtons(options.showZoomButtons);
    mapWrapper.setDoubleClickZoom(options.doubleClickZoom);

    // Täytetään select-valikko
    const mapSelect = document.getElementById('mapModeSelect');
    for (const key in mapModes) {
      const option = document.createElement('option');
      option.value = key;
      option.textContent = key;
      mapSelect.appendChild(option);
    }

    // Alustetaan valinta ja kartta
    mapSelect.value = mapName;
    mapWrapper.setMapMode(mapSelect.value);
    mapWrapper.setView([lat, lon], pzoom);

    // Kuunnellaan valikon muutosta
    mapSelect.addEventListener('change', (e) => {
      const mapName = e.target.value;
      mapWrapper.setMapMode(mapName);
      localStorage.mapName = mapName;
    });

    checkGeoLocation();

    async function getElevation(loc) {
      // Hae korkeus OpenTopoDatasta
      const url = cycloServerUrl + `/index.php?elev=${loc[0]},${loc[1]}`;
      let elevation = ''

      try {
        const response = await fetch(url);
        const data = await response.text();
        const ndata = Number(data);

        if (!isNaN(ndata)) {
          elevation = ndata.toFixed(0) + " m";
          // console.log("Korkeus:", elevation);

          // Päivitä pinin teksti näyttämään korkeus (pyöristetty)
          // hitPin.setIcon(customPin(`${Math.round(elevation)}m`, 'red', 'black'));
        }
      } catch (err) {
        // console.error("Korkeuden haku epäonnistui:", err);
      }
      return elevation;
    }


    mapWrapper.clickTimer = null;

    mapWrapper.on('dblclick', () => {
      if (mapWrapper.clickTimer) {
        clearTimeout(mapWrapper.clickTimer);
        mapWrapper.clickTimer = null;
      }
      // Double click action, e.g. zoom in
      // mapWrapper.map.setZoom(mapWrapper.map.getZoom() + 1, { animate: true });
    });

    mapWrapper.on('click', (e) => {
      // const oe = e.originalEvent;
      // const xy = [oe.offsetX, oe.offsetY];
      // const xyp = mapWrapper.getCoordXY(e.latlng);
      // console.log('Map clicked at', xy, xyp , e.latlng);
      if (mapWrapper.clickTimer) clearTimeout(mapWrapper.clickTimer);
      mapWrapper.clickTimer = setTimeout(async () => {
        closeNav();
        if (e.originalEvent && e.originalEvent.target.id === 'mapModeSelect') return;
        const {lat, lng} = e.latlng;
        const loc = [lat, lng];
        if (!hitPin) {
          // Luo hitPin ensimmäisellä klikkauksella
          hitPin = mapWrapper.createPin(loc, 'H', 'red', function () {
            lastHitPoint = mapWrapper.getPinLocation(hitPin);
            calcDistance();
            // setPinText(`${lastHitPoint[0].toFixed(5)} ${lastHitPoint[1].toFixed(5)} Hi`);
            // calcDistance();
            // lastHitPoint = mapWrapper.getPinLocation(hitPin);
          }, null, options.flipPins);
          mapWrapper.setPinDragging(hitPin, true);
          mapWrapper.setPinOn(hitPin, 'dragend', function () {
            // Kun hitPin on siirretty, päivitetään sen sijainti
            calcDistance(-1, -1);
            lastHitPoint = mapWrapper.getPinLocation(hitPin);
            if (options.HCenter2 && options.HStationary) {
              // preventMapMove = true;
              mapWrapper.setView(lastHitPoint);
            }
            hitPinXY = mapWrapper.getCoordXY(lastHitPoint);
          });
          mapWrapper.setPinOn(hitPin, 'drag', function () {
            // Kun hitPin on siirretty, päivitetään sen sijainti
            const loc = mapWrapper.getPinLocation(hitPin);
            setPinInputText(`${loc[0].toFixed(5)} ${loc[1].toFixed(5)} H`);
            calcDistance(-1, -1);
          });
          mapWrapper.setPinOn(hitPin, 'drag', function () {
            // Kun hitPin on siirretty, päivitetään sen sijainti
            const loc = mapWrapper.getPinLocation(hitPin);
            setPinInputText(`${loc[0].toFixed(5)} ${loc[1].toFixed(5)} H`);
            calcDistance(-1, -1);
          });
        } else
          // Siirrä olemassa olevaa hitPiniä uuteen paikkaan
        if (distanceLines.length > 0) {
          lastHitPoint = distanceLines[distanceLines.length - 1].to;
        }
        mapWrapper.setPinLocation(hitPin, loc);
        setHitPinLoc(loc);
        hitPinXY = mapWrapper.getCoordXY(mapWrapper.getPinLocation(hitPin));
        lastHitPoint = loc;

        const elevation = await getElevation(loc);

        setPinInputText(`${lat.toFixed(5)} ${lng.toFixed(5)} H ${elevation}`);
        if (options.HCenter2 && options.HStationary) {
          mapWrapper.setView(loc);
        }
        if (options.simulateSpeed) simulateGPS();
      }, options.doubleClickZoom ? 250 : 0);
    }); // mapWarpper.on  click end

    mapWrapper.on('move', mapMove);

    mapWrapper.map.on('zoomend', function () {
      const zoom = mapWrapper.getZoom();
      localStorage.zoom = zoom;
    });

    prefixHelpLinks();

    if (options.id !== "")
      toggleDiv("accountArea", false);
    else
      toggleDiv("followArea", false);

    document.getElementById('searchCombo').addEventListener('change', function () {
      const idx = this.selectedIndex - 1; // first is number of items found
      if (idx >= 0 && idx < searchPins.length) {
        const pin = searchPins[idx];
        mapWrapper.setView(mapWrapper.getPinLocation(pin));
        changeSelected(pin, true);
      }
    });

    readComponents();
    checkShowComponents();
    adjustComponents();

//if ('serviceWorker' in navigator) {
//  navigator.serviceWorker.register('sw.js');
//}
    const opens = params["open"] || "";

    if (opens) {
      const ops = opens.split(",");
      for (let i in ops) {
        openDiv(ops[i].trim());
      }
    }

    // Select all text in any input[type="text"] when focused
    document.querySelectorAll('input[type="text"]').forEach(input => {
      input.addEventListener('focus', function () {
        this.select();
      });
    });


    // Make all elements with class "draggable" movable / resizable
    document.querySelectorAll('.draggable').forEach(el => {
      let isDragging = false, offsetX = 0, offsetY = 0;
      restorePos(el);

      function clamp(val, min, max) {
        return Math.max(min, Math.min(val, max));
      }

      function savePos(el) {
        const rect = el.getBoundingClientRect();
        localStorage[el.id + '_pos'] = `${Math.trunc(rect.left)};${Math.trunc(rect.top)};${Math.trunc(rect.width)};${Math.trunc(rect.height)}`;
      }

      function restorePos(el) {
        const pos = localStorage[el.id + '_pos'];
        if (pos) {
          try {
            const [left, top, width, height] = pos.split(';');
            const w = width/2;
            const h = height/2;
            const maxRight = window.innerWidth - w;
            const maxBottom = window.innerHeight - h;
            el.style.position = 'absolute';
            el.style.width = width + 'px';
            if (!el.style.aspectRatio) el.style.height = height + 'px';
            el.style.right = ''; // Remove right to allow left positioning
            el.style.left = clamp(left, -w, maxRight) + 'px';
            el.style.top = clamp(top, -h, maxBottom) + 'px';
          } catch (e) {
            // Ignore JSON parse errors
          }
        }
      }

      el.addEventListener('mousedown', onMouseDown);
      el.addEventListener('touchstart', onMouseDown);

      function onMouseDown(e) {
        e.preventDefault();
        let et = e; if (e.touches) {
          et = e.touches[0];
          el.classList.add('show-handle');
          setTimeout(() => el.classList.remove('show-handle'), 2000);
        }
        isDragging = true;
        const rect = el.getBoundingClientRect();
        offsetX = et.clientX - rect.left; // el.offsetLeft;
        offsetY = et.clientY - rect.top; // el.offsetTop;
        el.style.cursor = 'move';
        el.style.position = 'absolute';
        document.addEventListener('mousemove', onMouseMove, {passive: false});
        document.addEventListener('mouseup', onMouseUp, {passive: false});
        document.addEventListener('touchmove', onMouseMove, {passive: false});
        document.addEventListener('touchend', onMouseUp);
      }

      function onMouseMove(e) {
        if (!isDragging) return;
        let et = e; if (e.touches) et = e.touches[0];
        const w = el.offsetWidth/2;
        const h = el.offsetHeight/2;
        const maxRight = window.innerWidth - w;
        const maxBottom = window.innerHeight - h;
        el.style.right = ''; // Remove right to allow left positioning
        el.style.left = clamp(et.clientX - offsetX, -w, maxRight) + 'px';
        el.style.top = clamp(et.clientY - offsetY, -h, maxBottom) + 'px';
        el.position = 'absolute';
        // const debug = document.getElementById('distance');
        // debug.innerText = `${window.innerWidth} ${el.style.left}`;
        e.preventDefault();
      }

      function onMouseUp(e) {
        if (!isDragging) return;
        e.preventDefault();
        document.removeEventListener('mousemove', onMouseMove);
        document.removeEventListener('mouseup', onMouseUp);
        document.removeEventListener('touchmove', onMouseMove);
        document.removeEventListener('touchend', onMouseUp);
        isDragging = false;
        el.style.cursor = 'pointer';
        savePos(el);
      }

      const handle = el.querySelector('.resize-handle');

      if (handle) {
        handle.addEventListener('mousedown', handleMouseDown, { passive: false });
        handle.addEventListener('touchstart', handleMouseDown, { passive: false });

        function handleMouseDown(e) {
          e.stopPropagation();
          e.preventDefault();
          let et = e; if (e.touches) et = e.touches[0];
          let startX = et.clientX;
          let startY = et.clientY;
          let startW = el.offsetWidth;
          let startH = el.offsetHeight;

          document.addEventListener('mousemove', onHandleMouseMove, { passive: false });
          document.addEventListener('mouseup', onHandleMouseUp, { passive: false });
          document.addEventListener('touchmove', onHandleMouseMove, { passive: false });
          document.addEventListener('touchend', onHandleMouseUp, { passive: false });

          function onHandleMouseMove(e) {
            // e.stopPropagation();
            e.preventDefault();
            let et = e; if (e.touches) et = e.touches[0];
            let newW = clamp(startW + (et.clientX - startX), 30, window.innerWidth);
            let newH = clamp(startH + (et.clientY - startY), 30, window.innerHeight);
            let aspect = getAspectRatio(el.style.aspectRatio);
            if (aspect) {
              newH = newW / aspect;
              if (newH > window.innerHeight) {
                newH = window.innerHeight;
                newW = newH * aspect;
              } else {
                newH = clamp(startH + (et.clientY - startY), 30, window.innerHeight);
              }
            }
            el.style.width = newW + 'px';
            if (!el.style.aspectRatio) {
              el.style.height = newH + 'px';
            }
          }

          function onHandleMouseUp(e) {
            // e.stopPropagation();
            e.preventDefault();
            document.removeEventListener('mousemove', onHandleMouseMove);
            document.removeEventListener('mouseup', onHandleMouseUp);
            document.removeEventListener('touchmove', onHandleMouseMove);
            document.removeEventListener('touchend', onHandleMouseUp);
            savePos(el);
          }
        }
      } // if handle

    });
    // draggable end

    initRotate(); // calls also initCompass
  } // initializeMapPage ends


  //#endregion Initialization



  function closeParent(element) {
    if (element.parentElement) {
      element.parentElement.style.display = 'none';
    }
  }

  let mySidenavElem = null;
  let menuElem = null;

  function checkMenuElements() {
    if (menuElem === null) {
      menuElem = document.getElementById("menu");
      mySidenavElem = document.getElementById("mySidenav");
    }
  }

  function isMenuOpen() {
    checkMenuElements()
    let s = menuElem.style;
    return s.visibility === "visible";
  }

  function openNav() {
    if (isMenuOpen()) {
      closeNav();
      return;
    }
    let s = menuElem.style;
    // s.width = "300px";
    // s.height = "350px";
    s.visibility = "visible";
    s = mySidenavElem.style;
    s.visibility = "visible";
  }


  function closeNav() {
    checkMenuElements()
    let s = mySidenavElem.style;
    s.visibility = "hidden";
    s = menuElem.style;
    s.visibility = "hidden";
  }

  function toggleDiv(divId, force = null, callBackShow = null, callBackHide = null) {
    const div = document.getElementById(divId);
    let show = div.style.display !== 'block';
    if (force !== null) {
      show = force;
    }
    if (show) {
      div.style.display = 'block';
      div.style.visibility = 'visible';
      if (callBackShow) callBackShow();
    } else {
      div.style.display = 'none';
      div.style.visibility = 'hidden';
      if (callBackHide) callBackHide();
    }
  }


  function findMyPlace() {
    mapWrapper.setBearing(0);
    if (!myPin) return;
    // Siirretään kartta käyttäjän sijaintiin
    const center = mapWrapper.getPinLocation(myPin);
    mapWrapper.setView(center);
  }

  function toggleFullscreen() {
    const elem = document.documentElement; // Käytetään koko sivua

    // noinspection JSUnresolvedReference
    if (document.fullscreenElement || document.mozFullScreenElement || document.webkitFullscreenElement || document.msFullscreenElement) {
      // Poistetaan fullscreen-tila
      if (document.exitFullscreen) {
        document.exitFullscreen();
      } else { // noinspection JSUnresolvedReference
        if (document.mozCancelFullScreen) { // Firefox
          document.mozCancelFullScreen();
        } else { // noinspection JSUnresolvedReference
          if (document.webkitExitFullscreen) { // Chrome, Safari ja Opera
            document.webkitExitFullscreen();
          } else { // noinspection JSUnresolvedReference
            if (document.msExitFullscreen) { // IE/Edge
              document.msExitFullscreen();
            }
          }
        }
      }
    } else {
      openFullscreen(elem);
    }
  }

  function openFullscreen(elem) {
    if (elem.requestFullscreen) {
      elem.requestFullscreen();
    } else { // noinspection JSUnresolvedReference
      if (elem.mozRequestFullScreen) { // Firefox
        elem.mozRequestFullScreen();
      } else { // noinspection JSUnresolvedReference
        if (elem.webkitRequestFullscreen) { // Chrome, Safari and Opera
          elem.webkitRequestFullscreen();
        } else { // noinspection JSUnresolvedReference
          if (elem.msRequestFullscreen) { // IE/Edge
            elem.msRequestFullscreen();
          }
        }
      }
    }
  }


  window.addEventListener('DOMContentLoaded', initializeMapPage);
  // window.addEventListener('DOMContentLoaded', () => showRoutePane(1));

  function setOption(name, value) {
    options[name] = value;
    localStorage.setItem(name, value);
  }


  function setOptionInt(name, value, def) {
    const val = parseInt(value) || def;
    options[name] = val;
    localStorage.setItem(name, "" + val);
  }


  function getOptionValue(name) {
    return localStorage[name];
  }


  function getOption(name, editName) {
    if (!editName) editName = name;
    const edit = document.getElementById(editName);
    options[name] = params[name] || localStorage.getItem(name) || "";
    if (!edit) return;
    if (options[name] !== "")
      edit.value = options[name]; //document.getElementById(edit).value = options[name];
    // noinspection JSUnusedLocalSymbols
    edit.addEventListener("change", function (event) {
      setOption(name, this.value);
    });
    setOption(name, edit.value);
  }


  function getOptionInt(name, editName, def) {
    if (!editName) editName = name;
    const edit = document.getElementById(editName);
    const val = parseInt(localStorage.getItem(name)) || def || (edit ? parseInt(edit.value) : undefined);
    options[name] = params[name] ?? val ?? def;
    if (!edit) return;
    if (options[name] !== "")
      edit.value = options[name];
    // noinspection JSUnusedLocalSymbols
    edit.addEventListener("change", function (event) {
      setOptionInt(name, this.value, def);
    });
    setOptionInt(name, edit.value, def);
  }


  function getBoolean(s) {
    if (typeof (s) === typeof true) return s;
    if (s === '1') return true;
    s = s.toUpperCase();
    if (s === "TRUE") return true;
    return s === "YES";

  }


  function setCBOption(name, value) {
    if (value === undefined) return;
    value = getBoolean(value);
    options[name] = value;
    localStorage.setItem(name, value);
  }


  function getCBOption(name, f) {
    const cb = document.getElementById(name);
    if (!cb)
      return;
    let value = params[name];
    if (value === undefined) value = getBoolean(localStorage.getItem(name) || options[name] || false);
    else value = getBoolean(value);
    options[name] = value;
    if (options[name]) {
      cb.checked = true;
      options[name] = true; // ??? ei kai tarviisi
    } else options[name] = false;

    // noinspection JSUnusedLocalSymbols
    cb.addEventListener("click", function (event) {
      setCBOption(name, this.checked);
      if (typeof f !== "undefined") f(this.checked);
    });
    setCBOption(name, cb.checked);
  }

  function setDDOption(name, value) {
    if (value === undefined) return;
    options[name] = value;
    localStorage.setItem(name, value);
  }


  function getDDOption(name, f) {
    const dd = document.getElementById(name);
    if (!dd)
      return;
    let value = params[name];
    if (value === undefined) value = localStorage.getItem(name) || options[name] || undefined;
    options[name] = value;
    if (options[name]) {
      dd.value = value;
    }

    // noinspection JSUnusedLocalSymbols
    dd.addEventListener("change", function (event) {
      setDDOption(name, event.target.value);
      if (typeof f !== "undefined") f(event.target.value);
    });
    setDDOption(name, dd.value);
  }

  function changeRaportView() {
    // TODO: korjaa raportin näkymä
    /*
    const sb = document.getElementById("editRaport").style;
    const ss = document.getElementById("editSmallRaport").style;
    if ( options.smallRaport ) {
    //      closeDiv("editRaport");
    //      openDiv("editSmallRaport");
      sb.height = "0px";
      sb.visibility = "hidden";
      ss.height = "auto";
      ss.visibility = "inherit";
    } else {
      //      openDiv("editRaport");
      //      closeDiv("editSmallRaport");
      ss.height = "0px";
      ss.visibility = "hidden";
      sb.height = "auto";
      sb.visibility = "inherit";
    }
    */
  }


  // Ks: https://github.com/richtr/NoSleep.js/blob/master/src/index.js
  // The wake lock sentinel.
  if ('wakeLock' in navigator) {
    options.hasWakeLock = true;
  }
  let wakeLock = null;

  // Function that attempts to request a screen wake lock.
  // async // IE11 does not like async, but we manage without it using then and teh fact that this is never called in ie
  function requestWakeLock() {
    // alert('Start Wake Lock 2');
    endWakeLock();
    if (document.visibilityState === "hidden") return;
    try {
      // noinspection JSUnresolvedVariable
      // wakeLock = await navigator.wakeLock.request('screen'); // does not work on ie
      // wakeLock.addEventListener('release', function() {/* alert('Screen Wake Lock was released'); */ });
      // alert('Screen Wake Lock is active');
      navigator.wakeLock.request('screen').then(function (wl) {
        wakeLock = wl;
        wakeLock.addEventListener('release', function () {
          // alert('Screen Wake Lock was released'); */
        });
        document.addEventListener('visibilitychange', handleVisibilityChange);
        // alert('Screen Wake Lock is active');
      });
    } catch (err) {
      alert(err.name + err.message);
    }
  }

  if ('wakeLock' in navigator) {
    options.hasWakeLock = true;
  }

  function handleVisibilityChange() {
    if (wakeLock !== null && document.visibilityState === 'visible') {
      requestWakeLock();
    }
  }


  function startWakeLock() {
    // alert('Start Wake Lock 1');
    requestWakeLock();
  }


  function endWakeLock() {
    if (!wakeLock) return;
    wakeLock.release();
    document.removeEventListener('visibilitychange', handleVisibilityChange);
    wakeLock = null;
    // alert('Wake Lock released');
  }


  function checkSleep() {
    if (options.preventSleep && options.hasWakeLock) {
      startWakeLock();
    }
    if (!options.preventSleep) {
      endWakeLock();
    }
  }


  function removeDistance() {
    mapWrapper.removeLines(distanceLines);
    lastHitPoint = mapWrapper.getPinLocation(hitPin);
  }

  function checkSavedValues() {
    if (!options.hasWakeLock) {
      const s = document.getElementById("preventSleepSpan").style;
      s.visibility = "hidden";
    }

    getOption("followMeColor", "editFollowMeColor");
    getOptionInt("followMeWidth", "editFollowMeWidth", 3);

    getOption("email", "editEmail");
    getOption("id", "editId");
    getOption("usersTofollow", "editUsersTofollow");
    getOption("to", "editTo");
    getOption("from", "editFrom");
    getOption("tpR", "editTPR");
    getOption("hereApiKey");
    getOption("graphHopperApiKey");
    getOptionInt("speechRate");

    getOption("tag", "editTag");
    getOption("logname", "editLog");
    getOption("interval", "editInterval");
    getOption("trackColors", "editTrackColors");
    getOption("routeColors", "editRouteColors");

    getCBOption("follow", function (checked) {
      checkTimer("follow", !checked);
    });
    getCBOption("followMe", function () { /*checkTimer("followMe");*/
    });
    getCBOption("selectNewPin", function () { /*checkTimer("followMe");*/
    });
    // getCBOption("useDummyRect",function() { /*checkTimer("followMe");*/ } );
    getCBOption("flipPins");
    getCBOption("preventSleep", function () {
      checkSleep();
    });
    getCBOption("smallRaport", function () {
      changeRaportView();
    });
    // getCBOption("showAccuracy");
    getCBOption("useCache", function () {
      if (mapWrapper) mapWrapper.setUseCache(options.useCache);
    });
    getCBOption("HStationary");
    getCBOption("HCenter2");
    getCBOption("send"); // ,sendPosition);
    getCBOption("drawLogLine");
    // getCBOption("readGPS",function() { checkTimer("readGPS"); });
    getCBOption("readGPS", function () {
      checkGeoLocation();
    });
    getCBOption("useComps", function () {
      checkShowComponents();
    });
    getCBOption("useCompsWindow");
    getCBOption("drawDistanceLine");
    getCBOption("doubleClickZoom", function () {
      if (mapWrapper) mapWrapper.setDoubleClickZoom(options.doubleClickZoom);
    });
    getCBOption("calcDistanceSum");
    getCBOption("showZoomButtons", function () {
      if (mapWrapper) mapWrapper.setZoomButtons(options.showZoomButtons);
    });
    getDDOption("showRotate", initRotate);
    getDDOption("showCompass", initCompass);

    getOptionInt("simulateSpeed");
    getOptionInt("lastRouter");

    getOptionInt("instLeadTime");
    getOptionInt("polygonAckRadius");
    getOptionInt("routePointAckRadius");

    const cb1 = document.getElementById('area1cb');
    const cb2 = document.getElementById('area1cbCopy');

    /*
    for (let area of areaDatas) {
      getCBOption(area.cb, function () {
        checkArea(area);
      });
      getCBOption(area.cb + "Own", function () {
        checkAreaColor(area);
      });
      getOption(area.cb + "Opt", area.cb + "Opt")
    }

     */

    // Sync the two checkboxes
    cb1.addEventListener('change', syncCheckboxes);
    cb2.addEventListener('change', syncCheckboxes);

    function syncCheckboxes(e) {
      cb1.checked = cb2.checked = e.target.checked;
      if (e.target === cb2) {
        // Trigger cb1's change event so all logic runs
        cb1.dispatchEvent(new Event('click', {bubbles: true}));
      }
    }

    cb2.checked = cb1.checked;

    checkTimer("follow", !options.follow);
    // checkTimer("readGPS");
    changeRaportView();

    checkSleep(); // check if use wake lock or not

    options.dialect = localStorage.getItem('dialect') || 'savo';

    // Route transport mode selection
    options.routeMode = localStorage.getItem('routeMode');
    const choices = document.querySelectorAll('#transportChoices .transport-choice');
    choices.forEach(choice => {
      if (choice.dataset.mode === options.routeMode) {
        choice.classList.add('selected');
      }
      choice.addEventListener('click', () => {
        choices.forEach(c => c.classList.remove('selected'));
        choice.classList.add('selected');
        const mode = choice.dataset.mode;
        options.routeMode = mode;
        localStorage.setItem('routeMode', mode);
        // You can use choice.dataset.mode for the selected mode
      });
    });
    // End of route transport mode selection}

    checkRouterButtons();
  }

  async function clearServiceWorker() {
    if ('serviceWorker' in navigator) {
      // Unregister all service workers for this origin
      const regs = await navigator.serviceWorker.getRegistrations();
      for (let reg of regs) {
        await reg.unregister();
      }
      // Optionally, clear caches
      if ('caches' in window) {
        const names = await caches.keys();
        for (let name of names) {
          await caches.delete(name);
        }
      }
    }
    location.reload(); // Reload the page to ensure everything is reset
  }

  function checkMemoryUsage() {
    if ('storage' in navigator && 'estimate' in navigator.storage) {
      navigator.storage.estimate().then(estimate => {
        document.getElementById('memoryUsage').textContent =
          `Käytetty: ${(estimate.usage / 1e6).toFixed(2)} MB
Tilaa: ${(estimate.quota / 1e6).toFixed(2)} MB`;
      });
    } else {
      document.getElementById('memoryUsage').textContent =
        "Muistin käyttöä ei voi arvioida tässä ympäristössä.";
    }
  }

  //#region Meter Components
  //=================================================================
  // Functions to handle components:
  //=================================================================
  //#region meter components helppers
  function setAutoComp(comp, name, value) {
    comp[name] = value;
    localStorage.setItem("acomp." + comp.name + "." + name, JSON.stringify(value));
  }

  function getAutoComp(comp, name, def, f) {
    const s = localStorage.getItem("acomp." + comp.name + "." + name);
    if (s === null) {
      setAutoComp(comp, name, def);
      return def;
    }
    let value = JSON.parse(s);
    if (f) value = f(value);
    return value
  }

  const getSpeed = function (comp, position) {
    return position.coords.speed * 3.6;
  }

  const getAlt = function (comp, position) {
    return position.coords.altitude;
  }

  const getDir = function (comp, position) {
    return position.coords.heading;
  }

  const clearTrip = function (comp) {
    setAutoComp(comp, "distSum", 0);
    comp.lastPos = undefined;
    localStorage.removeItem("acomp.Trip.lastPos");
    comp.value = 0;
    comp.span.innerText = "0.000";
  }

  const getTrip = function (comp, position) {
    let coord = {latitude: position.coords.latitude, longitude: position.coords.longitude};
    if (!startstop.checked) {
      setAutoComp(comp, "lastPos", coord);
      if (comp.temp === undefined) {
        comp.temp = getAutoComp(comp, "distSum", 0);
        return comp.temp;
      }
      return null;
    }
    let old = comp.lastPos;
    if (old === undefined) {
      old = getAutoComp(comp, "lastPos", coord);
    }
    const d = WGS84_distance(coord, old);
    // componentsList["Temp"].span.innerText = d + " " +  JSON.stringify(old);
    let distSum = comp["distSum"];
    if (distSum === undefined) {
      distSum = getAutoComp(comp, "distSum", 0);
    }
    if (d < 0.005) return distSum;
    distSum += d;
    setAutoComp(comp, "distSum", distSum);
    setAutoComp(comp, "lastPos", coord);
    return distSum;
  }

  const clearElap = function (comp) {
    setAutoComp(comp, "elapZero", (new Date()).getTime());
    setAutoComp(comp, "elapSum", 0);
  }

  const startCounters = function (start) {
    // let trip = namedComponents["Trip"];
    let elap = namedComponents["Elap"];
    if (elap) {
      if (start) setAutoComp(elap, "elapZero", (new Date()).getTime());
      else setAutoComp(elap, "elapSum", elap.sum);
    }
  }

  const msToHMS = function (ms) {
    const h = Math.floor(ms / 1000 / 60 / 60);
    ms -= h * 1000 * 60 * 60;
    const m = Math.floor(ms / 1000 / 60);
    ms -= m * 1000 * 60;
    const s = Math.floor(ms / 1000);
    return h + ":" + d2(m) + ":" + d2(s);
  }

  const getElap = function (comp, now) {
    if (!startstop.checked) {
      if (comp.temp !== undefined) return null;
      comp.temp = getAutoComp(comp, "elapSum", 0);
      return msToHMS(comp.temp);
    }
    let old = comp["elapZero"];
    if (old === undefined) {
      // old = getAutoComp(comp, "elapZero", now, value => new Date(value));
      old = getAutoComp(comp, "elapZero", now.getTime());
    }
    // let diff = now.getTime() - old.getTime();
    let nowt = now.getTime();
    let diff = nowt - old;
    const elapSum = getAutoComp(comp, "elapSum", 0);
    diff += elapSum;
    comp.sum = diff;
    return msToHMS(diff);
  }

  const getTime = function (comp, now) {
    const time = now.getHours() + ":" + d2(now.getMinutes()) + ":" + d2(now.getSeconds());
    return time;
  }


  const componentsList = {
    "Speed": {inUse: true, label: "Nopeus", unit: "km/h", font: "50px", back: "", len: 5, des: 1, f: getSpeed, type: 0},
    "Trip": {
      inUse: true,
      label: "Matka",
      unit: "km",
      font: "40px",
      back: "",
      len: -4,
      des: 3,
      f: getTrip,
      type: 0,
      click: clearTrip
    },
    "Alt": {inUse: true, label: "Korkeus", unit: "m", font: "30px", back: "", len: 4, des: 0, f: getAlt, type: 0},
    "Dir": {inUse: true, label: "Suunta", unit: "deg", font: "20px", back: "", len: 3, des: 0, f: getDir, type: 0},
    "Elap": {
      inUse: true,
      label: "Aika",
      unit: "aika",
      font: "20px",
      back: "",
      len: 3,
      des: -1,
      f: getElap,
      type: 1,
      click: clearElap
    },
    "Time": {inUse: false, label: "Kello", unit: "kello", font: "20px", back: "", len: 3, des: -1, f: getTime, type: 1},
//  "Temp":  {inUse: true,  label: "Temp",    unit: "temp", font: "10px", back: "rgba(255, 255, 255, 0.6)", len: 3, des: -1, f: null,     type: 2},
  }
  //#endregion meter components helppers


  let compsdiv = null;
  let startstop = {checked: false};  // Matki checkboxia jos ei luotu
  const namedComponents = {};

  function checkShowComponents() {
    let cb = options.useComps;
    let setDiv = document.getElementById("showCompsSettings");
    let useDiv = document.getElementById("showComps");
    if (!cb) {
      setDiv.style.display = "none";
      useDiv.style.display = "none";
    } else {
      setDiv.style.display = "block";
      useDiv.style.display = "block";
    }
  }

  function adjustComponents() {
    saveComponents();
    const compsdiv = document.getElementById("showComps");
    compsdiv.style.backgroundColor = document.getElementById("editCompsBackground").value;
    compsdiv.style.color = document.getElementById("editCompsColor").value;
    createComps();
    checkTimer("showTime", timecomponents.length === 0 || !options.useComps);
  }

  function readComponents() {
    let bs = localStorage.getItem("editCompsBackground");
    if (bs) document.getElementById("editCompsBackground").value = bs;

    bs = localStorage.getItem("editCompsColor");
    if (bs) document.getElementById("editCompsColor").value = bs;

    for (const name in componentsList) {
      const comp = componentsList[name];
      let s = localStorage.getItem(name);
      if (s) comp.editFont.value = s;
      s = localStorage.getItem(name + "Col");
      if (s !== null) comp.editCol.value = s;
      s = localStorage.getItem(name + "Cb");
      if (s !== null) {
        comp.cbUse.checked = s === "1";
        comp.inUse = comp.cbUse.checked;
      }
    }
  }

  function saveComponents() {
    localStorage.setItem("editCompsBackground", document.getElementById("editCompsBackground").value);
    localStorage.setItem("editCompsColor", document.getElementById("editCompsColor").value);
    for (const name in componentsList) {
      const comp = componentsList[name];
      localStorage.setItem(name, comp.editFont.value);
      localStorage.setItem(name + "Col", comp.editCol.value);
      localStorage.setItem(name + "Cb", comp.cbUse.checked ? "1" : "0");
      comp.inUse = comp.cbUse.checked;
    }
  }

  function addTD(tr, text) {
    const td = document.createElement("td");
    td.innerText = text;
    tr.appendChild(td);
  }

  function addTDInput(tr, id) {
    const td = document.createElement("td");
    tr.appendChild(td);
    // <input type="text" id="editSpeed" value="50px" size="3" /></td><td><input type="text" id="editSpeedCol" value="rgba(255, 255, 255, 0.6)" size="20" />
    const input = document.createElement("input");
    input.id = id;
    const label = document.createElement("label");
    label.htmlFor = id; // associate label with input
    label.textContent = ""; // empty label
    td.appendChild(label);
    td.appendChild(input);
    return input;
  }

  function addTDCB(tr, id) {
    const cb = addTDInput(tr, id);
    cb.setAttribute("type", "checkbox");
    return cb;
  }

  function addTDEdit(tr, name, size, text) {
    // <input type="text" id="editSpeed" value="50px" size="3" /></td><td><input type="text" id="editSpeedCol" value="rgba(255, 255, 255, 0.6)" size="20" />
    const edit = addTDInput(tr, "edit" + name);
    edit.setAttribute("size", size);
    edit.setAttribute("value", text);
    edit.innerHTML = text;
    return edit;
  }

  function createCompsSettings() {

    compsdiv = document.getElementById("showComps");
    const table = document.getElementById("tableCompsSettings");
    table.innerHTML = "<tr><td></td><td>Mittari</td><td>Fontti</td><td>Taustan väri</td></tr>";

    for (const name in componentsList) {
      const comp = componentsList[name];
      const tr = document.createElement("tr");
      const cbUse = addTDCB(tr, "cbm" + name);
      cbUse.checked = comp.inUse;
      addTD(tr, comp.label);
      const editFont = addTDEdit(tr, name, 3, comp.font);
      const editCol = addTDEdit(tr, name + "Col", 20, comp.back);
      comp.cbUse = cbUse;
      comp.editFont = editFont;
      comp.editCol = editCol;
      comp.div = null;
      comp.span = null;
      comp.name = name;
      comp.value = 0;
      table.appendChild(tr);
    }
    createComps();
  }

  function showCompsDiv(show) {
    if (show) {
      compsdiv.style.display = "inherit";
      if (compsWindow) compsWindow.show();
    } else {
      compsdiv.style.display = "none";
      if (compsWindow) compsWindow.hide();
    }
  }


  let compsWindow = null;

  function readWindowPos(w) {
    if (w === null) return;
    const s = localStorage.getItem(w.id + 'Pos');
    if (s === null) return;
    let xywh = s.split(";");
    w.x = parseInt(xywh[0]);
    w.y = parseInt(xywh[1]);
    w.width = parseInt(xywh[2]);
    w.height = parseInt(xywh[3]);
    w.move(w.x, w.y);
    w.resize(w.width, w.height);
  }

  function saveWindowPos(w) {
    if (w === null) return;
    const s = `${w.x};${w.y};${w.width};${w.height}`;
    localStorage.setItem(w.id + 'Pos', s);
  }


  function createComps() {
    readComponents();
    // noinspection JSUnresolvedReference
    if (options.useCompsWindow && compsWindow === null && typeof WinBox === "function") {
      // noinspection JSUnresolvedReference
      compsWindow = new WinBox("Mittarit", {
        id: "compsWindow",
        mount: document.getElementById("showComps"),
        height: 69,
        width: 410,
        header: 16,
        y: "bottom",
        onresize: function () {
          saveWindowPos(compsWindow);
        },
        onmove: function () {
          saveWindowPos(compsWindow);
        },
        onclose: function () {
          compsWindow = null;
          return false;
        },
        // background: document.getElementById("editCompsBackground").value,
      });
      readWindowPos(compsWindow);
      // compsWindow.onmove = function(x,y) { saveWindowPos(compsWindow); };
      // compsWindow.onresize = function(w,h) { saveWindowPos(compsWindow); };
    }
    if (!options.useCompsWindow && compsWindow !== null) {
      compsWindow.close(true);
      compsWindow = null;
    }

    if (compsWindow !== null) {
      const sheet = document.styleSheets[4]; // TODO: keksi oikea tapa löytää
      let bc = document.getElementById("editCompsBackground").value;
      if (bc.startsWith("rgba(") || bc.startsWith("hsla(")) {
        bc = bc.replace(/,[^,]*\)/, ",1)");
      }
      if (sheet && sheet.cssRules) {
        if (sheet.cssRules[0].cssText.startsWith("#compsWindow .wb-body")) sheet.deleteRule(0);
        sheet.insertRule(`#compsWindow .wb-body {background: ${bc}}`, 0);
      }
    }

    geocomponents = [];
    timecomponents = [];
    compsdiv.innerHTML = '<span style="top: 0;  position: absolute" onclick="showCompsDiv(false)"><</span>' +
      ''; //'<br />';

    startstop = document.createElement("input");
    startstop.setAttribute("type", "checkbox");
    startstop.style.verticalAlign = "bottom";
    startstop.onclick = function () {
      localStorage.setItem("startstop", startstop.checked ? "1" : "0");
      startCounters(startstop.checked);
    }
    startstop.checked = localStorage.getItem("startstop") !== "0"; // oletus päällä
    compsdiv.appendChild(startstop);

    for (const name in componentsList) {
      const comp = componentsList[name];
      comp.div = null;
      comp.span = null;
    }


    for (const name in componentsList) {
      const comp = componentsList[name];
      if (!comp.inUse) continue;
      const compdiv = document.createElement("div");
      compdiv.setAttribute("id", "div" + name);
      compdiv.style.backgroundColor = comp.editCol.value;
      compdiv.classList.add("comp");
      compdiv.style.display = "inline-block"
      compsdiv.appendChild(compdiv);
      comp.div = compdiv;
      if (comp.unit) {
        const labelspan = document.createElement("span");
        labelspan.innerHTML = comp.unit;
        compdiv.appendChild(labelspan);
        compdiv.appendChild(document.createElement("br"));
      }
      const compspan = document.createElement("span");
      compspan.setAttribute("id", name.toLowerCase() + "Comp");
      compspan.style.fontSize = comp.editFont.value;
      compspan.classList.add("data");
      compspan.innerText = comp.value;
      if (comp.click) compspan.onclick = () => comp.click(comp);
      compdiv.appendChild(compspan);
      comp.span = compspan;
      if (comp.type === 0) geocomponents.push(comp);
      if (comp.type === 1) timecomponents.push(comp);
      namedComponents[name] = comp;
      // const space = document.createElement("span");
      // space.innerHTML = "&nbsp;&nbsp;"
      // compsdiv.appendChild(space);
    }
  }

  function setTimeCompsValues() {
    const now = new Date();
    for (let comp of timecomponents) {
      let v = comp.f(comp, now);
      if (v === null) continue;
      comp.span.innerText = v;
      comp.value = v;
    }
  }


  function setGeoCompsValues(position) {
    // componentsList["Speed"].span.innerHTML = Math.round(position.coords.speed * 3.6 * 10) / 10;
    // componentsList["Alt"].span.innerHTML = Math.round(position.coords.altitude);
    // componentsList["Dir"].span.innerHTML = Math.round(position.coords.heading);
    for (let comp of geocomponents) {
      let v = comp.f(comp, position);
      if (v === null) continue;
      let d = comp.len;
      if (d < 0) {
        let s = v.toPrecision(-d).slice(0, -d + 1);
        comp.span.innerText = s;
        comp.value = s;
        continue;
      }
      let des = comp.des;
      if (des < 0) {
        comp.span.innerText = v;
        comp.value = v;
        continue;
      }
      let s = v.toFixed(des);
      while (s.length < d) s = "\u2000" + s;
      // s = s.replace(/ /g, "&nbsp;")
      comp.span.innerText = s;
      comp.value = s;
    }
  }


  //=================================================================
  // Functions to handle components ends
  //=================================================================
  //#endregion Meter Components

  //# region Routing

  function pToStr(p, sep) {
    // noinspection UnnecessaryLocalVariableJS
    const s = p[0].toFixed(5) + sep + p[1].toFixed(5);
    return s;
  }


  function moveEditTo(edit) {
    const editField = document.getElementById(edit);
    editField.value = getPinInputText();
    const name = edit.replace("edit", "").toLowerCase();
    setOption(name, editField.value);
    // calcDistance();
  }

  function moveITo(edit) {
    const editField = document.getElementById(edit);
    const p = mapWrapper.getPinLocation(myPin);

    editField.value = pToStr(p, ' ');
    const name = edit.replace("edit", "").toLowerCase();
    setOption(name, editField.value);
    calcDistance();
  }


  function getNormalizedCoordinateString(s, sep) {
    const pos = getCoordinateFromText(s);
    if (pos == null) return "";
    return pos[0] + sep + pos[1];
  }


  async function checkSpecialCoord(s, def) {
    if (s.toUpperCase() === "S") {
      if (lastSelected) {
        return mapWrapper.getPinLocation(lastSelected);
      }
      s = def;
    }
    if (s === "") s = def;
    const pin = mapWrapper.findPin(s);
    if (pin) return mapWrapper.getPinLocation(pin);
    if (isCoordinate(s)) return getCoordinateFromText(s);
    return await findAddressCoordinate(s);
  }


  async function showRoutePane(routerType = -1) {
    // routerType = parseInt(routerType, 10) || 0;
    if (routerType < 0) routerType = options.lastRouter;
    let navigating = false;
    if (options.navigate) {
      navigating = true;
      options.navigate = false;
      stopNavigation();
      document.getElementById("navigate").checked = false;
    }
    checkRouterButtons();
    createRouteWindow();
    let from;
    let to;
    if (routerType === 3) {  // example
      from = [62.29978, 25.73234];
      to = [62.25574, 25.77731];
    } else {
      setOption("lastRouter", routerType);
      let fromText = getInputText("editFrom");
      if (navigating) fromText = "I"; // my location if done while navigating is on
      from = await checkSpecialCoord(fromText, "I");
      let s = getInputText("editTo");
      if (s.trim() === "") s = "S"; // selected pin if empty
      to = await checkSpecialCoord(s, "H");
    }
    // let fromPin = lastSelected;
    // if (!fromPin) fromPin = myPin;
    // const from = mapWrapper.getPinLocation(fromPin);
    // const to = mapWrapper.getPinLocation(hitPin);
    if (!from || !to) {
      let message = "";
      let toText = getInputText("editTo").trim();
      if (!from) message += "Ei löydy lähtö: " + getInputText("editFrom") + "<br>";
      if (!to) {
        message += "Ei löydy kohdetta: " + toText + "<br>";
        if (toText.toUpperCase() === "H" || toText === "") {
          message += "Klikkaa kartalla paikkaa johon haluat reitin.<br>";
        }
      }
      removeOldRoutingControl(message);
      return;
    }
    if (WGS84_distance(from, to) < 0.010) {
      removeOldRoutingControl("Pisteet ovat liian lähellä toisiaan (<10m).");
      return;
    }
    loadRoutingMachine(function () {
      switch (routerType) {
        case 0:
          findRouteOSRM(from, to, initRoutingEvents, navigating);
          break;
        case 1:
          findRouteGraphHopper(from, to, options.graphHopperApiKey, initRoutingEvents, navigating);
          break;
        case 2:
          findRouteHERE(from, to, options.hereApiKey, initRoutingEvents, navigating);
          break;
        case 3:
          findRouteHERE(from, to, options.hereApiKey, initRoutingEvents, navigating, true);
          break;
        default:
          return;
      }
    });
  }

  let routingWindow = null;

  function createRouteWindow() {
    // noinspection JSUnresolvedReference
    if (routingWindow) return;
    const routingMainDiv = document.getElementById("routingMainDiv");
    routingMainDiv.style.visibility = "visible";
    // noinspection JSUnresolvedReference
    routingWindow = new WinBox("Ajo-ohjeet", {
      id: "routingWindow",
      mount: routingMainDiv,
      height: 300,
      width: 300,
      minHeight: 20,
      minwidth: 100,
      header: 16,
      class: ["no-full", "no-max"],
      y: "25px",
      x: "right",
      onresize: function () {
        saveWindowPos(routingWindow);
      },
      onmove: function () {
        saveWindowPos(routingWindow);
      },
      onclose: function () {
        routingWindow = null;
        removeOldRoutingControl();
        return false;
      },
      // background: document.getElementById("editCompsBackground").value,
    });
    readWindowPos(routingWindow);
    // compsWindow.onmove = function(x,y) { saveWindowPos(compsWindow); };
    // compsWindow.onresize = function(w,h) { saveWindowPos(compsWindow); };
  }

  async function findDriving(routerType = 2) {
    await showRoutePane(routerType);
  }

  function googleDirections() {
    let s = getPinInputText();
    if (isCoordinate(s)) {
      s = getNormalizedCoordinateString(s, ",")
    }
    // const url = "https://www.google.com/maps/search/?api=1&query=" + s;
    const url = "https://www.google.com/maps/dir/?api=1" +
      "&destination=" + encodeURIComponent(s) + "&travelmode=driving";
    const win = window.open(url, '_blank');
    win.focus();
  }

  function checkRouterButtons() {
    const hasHere = options.hereApiKey && options.hereApiKey.length > 10;
    const hasGH = options.graphHopperApiKey && options.graphHopperApiKey.length > 10;
    document.getElementById("buttonHERE").style.display = hasHere ? "" : "none";
    document.getElementById("buttonOSRM").style.display = ""; // always available
    document.getElementById("buttonGraphHopper").style.display = hasGH ? "" : "none";
  }

  function checkNavigate(nav) {
    options.navigate = nav;
    if (nav) {
      if (!startNavigation(mapWrapper.getPinLocation(myPin))) {
        stopNavigation();
      }
    } else {
      stopNavigation();
    }
  }

  //# endregion Routing


</script>
<div id="mySidenavHamburger"
     style="top: 0; left: 0; width: 30px; height: 35px; position: absolute; z-index:1050;  background-color: lightgray;">
  <span style="font-size:30px;cursor:pointer" onclick="openNav()">&#9776;<br></span>
  <span style="font-size:30px;cursor:pointer" onclick="findMyPlace()">&#9737;</span>
</div>

<div id="mySidenav"
     style="top: 45px; left: 0;  visibility: hidden; position: absolute; z-index:1040;  background-color: lightgray;"
     onclick="closeNav()">
  <label class="closebtn" style="visibility: hidden" onclick="closeNav()">&times;</label>

  <ul class="ui-menu" id="menu" style="visibility: hidden">
    <li><span onclick="toggleDiv('settings');">Asetukset...</span> <a class="help" data-href="#settings"></a></li>
    <li><span onclick="toggleDiv('findDiv'); closeNav();">Pinnien lisääminen...</span> <a class="help"
                                                                                          data-href="#addpins"></a></li>
    <li><span onclick="loadRoutingMachine(() => toggleDiv('routingOptions', null, initRoutingOptions))">Ajo-ohjeiden asetukset...</span>
      <a class="help" data-href="#settings"></a></li>

    <li><span onclick="showRoutePane(); closeNav()">Ajo-ohjeet...</span> <a class="help" data-href="#directions"></a>
    </li>
    <li><span onclick="showRoutePane(3); closeNav()">Ajo-ohjeet esimerkki</span> <a class="help"
                                                                                 data-href="#directions"></a></li>
    <!--<li><span onclick="showRoutePane(2); closeNav()">Ajo-ohjeet OSRM</span> <a class="help" data-href="#directions"></a></li>
    <li><span onclick="showRoutePane(3); closeNav()">Ajo-ohjeet GraphHopper</span> <a class="help" data-href="#directions"></a></li>-->
    <li><span onclick="toggleDiv('loadTrack'); ">Lataa track-tiedosto...</span> <a class="help"
                                                                                   data-href="#loadtrack"></a></li>
    <li><span onclick="toggleDiv('trackDiv'); ">Näytä track-tiedot</span> <a class="help"
                                                                             data-href="#showtrackdetails"></a></li>
    <li><span onclick="toggleDiv('loadRoute'); ">Lataa reittitiedosto...</span> <a class="help"
                                                                                   data-href="#loadroute"></a></li>
    <li><span onclick="toggleDiv('routeDiv'); ">Reitin suunnittelu...</span> <a class="help" data-href="#routeplan"></a>
    </li>
    <li><span onclick="toggleDiv('routeRaport'); ">Reittiraportti...</span> <a class="help"
                                                                               data-href="#routeraport"></a></li>
    <li><span onclick="toggleDiv('loadAreas'); ">Alueet...</span> <a class="help" data-href="#areas"></a></li>
    <li><span onclick="googleDirections();">Ajo-ohjeet Google Mapsillä</span> <a class="help"
                                                                                 data-href="#googledirections"></a></li>
    <li><span onclick="toggleFullscreen()">Fullscreen</span></li>
    <li><span onclick="checkMemoryUsage(); toggleDiv('about'); ">Pika-apu/Versio...</span></li>
    <li><span onclick="clearServiceWorker()">Tarkista uusi versio</span></li>

  </ul>
  <!--Muista muuttaa korkeus openNav  (tai tee tähän tyyli automaattiseksi) -->
</div>


<div class="layout-container">
  <!--suppress HtmlFormInputWithoutLabel -->
  <div id="findDiv" class="ui-layout-north">
    <label class="closebtn" style="top: -10px" onclick=closeParent(this)>&times;</label>
    <div id="pinDiv" style="margin-left: 35px">
      <!-- <label class="hamburgerSpace"> </label> -->
      <label><!--suppress JSDeprecatedSymbols -->
        <input type="text" name="editPinLoc" id="editPinLoc" value="Tontuntie"
               onkeyup="checkAddPinText()"
               onkeydown="if(event.key === 'Enter') { addPin(); event.preventDefault(); }"/></label>
      <span class="clearButton" id="buttonClearText" onclick="setPinInputText('')">x</span>
      <button type="button" id="buttonAddPin" onclick="addPin()">Etsi</button>
      <span id="pinButtons" style="display: none;">
      <button title="Vaihda pinnin tiedot" class="icon-btn" onclick="changePinData()">
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="black" stroke-width="2">
          <path d="M3 17.25V21h3.75l11.06-11.06-3.75-3.75L3 17.25z"/>
          <path d="M20.71 7.04a1 1 0 0 0 0-1.42l-2.34-2.34a1 1 0 0 0-1.42 0l-1.83 1.83 3.75 3.75 1.84-1.82z"/>
        </svg>
      </button>
      <button title="Poista pinni" class="icon-btn" onclick="removePin()">
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="black" stroke-width="2"
             stroke-linecap="round" stroke-linejoin="round">
          <rect x="3" y="6" width="18" height="15" rx="2"/>
          <line x1="9" y1="10" x2="9" y2="19"/>
          <line x1="15" y1="10" x2="15" y2="19"/>
          <line x1="4" y1="6" x2="20" y2="6"/>
          <line x1="10" y1="3" x2="14" y2="3"/>
          <line x1="12" y1="3" x2="12" y2="6"/>
        </svg>
      </button>
    </span>
      <a class="help" data-href="#find"></a>
      <div style="display: inline-block; margin-left: 10px; white-space: nowrap;">
      <span id="searchSpan" style="visibility: hidden; display: none;">
        <label><select id="searchCombo"></select></label>
        <span class="searchClass" id="searchMsg"></span>
        <label class="closebtn2" style="margin-top: 10px;" onclick="clearSearchResults()">&times;</label>
      </span>
      </div>
      <span class="errorClass" id="errorMsg"></span>
    </div>
  </div>

  <div class="ui-layout-center">
    <div id='map'></div>
    <div class="logo"></div>
    <div class="mapType">
      <div class="ui-widget" style="z-index: 10;">
        <label class="hamburgerSpace"><select id="mapModeSelect"></select></label>&nbsp;
        <span id="distance" onclick="removeDistance()">0 km</span>
      </div>
    </div>
    <div class="area1CBcopy">
      <label for="area1cbCopy">✈️</label><br><input type="checkbox" title="Ilmatilat" id="area1cbCopy"
                                                    name="area1cbCopy" value="area1cbCopy"/>
    </div>
  </div>
</div>

<div class="popup" id="settings" style="">
  <label class="closebtn" onclick="toggleDiv('settings'); adjustComponents()">&times;</label>
  <div class="popupIn">
    <h2>Asetukset</h2>
    <label><input type="checkbox" id="HStationary" value="HStationary"/>Pidä H paikallaan</label>
    <label><input type="checkbox" id="HCenter2" value="HCenter2"/>Pidä H keskellä <a class="help"
                                                                                     data-href="#othersettings"></a></label><br>
    <!-- <input type="checkbox" id="showAccuracy" value="showAccuray"  />Näytä tarkkuusympyrä<br> -->
    <label><input type="checkbox" id="readGPS" value="readGPS"/>Lue GPS:ää</label><br>
    <label><input type="checkbox" name="followMe" id="followMe" value="followMe"/>Piirrä oma jälki</label>
    <label><input type="text" name="editFollowMeColor" id="editFollowMeColor" value="orange" size="8"/></label>
    <label><input type="text" name="editFollowMeWidth" id="editFollowMeWidth" value="3" size="1"/> pt</label><br>
    <label><input type="checkbox" name="selectNewPin" id="selectNewPin" value="selectNewPin"/>Valitse uusi pin
      aktiiviseksi</label><br>
    <label><input type="checkbox" name="flipPins" id="flipPins" value="flipPins"
                  title="Kosketusnäytöllä parempi, vaikuttaa uusiin pinneihin."/>Käännä pinnit</label><br>
    <!-- <input type="checkbox" name="useDummyRect" id="useDummyRect" value="useDummyRect"  />Käytä tyhjää hakualuetta (jos ei osaa hakea)<br> -->
    <span id="preventSleepSpan"><label><input type="checkbox" name="preventSleep" id="preventSleep"
                                              value="preventSleep"/>Estä näytön sammuminen</label></span><br>
    <span id="spanUseCache"><label><input type="checkbox" name="useCache" id="useCache" value="useCache"/>Käytä paikallista muistia <a
      class="help" data-href="#usecache"></a></label></span><br>
    <label><input type="checkbox" id="drawDistanceLine" value="drawDistanceLine"/>Piirrä mittaviivaa</label>
    <label><input type="checkbox" id="calcDistanceSum" value="calcDistanceSum"/>Laske summaa <a class="help"
                                                                                                data-href="#addpins"></a></label><br>
    <label><input type="checkbox" id="showZoomButtons" value="showZoomButtons"/>Näytä Zoom-painikkeet (+/-)</label>
    <label><input type="checkbox" id="doubleClickZoom" value="doubleClickZoom"/>Tuplaklikkaus Zoom</label><br>
    <label for="showRotate">Kartan kierto:</label>
    <select id="showRotate" name="showRotate">
      <option value="none">Ei kiertoa</option>
      <option value="manual">Manuaalinen</option>
      <option value="gps">GPS suunnan mukaan</option>
      <option value="compass">Kompassin mukaan</option>
    </select>
    <br>
    <label for="showCompass">Kompassi:</label>
    <select id="showCompass" name="showCompass">
      <option value="none">Ei kompassia</option>
      <option value="gps">GPS suunnan mukaan</option>
      <option value="compass">Kompassin mukaan</option>
    </select>
    <br><br>


    <div class="ui-widget" id="followDiv">
      <div id="followArea">
        <button type="button" onclick="toggleDiv('followArea', false); toggleDiv('accountArea', true);">Tilaa
          käyttäjätunnus (ID)...
        </button>
        <a class="help" data-href="#userid"></a>
        <hr>
        <div id="accountArea2"><p><b>Oman paikan lähettäminen ja muiden seuraaminen:</b><a class="help"
                                                                                           data-href="#followsettings"></a>
        </p>
          <label for="editTag">Kartalla näkyvä tunnus: </label><input type="text" name="editTag" id="editTag" value=""
                                                                      size="5"/><br>
          <label for="editLog">logname: </label><input type="text" name="editLog" id="editLog" value="" size="12"/><br>
          <label for="editInterval">interval/ms: </label><input type="text" name="editInterval" id="editInterval"
                                                                value="5000" size="8"/><br>
          <label for="editUsersTofollow">Seurattavat käyttäjät: </label><input type="text" name="editUsersTofollow"
                                                                               id="editUsersTofollow" value=""
                                                                               size="15"/><br>
        </div>
        <br>
        <button type="button" onclick="getfollow(); toggleDiv('settings', false);">Hae muiden paikka</button>
        (jos automaatti ei ole päällä)<br>
        <br>
        <label><input type="checkbox" name="follow" id="follow" value="follow"/>Seuraa muita automaattisesti</label><br>
        <label><input type="checkbox" name="drawLogLine" id="drawLogLine" value="drawLogLine"/>Piirrä viivaa
          seurattavista</label><br>
        <label><input type="checkbox" id="send" value="send"/>Lähetä omaa paikkaa</label><br>
        <hr>
        <div id="compArea"><p><b>Mittareiden arvot</b> <a class="help" data-href="#gauges"></a></p>
          <label><input type="checkbox" name="useComps" id="useComps" value="useComps"/>Näytä mittarit</label><br>
          <div id="showCompsSettings">
            <label><input type="checkbox" id="useCompsWindow" value="useCompsWindow"/>Näytä ikkunassa</label><br>
            <span><br>Taustan väri: </span> <label><input type="text" id="editCompsBackground" value="rgba(0,0,0,1.0)"/></label><br>
            <span><br>Fontin väri: </span> <label><input type="text" id="editCompsColor" value="white"/></label><br>
            <span style="font-size: 10px">Ruksi mittarit joita haluat käyttää</span>
            <table id="tableCompsSettings">
            </table>
          </div>
        </div>
        <button class="close" onclick="toggleDiv('settings'); adjustComponents()">Sulje</button>
      </div>
      <div id="accountArea">
        <br>

        <label for="editEmail">Email: </label><input type="text" name="editEmail" id="editEmail" value="" size="25"/><a
        class="help" data-href="#userid"></a><br>
        <label for="editId">id: </label><input type="text" name="editId" id="editId" value="" size="15"/><br>
        <br>
        <button id="getId">Hae uusi ID</button>
        <a class="help" data-href="#userid"></a>
        <br>
        <br>
        <span class="idMsg" id="idMsg"></span>
        <br>
        <button type="button" onclick="toggleDiv('followArea', true); toggleDiv('accountArea', false);">Palaa
          seuranta-asetuksiin...
        </button>
      </div>
    </div>
  </div>
</div>

<div class="popup" id="about" style=" ">
  <label class="closebtn" onclick="toggleDiv('about')">&times;</label>
  <div class="popupIn">
    <p>Kartta versio: <span id="version-display">?</span>&nbsp;&nbsp;
      <button id="clear-worker" onclick="clearServiceWorker()">Tarkista uusi versio</button>
      <br>
    </p>
    <p id="memoryUsage">Muistin käyttö: ?</p>
    <h2>Pika-ohjeet</h2>

    <p>Dataa tähän karttaan voit lähettää <a href="https://trac.cc.jyu.fi/projects/dotnet/wiki/CycloLite">CycloLite</a>llä,
      <a href="https://play.google.com/store/apps/details?id=jyu.sendpos&hl=en_IE">SendPos Androidilla</a>
      tai <a href="s.html">Lähetys-sivulla</a>.</p>
    <p>
      Tunnukset voit tehdä <a href="javascript:void(0)"
                              onclick="toggleDiv('about'); toggleDiv('settings')">asetuksista</a> tai
      <a href="account.html">tilien hallinta</a>-sivulla.
    </p>
    <p>
      <a href="https://tim.jyu.fi/view/users/vesal/riippu/cyclo/kartta" target="blank">Ohjeet</a>.
    </p>
    <button class="close" onclick="toggleDiv('about')">Sulje</button>
  </div>
</div>

<div class="popup" id="loadAreas" style=" ">
  <label class="closebtn" onclick="toggleDiv('loadAreas')">&times;</label>
  <div class="popupIn">
    <h2>Alueet</h2>
    <p>Valitse mitä alueita haluat käyttää</p>
    <div id="loadAreasIn">
      <table>
        <tr>
          <th>Alue</th>
          <th>Oma väritys</th>
          <th>Optiot</th>
        </tr>
        <tr>
          <td><label><input type="checkbox" name="area1cb" id="area1cb" value="area1"/>Alue 1</label></td>
          <td><label><input type="checkbox" name="area1cbOwn" id="area1cbOwn" value="area1"/></label></td>
          <td><label><input type="text" name="area1cbOpt" id="area1cbOpt" value="c:gray/60,w:8,f:"/></label></td>
        </tr>
        <tr>
          <td><label><input type="checkbox" name="area2cb" id="area2cb" value="area2"/>Alue 1</label></td>
          <td><label><input type="checkbox" name="area2cbOwn" id="area2cbOwn" value="area2"/></label></td>
          <td><label><input type="text" name="area2cbOpt" id="area2cbOpt" value="c:red/60,w:8,f:red/30"/></label></td>
        </tr>
        <tr>
          <td><label><input type="checkbox" name="area3cb" id="area3cb" value="area3"/>Alue 1</label></td>
          <td><label><input type="checkbox" name="area3cbOwn" id="area3cbOwn" value="area3"/></label></td>
          <td><label><input type="text" name="area3cbOpt" id="area3cbOpt" value="c:red/80,w:8,f:red/30"/></label></td>
        </tr>
      </table>
      <br>
      <p>Tarkista kuitenkin alueiden korkeudet ja voimassaoloajat <a id="flykLink"
                                                                     href="https://flyk.com/map?lang=fi&pilot#p=7.11/60.837/27.172"
                                                                     target="flyk">FLYK-kartasta</a>!</p>
      <!--
      <p>Muut alueet: (kirjoita URL-osoiteet, joista saadaan ladattua alueiden JSONit)</p>
      <textarea  name="editRaport" id="editLoadAreas" class="loadAreasTextArea"  rows="10">
      </textarea>
      -->
    </div>
  </div>
</div>

<div id="openShowComps" style="bottom: 0.5em; left: 0; position: absolute; z-index:1011" onclick="showCompsDiv(true)">
  <span style="font-size: 30px;">></span>
</div>
<div id="showComps" class="showComps" style="bottom: 0; left: 0; position: absolute; z-index:1012">
</div>


<div style="bottom: 0; right: 0; position: absolute; z-index:1013; background-color: white;">
  <span class="coord" id="coord"></span>
  <a class="link" onclick="copyToUrl()">Laita&nbsp;URLiin</a>
</div>

<div class="routing-main-div" id="routingMainDiv" style="visibility: hidden">
  <!--<label class="closebtn" style="top: -13px;" onclick="showRoutePane();">&times;</label>-->
  <div class="popupIn">
    <div id='addressDiv'>
      <span class="instructions">Kirjoita osoitteet tai koordinaatit:
        <a class="link" onclick="copyRouteToUrl()">Laita&nbsp;URLiin</a>
      </span><br>
      <span class="inner">
      <button class="inner" type="button" title="Laita nykypiste lähtöpisteeksi"
              onclick='moveEditTo("editFrom")'>S</button>
        <!--<button class="inner" type="button" title="Laita oma paikka lähtöpisteeksi"
                onclick='moveITo("editFrom")'>I</button>-->
        <!-- <button class="inner" type="button" title="Etsi tämä paikka" onclick='searchFrom("editFrom")'>E</button> -->
      <label><input type="text" name="editFrom" id="editFrom" value=""/></label><br>
      </span>
      <span class="inner">
      =&gt;
      <button class="inner" type="button" title="Laita nykypiste loppupisteeksi"
              onclick='moveEditTo("editTo")'>S</button>
        <!-- <button class="inner" type="button" title="Etsi tämä paikka" onclick='searchFrom("editTo")'>E</button> -->
      <label><input type="text" name="editTo" id="editTo" value=""/></label><br>
      </span>
      <span class="inner">
        <span id="transportChoices">
          <span class="transport-choice" data-mode="car">🚗</span>
          <span class="transport-choice" data-mode="bike">🚲</span>
          <span class="transport-choice" data-mode="walk">🚶</span>
        </span>
        <button id="buttonOSRM" type="button" onclick="findDriving(0)"
                title="Etsi OSMR-reittittimellä (ei osaa muuta kuin auton)">Etsi&nbsp;reitti</button>
        <button id="buttonGraphHopper" type="button" onclick="findDriving(1)"
                title="Etsi GraphHopper-reitittimellä (antaa vain yhden)">G</button>
        <button id="buttonHERE" type="button" onclick="findDriving(2)" title="Etsi HERE-reitittimellä">H</button>
        <label><input type="checkbox" name="navigate" id="navigate" value="navigate" onclick="checkNavigate(this.checked)"/>Aja</label>
      </span>
    </div>
    <div class="driving">
      <div id="routeAlts">
      </div>
      <div id='itineraryDiv'></div>
    </div>
  </div>
</div>

<div class="popup" id="routingOptions" style=" ">
  <label class="closebtn" onclick="checkRouterButtons(); toggleDiv('routingOptions')">&times;</label>
  <div class="popupIn">
    <h2>Ajo-ohjeiden asetuksia</h2>
    <div class="flex-labels">
      <div><label for="instLeadTime">Kaunako ennen käännöstä luetaan ohje: </label><input type="text" size="3" id="instLeadTime" value="10"> s</div>
      <div><label for="polygonAckRadius">Millaisella säteellä reittiviivan pisteet kuitataan: </label><input type="text" size="3" id="polygonAckRadius" value="40"> m</div>
      <div><label for="routePointAckRadius">Millaisella säteellä ohjepisteet kuitataan: </label><input type="text" size="3" id="routePointAckRadius" value="15"> m</div>
    </div>
    <hr>
    <div class="flex-labels">
      <div><label for="speechRate">Puhenopeus: </label><input type="text" size="3" id="speechRate" value="120"> %</div>
      <div><label for="dialectSelect">Murre: </label><select id="dialectSelect"></select></div>
      <div><label for="exampleText">Malliteksti: </label><input type="text" size="30" id="exampleText" value=""></div>
    </div>
    <button onclick="exampleSpeech()">Puhu malliksi</button>
    <br>
    <button onclick="showRoutePane(1); closeNav()">Ajo-ohjeet malli</button>
    <hr>
    <h3>Eri reitityspalvelujen API-avaimia</h3>
    <p>Lisäämällä avaimia, saat käyttöön muitakin reitityspavelimia. Lue lisää ?</p>
    <div class="flex-labels">
      <div><label for="hereApiKey">HERE API-key: </label><input type="text" size="50" id="hereApiKey"></div>
      <div><label for="graphHopperApiKey">GraphHopper API-key: </label><input type="text" size="50"
                                                                              id="graphHopperApiKey"></div>
    </div>
    <hr>
    <div>
      <div><label for="simulateSpeed">Liikkumisen nopeus simuloinnissa: </label><input type="text" size="5" id="simulateSpeed" value="0"> m/s</div>
    </div>
  </div>
</div>

<div id="naviInfo" class="draggable noselect" style="background-color: white; position:absolute; padding: 5px; border: 1px solid black;
  min-width: 120px;top:10px;right:200px;width: unset; height: unset; z-index:1031; visibility: hidden">
  <div id="naviInfoText" style="background-color: white; ">
  </div>
  <div class="resize-handle"></div>
</div>

<div id="compass" class="draggable noselect" style="position:absolute;
  top:10px;right:10px;z-index:1030;
  width: 60px; height: auto;
  aspect-ratio: 1 / 1;
   ">
  <svg width="100%" height="100%" viewBox="0 0 80 80" preserveAspectRatio="xMidYMid meet">
    <!-- Outer circle -->
    <circle cx="40" cy="40" r="39" stroke="black" stroke-width="2" fill="white"/>
    <!-- Inner circle -->
    <circle cx="40" cy="40" r="36" stroke="#aaa" stroke-width="1" fill="#f8f8f8"/>
    <!-- Cardinal directions -->
    <text x="40" y="14" text-anchor="middle" font-size="14" font-weight="bold" fill="#333">N</text>
    <text x="40" y="75" text-anchor="middle" font-size="14" font-weight="bold" fill="#333">S</text>
    <text x="71" y="44" text-anchor="middle" font-size="14" font-weight="bold" fill="#333">E</text>
    <text x="11" y="44" text-anchor="middle" font-size="14" font-weight="bold" fill="#333">W</text>
    <!-- Needle group for rotation -->
    <g id="needle-group">
      <!-- Needle shadow -->
      <line x1="40" y1="40" x2="40" y2="20" stroke="#888" stroke-width="5" opacity="0.2"/>
      <!-- Needle (red) -->
      <line x1="40" y1="40" x2="40" y2="16" stroke="red" stroke-width="4" stroke-linecap="round"/>
      <!-- Needle tail (blue) -->
      <line x1="40" y1="40" x2="40" y2="64" stroke="blue" stroke-width="3" stroke-linecap="round"/>
      <!-- Center dot -->
      <circle cx="40" cy="40" r="5" fill="#333" stroke="white" stroke-width="2"/>
    </g>
  </svg>
  <div class="resize-handle"></div>
</div>

</body>
</html>
