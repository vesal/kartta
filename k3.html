<!DOCTYPE html>
<html lang="fi">
<head>
  <meta charset="UTF-8" />
  <title>Kartta 2</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <link rel="icon" href="data:,">
  <!-- Leaflet CSS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>

  <style>
    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
    }

    .errorClass {
      color:#ff0000;
      font-weight: bold;
    }

    #searchCombo {
      max-width: 250px;      /* Adjust as needed */
      width: 100%;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .popup {
      padding: 5%;
      position: absolute;
      z-index: 400;
      background-color: lightyellow;
      visibility: hidden;
      top: 30pt;
      left: 5%;
      /*width: calc(100% - 72px);
      height: calc(100% - 120px);*/
      right: 5%;
      bottom: 10pt;
      border-color: steelblue;
      border-radius: 20px;
      border-style: solid;
      max-width: 800px;
      /* overflow:auto; */
    }

    .popupIn {
      padding: 5%;
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      overflow:auto;
      border-radius: 20px;
    }

    .ui-menu li {
        margin: 0;
        cursor: pointer;
        list-style-image: url(data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7);
        position: relative;
        padding: 3px 2em 3px 0;
        font-family: Arial, Helvetica, sans-serif;
        font-size: 1em;
    }

    .ui-menu li:hover {
      background-color: #007bff;
      color: #fff;
    }
    .ui-menu li span {
      color: inherit; /* Ensure span inherits the hover color */
    }

    .ui-menu {
        background: #ffffff;
        /* width: 230px; */
        margin-left: 25px;
        /* margin-top: 40px; */
        margin-right: 20px;
        height: auto !important;
        display: block;
        list-style-type: none;
        margin-block-start: 1em;
        margin-block-end: 1em;
        padding-inline-start: 6px;
    }

    li a.help {
        padding: unset !important;
        display: inline !important;
        /* float: right; */
        position: absolute !important;
        right: 10px;
    }

    a.help {
        text-decoration: none !important;
    }


    #map {
      height: 100%;
      /* position: relative; */
      cursor: default;
      /* flex: 1 1 auto; */
      width: 100%;
      /* height: auto; */
      /*min-height: 100px; */
      overflow: hidden; /* Prevent scrolling */
    }
    #mapModeSelect {
      /* position: absolute;
      top: 0px;
      left: 35px;

       */
      z-index: 1000;
      background: white;
      padding: 0;
      border-radius: 3px;
      /* box-shadow: 0 0 5px rgba(0,0,0,0.3); */
      font-family: Arial, Helvetica, sans-serif;
      font-size: 1.0em;
    }
    #distance {
      background-color: white;
      align-self: baseline;
    }

    #editPinLoc {
      width: 250px; /* desktop default */
    }

    @media (max-width: 600px) {
      #editPinLoc {
        width: 180px; /* smaller for mobile */
      }
    }

    .closebtn {
        z-index: 1000;
        position: absolute;
        top: 0;
        width: 20px;
        right: 5px;
        font-size: 36px;
        /*margin-left: 50px; */
    }

    .layout-container {
      display: flex;
      flex-direction: column;
      height: 100dvh;
    }

    .ui-layout-north {
      z-index: 2000;
      height: 22px;
      position: relative;
      background: #f8f9fa;
      border-bottom: 1px solid #dee2e6;
      flex-shrink: 0;
    }

    .ui-layout-center {
      flex: 1 1 auto;
      position: relative;
      display: flex;
      flex-direction: column;
      overflow: hidden; /* Prevent scrolling */

    }

    .ui-widget {
      display: flex;
      /* align-items: center; */
      gap: 5px; /* optional spacing */
    }

    .mapType {
      position: absolute;
      top: 0;
      left: 0;
      z-index: 1100;
      background: rgba(255,255,255,0.9);
      padding: 0;
      border-radius: 0;
      /* width: 100%; */
    }

    .hamburgerSpace {
      margin-left: 35px;
    }

    .area1CBcopy {
      align-items: center;
      position: absolute;
      top: 0;
      right: 0;
      z-index: 3000;
    }
  </style>
</head>
<body>

<!-- Pick next files to your js-directory -->
<!-- Leaflet JS -->
<!-- <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script> -->
<!-- <script src="https://unpkg.com/leaflet-textpath/leaflet.textpath.js"></script>-->

<script src="js/leaflet.js"></script>
<script src="js/leaflet.textpath.js"></script>
<script>

function sanitizeInput(input, type = "html") {
  if (typeof input !== "string") return "";

  switch (type) {
    case "html": // Näytetään HTML:ssä tekstinä
      return input
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#039;");

    case "attr": // HTML-attribuuteissa
      return input
        .replace(/&/g, "&amp;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#039;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;");

    case "url": // URL-parametreissa
      return encodeURIComponent(input);

    case "alnum": // Vain kirjaimet ja numerot
      return input.replace(/[^a-z0-9]/gi, '');

    default:
      return input;
  }
}


const helpServerUrl = "https://tim.jyu.fi/view/users/vesal/riippu/cyclo/kartta";
function prefixHelpLinks() {
    document.querySelectorAll('a.help').forEach(link => {
        link.target = "help";
        link.innerText = " ?";
        const hash = link.getAttribute('data-href');
        if (hash && hash.startsWith('#')) {
            link.setAttribute('href',  helpServerUrl + hash);
        }
    });
}


 class MapWrapper {
  /**
   * @typedef {Object} Polyline
   * @property {function(string, Object=): any} setText
   */
   // Luo layer-muuttuja, johon asetetaan nykyinen karttalaatta


    constructor(containerId, mapmodes) {
      // noinspection TypeScriptUMDGlobal
      this.L = L;
      this.currentLayer = null;
      this.mapModes = mapmodes;
      // this.mapMode = mapModes["OpenStreet"];
      this.mapMode = this.mapModes["b-bark SuomiTopo"];
      this.map = this.L.map('map', { zoomControl: false }).setView([60.1699, 24.9384], 13);
      this.pins = [];
      // L.control.zoom({ position: 'topright' }).addTo(map);
    }


   setView(coord, zoom=null) {
     if (zoom === null) {
       zoom = this.map.getZoom();
     }
     if (Array.isArray(coord)) {
       coord = this.L.latLng(coord[0], coord[1]);
     }
     this.map.setView(coord, zoom);
   }

   addLayer(layer) {
     this.map.addLayer(layer);
   }

   removeLayer(layer) {
     this.map.removeLayer(layer);
   }


  // noinspection TypeScriptUMDGlobal
  static CustomTileLayer = class extends L.GridLayer {
    constructor(options, outer) {
      super(options);
      this.outer = outer;
    }

    // noinspection JSUnusedGlobalSymbols
    createTile(coords, done) {
      const tile = document.createElement('img');
      tile.alt = '';
      tile.setAttribute('role', 'presentation');

      // Käytetään sun omaa URL-funktiota
      const tileInfo = {
        zoom: coords.z,
        x: coords.x,
        y: coords.y
      };
      tile.src = this.outer.mapMode.f(tileInfo);

      // Kun kuva latautuu tai epäonnistuu, kerrotaan Leafletille
      tile.onload = () => done(null, tile);
      tile.onerror = () => done(new Error('Tile load error'), tile);

      return tile;
    }

  }; // CustomTileLayer ends


  // Aluksi luodaan ja lisätään ensimmäinen layer
  setMapMode(modeKey) {
    this.mapMode = this.mapModes[modeKey];
    if (this.currentLayer) {
      this.removeLayer(this.currentLayer);
    }
    if (typeof this.mapMode.i !== 'undefined') {
         this.mapMode.i();
    }
    // Ota oma karttataso käyttöön
    this.currentLayer = new MapWrapper.CustomTileLayer({ attribution: this.mapMode.c }, this);
    this.addLayer(this.currentLayer);

    // Päivitä attribution-kenttä Leafletin oikeaan alakulmaan
    this.map.attributionControl.setPrefix(false);
    // map.attributionControl.setAttribution(mapMode.c);
  }

  customPin(label = 'I', color = 'green', baseColor = 'black') {
    let tsize = "16";
    if (label.length > 3) { tsize = "12"; }
    if (label.length >= 5) { tsize = "10"; }
    const svg = `
      <svg width="32" height="48" viewBox="0 0 32 48" xmlns="http://www.w3.org/2000/svg">
        <!-- Kolmion muotoinen jalka -->
        <path d="M 3 16 L 16 48 L 29 16 Z" fill="${baseColor}" />
        <!-- Eri värinen valinta-alue -->
        <path id="pin-foot" d="M 4 15 L 16 47 L 28 15 Z" fill="red" style="visibility:hidden;" />
        <!-- Iso musta ympyrä -->
        <circle cx="16" cy="16" r="16" fill="${baseColor}" />
        <!-- Sisempi värillinen ympyrä -->
        <circle cx="16" cy="16" r="14" fill="${color}" />
        <!-- Valkoinen teksti keskellä -->
        <text x="16" y="16" text-anchor="middle" font-family="Arial" font-weight="bold" font-size="${tsize}" fill="white" dominant-baseline="middle">
          ${label}
        </text>
      </svg>
    `;

    return this.L.divIcon({
      className: '',
      html: svg,
      iconSize: [32, 48],
      iconAnchor: [16, 48], // kärki osoittaa koordinaattiin
      popupAnchor: [0, -48]
    });
  }  // customPin ends

  selectPin(pin, selected) {
    const element = pin.getElement();
    if (!element) {
      return;
    }
    const svg = element.querySelector('svg');
    const foot = svg.querySelector('#pin-foot');
    if (foot) {
      foot.style.visibility = selected ? 'visible' : 'hidden';
    }
  }

  createPin(coord, label, color, click, text = null) {
    const pin = this.L.marker(coord, {icon: this.customPin(label, color)});
    pin.addTo(this.map);
    if (text) {
      pin.bindPopup(text);
    }
    pin.on('click', function() {
      click(pin);
    });
    return pin;
  }

  removePin(pin) {
    this.map.removeLayer(pin);
    const index = this.pins.indexOf(pin);
    if (index > -1) {
      this.pins.splice(index, 1);
    }
  }

  getPinLocation(pin=null) {
    if (!pin || !pin.getLatLng) {
      const center = this.map.getCenter();
      return [center.lat, center.lng];
    }
    const latLng = pin.getLatLng();
    return [latLng.lat, latLng.lng];
  }

  setPinDragging(pin, enable) {
    if (enable) {
      pin.dragging.enable();
    } else {
      pin.dragging.disable();
    }
  }

  on(event, callback) {
    this.map.on(event, callback);
  }

  setPinOn(pin, eventName, callback) {
    pin.on(eventName, callback);
  }

  addLines(lines, from, to, options = {}, text = null) {
    if (!lines) {
      lines = [];
    }
    const lineOptions = {
      color: options.color || 'blue',
      weight: options.weight || 2,
      opacity: options.opacity || 0.6
    };
    let line;
    // if (!line) {
      line = this.L.polyline([from, to], lineOptions);
      line.from = from;
      line.to = to;
      this.map.addLayer(line);
    // } else {
    //  line.setLatLngs([from, to]);
    //  if (options) line.setStyle(lineOptions);
    // }
    line.setText("", {});
    if (text) {
      let flip = 'normal';
      let offset = -3;
      if (to[1] < from[1]) {
         flip = 'flip';
         offset = 12;
      }
      const opts = {repeat: false, center: true, offset: offset}
      if (flip === 'flip') opts.orientation = 'flip';
      line.setText(text, opts);
    }
    lines.push(line);
    return lines;
  }

  removeLines(lines, idx1 = 0, idx2 = 10000) {
    if (!lines || lines.length === 0) return;
    if (idx1 >= lines.length) return;
    if (idx1 < 0) idx1 = lines.length + idx1;
    if (idx2 < 0) idx2 = lines.length + idx2;
    if (idx1 >= lines.length) return;
    if (idx2 < 0) return;
    if (idx1 < 0) idx1 = 0;
    if (idx2 >= lines.length) idx2 = lines.length - 1;
    for (let i = idx1; i <= idx2; i++) {
      this.map.removeLayer(lines[i]);
    }
    lines.splice(idx1, idx2 - idx1 + 1); // poista vastaavat taulukosta
  }


 } // MapWrapper ends



 // Simulation of C# string.Format, only {n} works.
 if (!String.format) {
  String.format = function(format) {
    const args = Array.prototype.slice.call(arguments, 1);
    return format.replace(/{(\d+)}/g, function(match, number) {
      return typeof args[number] != 'undefined'
        ? args[number]
        : match
      ;
    });
  };
}

// Converts tile XY coordinates into a QuadKey at a specified level of detail.
function TileXYToQuadKey(tile) {
  let quadKey = "";
  for (let i = tile.zoom; i > 0; i--)  {
    let digit = '0';
    const mask = 1 << (i - 1);
    if ((tile.x & mask) !== 0) {
            digit++;
    }
    if ((tile.y & mask) !== 0) {
        digit++;
        digit++;
    }
    quadKey += digit;
  }
  return quadKey;
}


const belectro = {
  link: "https://tanger.belectro.fi/tiles/mmltopo/v9/256/{0}/{2}/{1}?ref=7f2d",
  ok: false,
  init: async function () {
    if (this.ok) return;
    this.ok = true;
    const response = await fetch("https://www.mit.jyu.fi/demowww/cyclo/bbark.php");
    const data = await response.text();
    const bbarkObj = JSON.parse(data);
    // noinspection JSUnresolvedReference
    let url = bbarkObj.base_map_groups[0].maps[0].url;
    url = url.replace("{W}", "256");
    url = url.replace("{Z}", "{0}");
    url = url.replace("{Y}", "{2}");
    url = url.replace("{X}", "{1}");
    belectro.link = url;
  }
};

 // noinspection CheckImageSize
const mapModes = {
  "Bing Maps normal"   : { f:function(tile) {
	                            return String.format("https://ecn.t1.tiles.virtualearth.net/tiles/r{0}?g=1135",TileXYToQuadKey(tile));
							}, c:""},
	"Bing Maps aerial"   : { f:function(tile) {
	                            return String.format("https://ecn.t1.tiles.virtualearth.net/tiles/h{0}?g=1135",TileXYToQuadKey(tile));
							}, c:""},
	"Google street"      : { f:function(tile) { return String.format("https://mt1.google.com/vt/lyrs=m&z={0}&x={1}&y={2}",tile.zoom ,tile.x, tile.y ); },
	                         c:'(c) <a href="https://maps.google.com/help/terms_maps.html" target="_blank">Google Maps</a>'},
	"Google satellite"   : { f:function(tile) { return String.format("https://mt1.google.com/vt/lyrs=y&z={0}&x={1}&y={2}",tile.zoom ,tile.x, tile.y ); },
	                         c:'(c) <a href="https://maps.google.com/help/terms_maps.html" target="_blank">Google Maps</a>'},
//  "Google Street"      : { f:function(tile) { tile = nokiaConvert(tile); return String.format("https://maps.googleapis.com/maps/api/staticmap?center={1},{2}&zoom={0}&size=256x256&key=AIzaSyCpXjAoV19MUbpGd6e6YD9IketR2Gu-tqc",tile.zoom ,tile.x, tile.y); }, c:""},
//  "Google satellite"   : { f:function(tile) { tile = nokiaConvert(tile); return String.format("https://maps.googleapis.com/maps/api/staticmap?center={1},{2}&zoom={0}&size=256x256&key=AIzaSyCpXjAoV19MUbpGd6e6YD9IketR2Gu-tqc&maptype=hybrid",tile.zoom ,tile.x, tile.y); }, c:""},
//    "Nokia"              : { f:function(tile) { tile = nokiaConvert(tile); return String.format("http://m.nok.it/?app_id=_peU-uCkp-j8ovkzFGNU&app_code=gBoUkAMoxoqIWfxWA5DuMQ&h=256&w=256&ctr={1},{2}&z={0}&t=0&nord",tile.zoom ,tile.x, tile.y); }, c:""},
//	"MapQuest"           : { f:function(tile) { return String.format("http://otile1.mqcdn.com/tiles/1.0.0/map/{0}/{1}/{2}.png",Clip(tile.zoom,0,19) ,tile.x, tile.y); },
//	                         c:'(c) <a href="http://info.mapquest.com/terms-of-use/" target="_blank">MapQuest</a>'},
	"OpenStreet"         : { f:function(tile) { return String.format("https://tile.openstreetmap.org/{0}/{1}/{2}.png",tile.zoom,tile.x,tile.y); },
	                         c:'(c) <a href="https://www.openstreetmap.org/copyright" target="_blank">OpenStreetMap</a>'},
	"OpenCycle"          : //{ f:function(tile) { return String.format("http://a.tile.opencyclemap.org/cycle/{0}/{1}/{2}.png",tile.zoom ,tile.x, tile.y ); },
	                         { f:function(tile) { return String.format("https://tile.thunderforest.com/cycle/{0}/{1}/{2}.png?apikey=4e1589f40d3049469a043e2ec917dc88",tile.zoom ,tile.x, tile.y ); },
	                         c:'(c) <a href="https://www.opencyclemap.org/docs/" target="_blank">OpenCycleMap</a>'},
	"Landscape"          : { f:function(tile) { return String.format("https://tile.thunderforest.com/landscape/{0}/{1}/{2}.png?apikey=4e1589f40d3049469a043e2ec917dc88",tile.zoom ,tile.x, tile.y ); },
	                         c:'(c) <a href="https://www.opencyclemap.org/docs/" target="_blank">OpenCycleMap</a>'},
	"Transport"          : { f:function(tile) { return String.format("https://tile.thunderforest.com/transport/{0}/{1}/{2}.png?apikey=4e1589f40d3049469a043e2ec917dc88",tile.zoom ,tile.x, tile.y ); },
	                         c:'(c) <a href="https://www.opencyclemap.org/docs/" target="_blank">OpenCycleMap</a>'},
	"Outdoors"           : { f:function(tile) { return String.format("https://tile.thunderforest.com/outdoors/{0}/{1}/{2}.png?apikey=4e1589f40d3049469a043e2ec917dc88",tile.zoom ,tile.x, tile.y ); },
	                         c:'(c) <a href="https://www.opencyclemap.org/docs/" target="_blank">OpenCycleMap</a>'},
	/* Ei voi käyttää, koska ei ole enää saatavilla WGS84, vaan vain EPSG:3067
  "Kapsi peruskartta"  : { f:function(tile) { return getKapsiTilePath(tile); },
	                         c:'(c) <a href="http://www.maanmittauslaitos.fi/avoindata_lisenssi_versio1_20120501" target="_blank">Maanmittauslaitos</a>'},
	"Kapsi Tausta"       : { f:function(tile) { return String.format("http://tiles.kartat.kapsi.fi/taustakartta_3067/{0}/{1}/{2}.jpg",tile.zoom ,tile.x, tile.y); },
	                         c:'(c) <a href="http://www.maanmittauslaitos.fi/avoindata_lisenssi_versio1_20120501" target="_blank">Maanmittauslaitos</a>'},
	"Kapsi Ilma"         : { f:function(tile) { return String.format("http://tiles.kartat.kapsi.fi/ortokuva_3067/{0}/{1}/{2}.jpg",tile.zoom ,tile.x, tile.y); },
	                         c:'(c) <a href="http://www.maanmittauslaitos.fi/avoindata_lisenssi_versio1_20120501" target="_blank">Maanmittauslaitos</a>'

                             },
https://avoin-karttakuva.maanmittauslaitos.fi/avoin/wmts/1.0.0/taustakartta/default/WGS84_Pseudo-Mercator/18/72651/149809.png?api-key=
https://avoin-karttakuva.maanmittauslaitos.fi/avoin/wmts/1.0.0/ortokuva/default/WGS84_Pseudo-Mercator/12/1116/2297.png?api-key=
	 */
  "MML maasto"         : {   f:function(tile) { return String.format("https://avoin-karttakuva.maanmittauslaitos.fi/avoin/wmts/1.0.0/maastokartta/default/WGS84_Pseudo-Mercator/{0}/{2}/{1}.png?api-key=4c0b6a7d-aa24-4b2c-913c-66d3823d7445",tile.zoom ,tile.x, tile.y); },
	                         c:'(c) <a href="https://www.maanmittauslaitos.fi/avoindata_lisenssi_versio1_20120501" target="_blank">Maanmittauslaitos</a>'},
  "MML tausta"         : {   f:function(tile) { return String.format("https://avoin-karttakuva.maanmittauslaitos.fi/avoin/wmts/1.0.0/taustakartta/default/WGS84_Pseudo-Mercator/{0}/{2}/{1}.png?api-key=4c0b6a7d-aa24-4b2c-913c-66d3823d7445",tile.zoom ,tile.x, tile.y); },
	                         c:'(c) <a href="https://www.maanmittauslaitos.fi/avoindata_lisenssi_versio1_20120501" target="_blank">Maanmittauslaitos</a>'},
  "MML selko"         : {   f:function(tile) { return String.format("https://avoin-karttakuva.maanmittauslaitos.fi/avoin/wmts/1.0.0/selkokartta/default/WGS84_Pseudo-Mercator/{0}/{2}/{1}.png?api-key=4c0b6a7d-aa24-4b2c-913c-66d3823d7445",tile.zoom ,tile.x, tile.y); },
	                         c:'(c) <a href="https://www.maanmittauslaitos.fi/avoindata_lisenssi_versio1_20120501" target="_blank">Maanmittauslaitos</a>'},
  "MML ilma"           : {   f:function(tile) { return String.format("https://avoin-karttakuva.maanmittauslaitos.fi/avoin/wmts/1.0.0/ortokuva/default/WGS84_Pseudo-Mercator/{0}/{2}/{1}.png?api-key=4c0b6a7d-aa24-4b2c-913c-66d3823d7445",tile.zoom ,tile.x, tile.y); },
	                         c:'(c) <a href="https://www.maanmittauslaitos.fi/avoindata_lisenssi_versio1_20120501" target="_blank">Maanmittauslaitos</a>'},
	"b-bark SuomiTopo"   : { f:function(tile) {
                            return String.format(belectro.link, tile.zoom, tile.x, tile.y);
						               },
	                         c:'<span>Render:</span> <a href="https://www.b-bark.com" target="_blank"><img style="vertical-align:middle" src="css/b_bark_logo.png" width="10%" height="10%"  alt=""/></a> (c) <a href="https://www.maanmittauslaitos.fi/avoindata_lisenssi_versio1_20120501" target="_blank">Maanmittauslaitos</a>',
                             i: belectro.init },
  "World Topo Map":      {f: function(tile) {
                            return String.format("https://services.arcgisonline.com/ArcGIS/rest/services/World_Topo_Map/MapServer/tile/{0}/{2}/{1}", tile.zoom, tile.x, tile.y);
                          },
                          c: '(c) <a href="https://www.esri.com/" target="_blank">Esri</a>'
                          },
  "World Imagery"      : { f:function(tile) { return String.format("https://services.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{0}/{2}/{1}",tile.zoom ,tile.x, tile.y);},
	                         c:'(c) <a href="https://www.esri.com/en-us/home" target="_blank">ArgGIS</a>'},
	"Ilmailu merged"      : { f:function(tile) {
                              const airac = "1806";
                              return String.format('https://snapshots.openflightmaps.org/live/' + airac + '/tiles/world/noninteractive/epsg3857/merged/256/latest/{0}/{1}/{2}.png', tile.zoom, tile.x, tile.y);
                              },
	                         c:'(c) <a href="https://openflightmaps.org/live/ef-finland/" target="_blank">openflightmaps.org</a>'},
	"Ilmailu aero"      : { f:function(tile) {
	                             const airac = "1806";
	                             return String.format('https://snapshots.openflightmaps.org/live/' + airac + '/tiles/world/noninteractive/epsg3857/aero/256/latest/{0}/{1}/{2}.png',tile.zoom ,tile.x, tile.y);
	                             },
	                         c:'(c) <a href="https://openflightmaps.org/live/ef-finland/" target="_blank">openflightmaps.org</a>'},
/*
	"Ilmailu base"      : { f:function(tile) {
	                             var airac = "1806";
	                             var url = String.format('https://snapshots.openflightmaps.org/live/' + airac + '/tiles/world/noninteractive/epsg3857/base/256/latest/{0}/{1}/{2}.png',tile.zoom ,tile.x, tile.y);
	                             return url},
	                         c:'(c) <a href="https://openflightmaps.org/live/ef-finland/" target="_blank">openflightmaps.org</a>'},
*/
};

function Ellipsoid(name, a, invf) {
  /* constructor */
  this.name=name
  this.a=a
  this.invf=invf
}

const ells = [
  new Ellipsoid("WGS84", 6378.137 / 1.852, 298.257223563),
  new Ellipsoid("FAI sphere", 6371.0 / 1.852, 1000000000.)
];


function getEllipsoid(selection){
//  document.spheroid.major_radius.value=ells[selection.selectedIndex+1].a*1.852
//  document.spheroid.inverse_f.value=ells[selection.selectedIndex+1].invf
  return ells[selection.selectedIndex];
}

function atan2(y,x) {
  let out;
  if (x <0)            { out= Math.atan(y/x)+Math.PI;}
  if ((x >0) && (y>=0)){ out= Math.atan(y/x);}
  if ((x >0) && (y<0)) { out= Math.atan(y/x)+2*Math.PI;}
  if ((x===0) && (y>0)) { out= Math.PI/2;}
  if ((x===0) && (y<0)) { out= 3*Math.PI/2;}
  if ((x===0) && (y===0)) {
  //alert("atan2(0,0) undefined")
      out= 0.
  }
  return out
}

function bearingDegrees(from, to) {
  // from and to: [lat, lon]
  const toRad = deg => deg * Math.PI / 180;
  const toDeg = rad => rad * 180 / Math.PI;

  const lat1 = toRad(from[0]);
  const lat2 = toRad(to[0]);
  const dLon = toRad(to[1] - from[1]);

  const y = Math.sin(dLon) * Math.cos(lat2);
  const x = Math.cos(lat1) * Math.sin(lat2) -
            Math.sin(lat1) * Math.cos(lat2) * Math.cos(dLon);
  let brng = Math.atan2(y, x);
  brng = toDeg(brng);
  return (brng + 360) % 360; // Normalize to 0–360
}

function WGS84_distance(p1,p2) {
  if (Array.isArray(p1) && p1.length === 2) {
    p1 = { latitude: p1[0], longitude: p1[1] };
  }
  if (Array.isArray(p2) && p2.length === 2) {
    p2 = { latitude: p2[0], longitude: p2[1] };
  }
  const selection = {selectedIndex: 0};
  const m = Math.PI / 180;
  return crsdist_ell(p1.latitude*m,p1.longitude*m,p2.latitude*m,p2.longitude*m,getEllipsoid(selection));
}

function crsdist_ell(glat1,glon1,glat2,glon2,ellipse){
  // glat1 initial geodetic latitude in radians N positive
  // glon1 initial geodetic longitude in radians E positive
  // glat2 final geodetic latitude in radians N positive
  // glon2 final geodetic longitude in radians E positive
  const a = ellipse.a
  const f = 1/ellipse.invf
  //alert("a="+a+" f="+f)
  let r, tu1, tu2, cu1, su1, cu2, s1, b1, f1;
  let x, sx, cx, sy, cy, y, sa, c2a, cz, e, c, d;
  const EPS = 0.00000000005;
  let s;
  let iter = 1;
  const MAXITER = 100;
  if ((glat1+glat2===0.) && (Math.abs(glon1-glon2)===Math.PI)){
    alert("Course and distance between antipodal points is undefined")
    glat1=glat1+0.00001 // allow algorithm to complete
    }
  if ( glat1===glat2 && (glon1===glon2 || Math.abs(Math.abs(glon1-glon2)-2*Math.PI) <  EPS) ) {
    //alert("Points 1 and 2 are identical- course undefined")
    return 0.0; // don't care???
  }
  r = 1 - f
  tu1 = r * Math.tan (glat1)
  tu2 = r * Math.tan (glat2)
  cu1 = 1. / Math.sqrt (1. + tu1 * tu1)
  su1 = cu1 * tu1
  cu2 = 1. / Math.sqrt (1. + tu2 * tu2)
  s1 = cu1 * cu2
  b1 = s1 * tu2
  f1 = b1 * tu1
  x = glon2 - glon1
  d = x + 1 // force one pass
  while ((Math.abs(d - x) > EPS) && (iter < MAXITER))
    {
      iter=iter+1
      sx = Math.sin (x)
//       alert("sx="+sx)
      cx = Math.cos (x)
      tu1 = cu2 * sx
      tu2 = b1 - su1 * cu2 * cx
      sy = Math.sqrt(tu1 * tu1 + tu2 * tu2)
      cy = s1 * cx + f1
      y = atan2 (sy, cy)
      sa = s1 * sx / sy
      c2a = 1 - sa * sa
      cz = f1 + f1
      if (c2a > 0.)
     cz = cy - cz / c2a
      e = cz * cz * 2. - 1.
      c = ((-3. * c2a + 4.) * f + 4.) * c2a * f / 16.
      d = x
      x = ((e * cy * c + cz) * sy * c + y) * sa
      x = (1. - c) * x * f + glon2 - glon1
    }
  x = Math.sqrt ((1 / (r * r) - 1) * c2a + 1)
  x +=1
  x = (x - 2.) / x
  c = 1. - x
  c = (x * x / 4. + 1.) / c
  d = (0.375 * x * x - 1.) * x
  x = e * cy
  s = ((((sy*sy*4.-3.)*(1.-e-e)*cz*d/6.-x)*d/4.+cz)*sy*d+y)*c*a*r

  return s*1.852;
  /*
  let faz, baz;
  faz = modcrs(atan2(tu1, tu2))
  baz = modcrs(atan2(cu1 * sx, b1 * cx - su1 * cu2) + Math.PI)
  out=new MakeArray(0)
  out.d=s
  out.crs12=faz
  out.crs21=baz
  if (Math.abs(iter-MAXITER)<EPS){
    alert("Algorithm did not converge")
  }
  return out
  */
} // crsdist_ell ends

// Globals:
let lastSelected = null;
let myPin = null;
let hitPin = null;
let mapWrapper = null;
let pinNr = 1;
let dst = null;
let lastHitPoint = null;
let searchPins = [];

const options = {
  email: "",
  id: "",
  logname: "",
  interval: "5000",
  usersTofollow: "",
  send: false,
  readGPS: true,
  resend: false,
  follow: false,
  followMe: false,
  showTime: true,
  selectNewPin: true,
  useDummyRect: false,
  preventSleep: true,
  smallRaport: false,
  drawLogLine: false,
  HCenter: true,
  showAccuracy: true,
  extra: false,
  tpR: "0",
  hasWakeLock: false,
  useComps: false,
  useCompsWindow: false,
};

function isCoordinate(s) {
     if ( s === "" ) return false;
     return "0123456789-".indexOf(s[0]) >= 0;
}

function geocodeQuery(query) {

  const select = document.getElementById('searchCombo');
  select.innerText = "";
  toggleDiv("searchSpan", true);

  if (isCoordinate(query)) {
    const loc = getCoordinateFromText(query);
    const pin = addPinAt(loc)
    searchPins.push(pin);
    // map.entities.push([pin]);
    // map.setView({center: loc});
    return;
  }
  fetch(`https://nominatim.openstreetmap.org/search?q=${query}&format=json`)
    .then(response => response.json())
    .then(data => {
      const opt0 = document.createElement('option');
      opt0.value = "0";
      let text = "Ei löytynyt";
      if (data.length === 1) {
        text = "Löytyi 1 kohde: ";
      }
      if (data.length > 1) {
        text = "Löytyi " + data.length + " kohdetta: ";
      }
      opt0.text = text;
      select.appendChild(opt0);

      if (data.length > 0) {
        // console.log('Löytyi useita tuloksia:', data.length);
        data.forEach((item, i) => {
          // console.log(`${i + 1}: ${item.display_name} — lat: ${item.lat}, lon: ${item.lon}`);
          // noinspection JSUnresolvedReference
          const pin = createPin([item.lat,item.lon], `s${i+1}`, 'violet', item.display_name);
          searchPins.push(pin)
          // noinspection JSUnresolvedReference
          const opt = (i + 1) + ') ' + item.display_name;
          const option = document.createElement('option');
          option.value = "" + (i + 1);
          option.text = opt;
          select.appendChild(option);
        });
      }
    })
    .catch(err => console.error('Virhe:', err));
}

function clearSearchResults() {
    if (searchPins.length > 0) {
        searchPins.forEach(pin => {
            if (pin === lastSelected) lastSelected = null;
            mapWrapper.removePin(pin);
        });
        searchPins = [];
    }
    toggleDiv('searchSpan', false)
}

function search() {
    //Remove any previous results from the map.
    clearSearchResults();
    //Get the users query and geocode it.
    const query = getPinText();
    geocodeQuery(query);
}

function getCoordinateFromText(s) {
  // Etsitään koordinaatit tekstistä
  const latLongArray = s.split(/[\s,]+/);
  if (latLongArray.length < 2) return null;
  const lat = parseFloat(latLongArray[0]);
  const lng = parseFloat(latLongArray[1]);
  if (isNaN(lat) || isNaN(lng)) return null;
  return [lat, lng];
}

let distanceLines = null;

function calcDistance(idx1 = -1000, idx2 = -1000) {
  let d = 0;
  let sum = 0;
  if ( !hitPin ) return;
  let from = null;
  if (idx1 === -1) {
    if (distanceLines.length >= 1) {
        lastHitPoint = distanceLines[distanceLines.length - 1].from;
    }
  }
  const to = mapWrapper.getPinLocation(hitPin);
  if ( !lastSelected ) {
    if (!lastHitPoint) return;
    from = lastHitPoint;
  } else {
    d = WGS84_distance(mapWrapper.getPinLocation(lastSelected), mapWrapper.getPinLocation(hitPin));
    from = mapWrapper.getPinLocation(lastSelected);
    mapWrapper.removeLines(distanceLines);
  }
  d = WGS84_distance(from, to);
  const deg = bearingDegrees(from, to);
  const s  = `${d.toFixed(3)} km, ${deg.toFixed(1)}°`;
  if (idx1 >= -1) mapWrapper.removeLines(distanceLines, idx1, idx2);
  distanceLines = mapWrapper.addLines(distanceLines, from, to, {
    color: 'red',
    weight: 1,
    opacity: 0.8
  }, s);
  const line = distanceLines[distanceLines.length - 1];
  line.d = d;
  line.deg = deg;
  for (let i = 0; i < distanceLines.length; i++) {
    if (distanceLines[i].d) sum += distanceLines[i].d;
  }
  if (!dst) dst = document.getElementById("distance");
  if (sum !== d) dst.innerText = s + ` = ${sum.toFixed(3)} km`;
  else dst.innerText = s;
}


function selectActivePin(pin, calcDist) {
  changeSelected(pin, true);
  mapWrapper.selectPin(pin, true);
  if ( calcDist ) calcDistance();
}

function addPinAt(pinLoc) {
  let center = mapWrapper.getPinLocation(hitPin);
  let name = "" + pinNr;
  if ( pinLoc !== "" ) {
    const latLongArray = (pinLoc).split(/[\s,]+/);
    center = getCoordinateFromText(pinLoc);
    name = latLongArray[2];
    if ( name === undefined || name === "H" || name === "" ) name = ""+pinNr++;
  }
  else pinNr++;

  return createPin(center, name, 'blue');
}


function addPin() {
   const s = getPinText();
   if ( s !== "" && !isCoordinate(s) ) return search();
   const pin = addPinAt(s);
   mapWrapper.setPinDragging(pin, true);
   if (options.selectNewPin) {
     selectActivePin(pin, true);
     // const loc = new Microsoft.Maps.Location(pin.geometry.y, pin.geometry.x);
     // map.setView({center:loc});
   }
}


function checkAddPinText() {
   let text = "Lisää pinni";
   const s = getPinText()
   if ( s !== "" && !isCoordinate(s) ) text = "Etsi";
   document.getElementById('buttonAddPin').innerText = text;
}

 function getPinText() {
    let s = sanitizeInput(document.getElementById('editPinLoc').value.trim());
    return s;
}

function setPinText(s) {
    document.getElementById('editPinLoc').value = s.trim();
    checkAddPinText();
}

function setHitPinLoc(loc) {
  hitPin.setLatLng(loc);
  calcDistance();
}


function initializeMapPage() {
  mapWrapper = new MapWrapper('map', mapModes);
  // Täytetään select-valikko
  const mapSelect = document.getElementById('mapModeSelect');
  for (const key in mapModes) {
    const option = document.createElement('option');
    option.value = key;
    option.textContent = key;
    mapSelect.appendChild(option);
  }

  // Alustetaan valinta ja kartta
  mapSelect.value = "OpenStreet";
  mapWrapper.setMapMode(mapSelect.value);

  // Kuunnellaan valikon muutosta
  mapSelect.addEventListener('change', (e) => {
    mapWrapper.setMapMode(e.target.value);
  });

  // Ensimmäinen sijainnin hakukutsu, tarkalla sijainnilla
  navigator.geolocation.getCurrentPosition(function(position) {
    const lat = position.coords.latitude;
    const lng = position.coords.longitude;

    myPin = createPin([lat, lng], 'I', 'green', "Olet tässä");

    // Siirretään kartta käyttäjän sijaintiin
    mapWrapper.setView([lat, lng]);
  }, function(err) {
    console.error("Sijainnin haku epäonnistui:", err);
  }, {
    enableHighAccuracy: true,
    timeout: 10000,
    maximumAge: 0
  });

  // Seurataan sijainnin muutoksia
  navigator.geolocation.watchPosition(function(pos) {
    const lat = pos.coords.latitude;
    const lng = pos.coords.longitude;

    if (myPin) {
      myPin.setLatLng([lat, lng]);
    }
  }, function(err) {
    console.error("Sijainnin päivitys epäonnistui:", err);
  }, {
    enableHighAccuracy: true,
    timeout: 10000,
    maximumAge: 0
  });

  async function getElevation(loc) {
  // Hae korkeus OpenTopoDatasta
    const url = `https://www.mit.jyu.fi/demowww/cyclo/index.php?elev=${loc[0]},${loc[1]}`;
    let elevation = ''

    try {
      const response = await fetch(url);
      const data = await response.text();
      const ndata = Number(data);

      if (!isNaN(ndata)) {
        elevation = ndata.toFixed(0) + " m";
        // console.log("Korkeus:", elevation);

        // Päivitä pinin teksti näyttämään korkeus (pyöristetty)
        // hitPin.setIcon(customPin(`${Math.round(elevation)}m`, 'red', 'black'));
      }
    } catch (err) {
      // console.error("Korkeuden haku epäonnistui:", err);
    }
    return elevation;
  }


  mapWrapper.on('click', async (e) => {
    closeNav();
    if (e.originalEvent && e.originalEvent.target.id === 'mapModeSelect') return;
    const { lat, lng } = e.latlng;
    const loc = [lat, lng];
    if (!hitPin) {
      // Luo hitPin ensimmäisellä klikkauksella
      hitPin = createPin(loc, 'H', 'red');
      mapWrapper.setPinDragging(hitPin, true);
      mapWrapper.setPinOn(hitPin, 'dragend', function() {
        // Kun hitPin on siirretty, päivitetään sen sijainti
        calcDistance(-1, -1);
        lastHitPoint = mapWrapper.getPinLocation(hitPin);
      });
      mapWrapper.setPinOn(hitPin, 'drag', function() {
        // Kun hitPin on siirretty, päivitetään sen sijainti
        calcDistance(-1, -1);
      });
    } else {
      // Siirrä olemassa olevaa hitPiniä uuteen paikkaan
      setHitPinLoc(loc);
    }
    lastHitPoint = loc;

    const elevation = await getElevation(loc);

    setPinText(`${lat.toFixed(5)} ${lng.toFixed(5)} H ${elevation}`);

  });  // mapWarpper.on end

  prefixHelpLinks();

  if ( options.id !== "" )
	  toggleDiv("accountArea", false);
	else
	  toggleDiv("followArea", false);

  document.getElementById('searchCombo').addEventListener('change', function() {
    const idx = this.selectedIndex-1; // first is number of items found
    if (idx >= 0 && idx < searchPins.length) {
      const pin = searchPins[idx];
      mapWrapper.setView(mapWrapper.getPinLocation(pin));
      changeSelected(pin, true);
    }
  });

} // initializeMapPage ends


function changeSelected(pin, selected=true) {
  if (lastSelected === pin) { // Jos sama pin on jo valittu, poistetaan valinta
    mapWrapper.selectPin(pin, false);
    lastSelected = null;
    return;
  }

  if (lastSelected) {
    mapWrapper.selectPin(lastSelected, false);
  }
  lastSelected = pin;
  if (pin)  {
    mapWrapper.selectPin(pin, selected);
  }
}

function createPin(coord, label, color, text = null) {
  return mapWrapper.createPin(coord, label, color, function(pin) {
    changeSelected(pin);
  }, text);
}

function closeParent(element) {
  if (element.parentElement) {
    element.parentElement.style.display = 'none';
  }
}

let mySidenavElem = null;
let menuElem = null;

function checkMenuElements() {
  if (menuElem === null) {
    menuElem = document.getElementById("menu");
    mySidenavElem = document.getElementById("mySidenav");
  }
}

function isMenuOpen() {
  checkMenuElements()
  let s = menuElem.style;
  return s.visibility === "visible";
}

function openNav() {
  if ( isMenuOpen() ) { closeNav(); return; }
  let s = menuElem.style;
  // s.width = "300px";
  // s.height = "350px";
  s.visibility = "visible";
  s = mySidenavElem.style;
  s.visibility = "visible";
}


function closeNav() {
  checkMenuElements()
  let s = mySidenavElem.style;
  s.visibility = "hidden";
  s = menuElem.style;
  s.visibility = "hidden";
}

function toggleDiv(divId, force = null) {
  const div = document.getElementById(divId);
  let show = div.style.display !== 'block';
  if (force !== null) {
    show = force;
  }
  if (show) {
    div.style.display = 'block';
    div.style.visibility = 'visible';
  } else {
    div.style.display = 'none';
    div.style.visibility = 'hidden';
  }
}


function findMyPlace() {
  if (!myPin) return;
  // Siirretään kartta käyttäjän sijaintiin
  const center = mapWrapper.getPinLocation(myPin);
  mapWrapper.setView(center);
}

function toggleFullscreen() {
  const elem = document.documentElement; // Käytetään koko sivua

  // noinspection JSUnresolvedReference
  if (document.fullscreenElement || document.mozFullScreenElement || document.webkitFullscreenElement || document.msFullscreenElement) {
    // Poistetaan fullscreen-tila
    if (document.exitFullscreen) {
      document.exitFullscreen();
    } else { // noinspection JSUnresolvedReference
      if (document.mozCancelFullScreen) { // Firefox
            document.mozCancelFullScreen();
      } else { // noinspection JSUnresolvedReference
        if (document.webkitExitFullscreen) { // Chrome, Safari ja Opera
                    document.webkitExitFullscreen();
              } else { // noinspection JSUnresolvedReference
          if (document.msExitFullscreen) { // IE/Edge
                              document.msExitFullscreen();
                        }
        }
      }
    }
  } else {
    openFullscreen(elem);
  }
}

function openFullscreen(elem) {
  if (elem.requestFullscreen) {
    elem.requestFullscreen();
  } else { // noinspection JSUnresolvedReference
    if (elem.mozRequestFullScreen) { // Firefox
        elem.mozRequestFullScreen();
      } else { // noinspection JSUnresolvedReference
      if (elem.webkitRequestFullscreen) { // Chrome, Safari and Opera
              elem.webkitRequestFullscreen();
            } else { // noinspection JSUnresolvedReference
        if (elem.msRequestFullscreen) { // IE/Edge
                      elem.msRequestFullscreen();
                    }
      }
    }
  }
}


function adjustComponents() {
  /*  TODO: korjaa komponenttien muokkaus
   saveComponents();
   const compsdiv = document.getElementById("showComps");
   compsdiv.style.backgroundColor = document.getElementById("editCompsBackground").value;
   compsdiv.style.color = document.getElementById("editCompsColor").value;
   createComps();
   checkTimer("showTime", timecomponents.length === 0 || !options.useComps);
   */
}



window.addEventListener('DOMContentLoaded', initializeMapPage)

</script>
<div id="mySidenavHamburger" style="top: 0; left: 0; width: 30px; height: 35px; position: absolute; z-index:3600;  background-color: lightgray;">
  <span style="font-size:30px;cursor:pointer" onclick="openNav()">&#9776;<br></span>
  <span style="font-size:30px;cursor:pointer" onclick="findMyPlace()">&#9737;</span>
</div>

<div id="mySidenav" style="top: 45px; left: 0;  visibility: hidden; position: absolute; z-index:3500;  background-color: lightgray;" onclick="closeNav()">
  <label class="closebtn" style="visibility: hidden" onclick="closeNav()">&times;</label>

  <ul class="ui-menu" id="menu" style="visibility: hidden">
  <li><span onclick="toggleDiv('settings');">Asetukset...</span> <a class="help" data-href="#settings"></a></li>
  <li><span onclick="toggleDiv('findDiv'); closeNav();">Pinnien lisääminen...</span> <a class="help" data-href="#addpins"></a></li>
  <li><span onclick="showRoutePane(); closeNav()">Ajo-ohjeet...</span> <a class="help" data-href="#directions"></a></li>
  <li><span onclick="toggleDiv('loadTrack'); ">Lataa track-tiedosto...</span> <a class="help" data-href="#loadtrack"></a></li>
  <li><span onclick="toggleDiv('trackDiv'); ">Näytä track-tiedot</span> <a class="help" data-href="#showtrackdetails"></a></li>
  <li><span onclick="toggleDiv('loadRoute'); ">Lataa reittitiedosto...</span>  <a class="help" data-href="#loadroute"></a></li>
  <li><span onclick="toggleDiv('routeDiv'); ">Reitin suunnittelu...</span> <a class="help" data-href="#routeplan"></a></li>
  <li><span onclick="toggleDiv('routeRaport'); ">Reittiraportti...</span> <a class="help" data-href="#routeraport"></a></li>
  <li><span onclick="toggleDiv('loadAreas'); ">Alueet...</span>  <a class="help" data-href="#areas"></a></li>
  <li><span onclick="googleDirections();">Ajo-ohjeet Google Mapsillä</span> <a class="help" data-href="#googledirections"></a></li>
  <li><span onclick="toggleFullscreen()">Fullscreen</span></li>
  <li><span onclick="toggleDiv('about'); ">Pika-apu...</span></li>
  </ul>
  <!--Muista muuttaa korkeus openNav  (tai tee tähän tyyli automaattiseksi) -->
</div>


<div class="layout-container">
<!--suppress HtmlFormInputWithoutLabel -->
<div id="findDiv" class="ui-layout-north">
  <label class="closebtn" style="top: -10px" onclick=closeParent(this)>&times;</label>
  <div id="pinDiv" style="margin-left: 35px">
    <!-- <label class="hamburgerSpace"> </label> -->
    <label><!--suppress JSDeprecatedSymbols -->
      <input type="text" name="editPinLoc" id="editPinLoc" value="Tontuntie"
           onkeyup="checkAddPinText()"
           onkeydown="if(event.key === 'Enter') { addPin(); event.preventDefault(); }" /></label>
    <span class ="clearButton" id="buttonClearText" onclick="setPinText('')">x</span>
    <button type="button" id="buttonAddPin" onclick="addPin()">Etsi</button>
    <a class="help" data-href="#find"></a>
    <div style="display: inline-block; margin-left: 10px; white-space: nowrap;">
      <span id="searchSpan" style="visibility: hidden; display: none;">
        <label><select id="searchCombo" ></select></label>
        <span class="searchClass" id="searchMsg"></span>
        <label class="closebtn2" style="margin-top: 10px;" onclick="clearSearchResults()">&times;</label>
      </span>
    </div>
    <span class="errorClass" id="errorMsg"></span>
  </div>
</div>

<div class="ui-layout-center">
  <div id='map'></div>
  <div class="logo"></div>
  <div class="mapType">
      <div class="ui-widget" style="z-index: 1001;">
        <label class="hamburgerSpace"><select id="mapModeSelect"></select></label>&nbsp;
        <span  id="distance" onclick="mapWrapper.removeLines(distanceLines)">0 km</span>
      </div>
    </div>
    <div class="area1CBcopy">
      <label for="area1cbCopy">✈️</label><br><input type="checkbox" title="Ilmatilat" id="area1cbCopy" name="area1cbCopy" value="area1cbCopy" />
    </div>
</div>
</div>

<div class="popup" id="settings" style="">
  <label class="closebtn" onclick="toggleDiv('settings'); adjustComponents()">&times;</label>
  <div class="popupIn">
    <h2>Asetukset</h2>
    <label><input type="checkbox" id="HCenter" value="HCenter"  />Pidä H keskellä <a class="help" data-href="#othersettings"></a></label><br />
    <!-- <input type="checkbox" id="showAccuracy" value="showAccuray"  />Näytä tarkkuusympyrä<br /> -->
    <label><input type="checkbox" id="readGPS" value="readGPS"  />Lue GPS:ää</label><br />
    <label><input type="checkbox" name="followMe" id="followMe" value="followMe"  />Piirrä oma jälki</label>
    <label><input type="text" name="editFollowMeColor" id="editFollowMeColor" value="orange" size="8" /></label>
    <label><input type="text" name="editFollowMeWidth" id="editFollowMeWidth" value="3" size="1" /> pt</label><br />
    <label><input type="checkbox" name="selectNewPin" id="selectNewPin" value="selectNewPin"  />Valitse uusi pin aktiiviseksi</label><br />
    <!-- <input type="checkbox" name="useDummyRect" id="useDummyRect" value="useDummyRect"  />Käytä tyhjää hakualuetta (jos ei osaa hakea)<br /> -->
    <span id="preventSleepSpan"><label><input type="checkbox" name="preventSleep" id="preventSleep" value="preventSleep"  />Estä näytön sammuminen</label></span>
    <br /><br />


    <div class="ui-widget" id="followDiv">
      <div id="followArea">
        <button type="button" onclick="toggleDiv('followArea', false); toggleDiv('accountArea', true);" >Tilaa käyttäjätunnus (ID)...</button><a class="help" data-href="#userid"></a>
        <hr>
        <div id="accountArea2"><p><b>Oman paikan lähettäminen ja muiden seuraaminen:</b><a class="help" data-href="#followsettings"></a></p>
          <label for="editTag">Kartalla näkyvä tunnus: </label><input type="text" name="editTag" id="editTag" value="" size="5" /><br>
          <label for="editLog">logname: </label><input type="text" name="editLog" id="editLog" value="" size="12" /><br>
          <label for="editInterval">interval/ms: </label><input type="text" name="editInterval" id="editInterval" value="5000" size="8" /><br>
          <label for="editUsersTofollow">Seurattavat käyttäjät: </label><input type="text" name="editUsersTofollow" id="editUsersTofollow" value="" size="15"   /><br />
        </div>
        <br />
        <button type="button" onclick="getfollow(); closeDiv('settings');">Hae muiden paikka</button> (jos automaatti ei ole päällä)<br />
        <br />
        <label><input type="checkbox" name="follow" id="follow" value="follow"  />Seuraa muita automaattisesti</label><br />
        <label><input type="checkbox" name="drawLogLine" id="drawLogLine" value="drawLogLine"  />Piirrä viivaa seurattavista</label><br />
        <label><input type="checkbox" id="send" value="send"  />Lähetä omaa paikkaa</label><br />
        <hr>
        <div id="compArea"><p><b>Mittareiden arvot</b> <a class="help" data-href="#gauges"></a></p>
          <label><input type="checkbox" name="useComps" id="useComps" value="useComps"  />Näytä mittarit</label><br />
          <div id="showCompsSettings">
            <label><input type="checkbox" id="useCompsWindow" value="useCompsWindow"  />Näytä ikkunassa</label><br />
            <span><br>Taustan väri: </span> <label><input type="text" id="editCompsBackground" value="rgba(0,0,0,1.0)"  /></label><br />
            <span><br>Fontin väri: </span> <label><input type="text" id="editCompsColor" value="white"  /></label><br />
            <span style="font-size: 10px">Ruksi mittarit joita haluat käyttää</span>
            <table id="tableCompsSettings">
            </table>
          </div>
        </div>
        <button class="close" onclick="toggleDiv('settings'); adjustComponents()">Sulje</button>
      </div>
      <div id="accountArea">
        <br />

        <label for="editEmail">Email: </label><input type="text" name="editEmail" id="editEmail" value="" size="25" /><a class="help" data-href="#userid"></a><br />
        <label for="editId">id: </label><input type="text" name="editId" id="editId" value="" size="15" /><br />
        <br />
        <button id="getId">Hae uusi ID</button><a class="help" data-href="#userid"></a>
        <br />
        <br />
        <span class="idMsg" id = "idMsg"></span>
        <br />
        <button type="button" onclick="toggleDiv('followArea', true); toggleDiv('accountArea', false);" >Palaa seuranta-asetuksiin...</button>
      </div>
    </div>
  </div>
</div>

<div class="popup" id="about" style=" ">
  <label class="closebtn" onclick="toggleDiv('about')">&times;</label>
  <div class="popupIn">
  <h2>Pika-ohjeet</h2>
  <p>Dataa tähän karttaan voit lähettää <a href="https://trac.cc.jyu.fi/projects/dotnet/wiki/CycloLite">CycloLite</a>llä,
  <a href="https://play.google.com/store/apps/details?id=jyu.sendpos&hl=en_IE">SendPos Androidilla</a>
    tai <a href="s.html">Lähetys-sivulla</a>.</p>
  <p>
    Tunnukset voit tehdä <a href="javascript:void(0)" onclick="toggleDiv('about'); toggleDiv('settings')">asetuksista</a> tai
  <a href="account.html">tilien hallinta</a>-sivulla.
  </p>
  <p>
  <a href="https://tim.jyu.fi/view/users/vesal/riippu/cyclo/kartta" target="blank">Ohjeet</a>.
  </p>
   <button class="close" onclick="toggleDiv('about')">Sulje</button>
  </div>
</div>



</body>
</html>
