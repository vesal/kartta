<!DOCTYPE HTML>
<!--suppress JSUnresolvedFunction, JSUnresolvedVariable, HtmlFormInputWithoutLabel -->
<html lang="">
  <head>
    <meta charset="UTF-8">
      <title>Kartta</title>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
	  <meta name="viewport" content="initial-scale=1.0, user-scalable=no,width=device-width">
<script type='text/javascript' src='https://www.bing.com/api/maps/mapcontrol?callback=GetMap&setLang=en' async defer ></script>
<!-- see: https://social.msdn.microsoft.com/Forums/en-US/bd8fe277-c0cf-4764-9fea-c2817451e7f3/problems-with-search-and-directions-with-bing-maps-when-setlangfi?forum=bingmaps -->

<script src="https://code.jquery.com/jquery-latest.min.js"></script>
<script src="https://code.jquery.com/ui/1.12.1/jquery-ui.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jqueryui-touch-punch/0.2.2/jquery.ui.touch-punch.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
<!-- <script src="js/CanvasPushpinModule.js"></script> -->
<link rel="stylesheet" href="css/smoothness/jquery-ui-1.10.3.custom.min.css">

<script src="js/jquery.layout-latest.min.js"></script>
<!-- <script src="js/CanvasPushpinModule.js"></script> -->
<script src="https://rawcdn.githack.com/nextapps-de/winbox/0.2.0/dist/winbox.bundle.js"></script>
<style>

.hide {
    display: none;
}

.wb-body {
    right: 0;
    top: 15px;
    overflow: unset;
}
.wb-icon {
    height: 15px;
}
.wb-title {
    line-height: 15px;
}

</style>

<script type="text/javascript">

const helpServerUrl = "https://tim.jyu.fi/view/users/vesal/riippu/cyclo/kartta";

function prefixHelpLinks() {
    document.querySelectorAll('a.help').forEach(link => {
        link.target = "help";
        link.innerText = " ?";
        const hash = link.getAttribute('href');
        if (hash && hash.startsWith('#')) {
            link.setAttribute('href',  helpServerUrl + hash);
        }
    });
}

  const options = {
    email: "",
    id: "",
    logname: "",
    interval: "5000",
    usersTofollow: "",
    send: false,
    readGPS: true,
    resend: false,
    follow: false,
    followMe: false,
    showTime: true,
    selectNewPin: true,
    useDummyRect: false,
    preventSleep: true,
    smallRaport: false,
    drawLogLine: false,
    HCenter: true,
    showAccuracy: true,
    extra: false,
    tpR: "0",
    hasWakeLock: false,
    useComps: false,
    useCompsWindow: false,
  };

const areaDatas = [
  {name: "Ilmatilat", url: "https://flyk.com/api/airspaces.geojson", cb: "area1cb"},
  {name: "Suplementit", url: "https://flyk.com/api/supplements.geojson", cb: "area2cb"},
  {name: "Varaukset", url: "https://flyk.com/api/reservations.geojson", cb: "area3cb"},
];

let namedComponents = {};

/* View in fullscreen
* https://www.w3schools.com/howto/howto_js_fullscreen.asp
*/
function openFullscreen(elem) {
  if (elem.requestFullscreen) {
    elem.requestFullscreen();
  } else if (elem.webkitRequestFullscreen) { /* Safari */
    elem.webkitRequestFullscreen();
  } else if (elem.msRequestFullscreen) { /* IE11 */
    elem.msRequestFullscreen();
  }
}

function setAutoComp(comp, name, value) {
  comp[name] = value;
  localStorage.setItem("acomp." + comp.name +"." + name, JSON.stringify(value));
}

function getAutoComp(comp, name, def, f) {
  const s = localStorage.getItem("acomp." + comp.name +"." + name);
  if (s===null) {
     setAutoComp(comp, name, def);
     return def;
  }
  let value = JSON.parse(s);
  if (f) value = f(value);
  return value
}

const getSpeed = function(comp, position) {
  return position.coords.speed * 3.6;
}

const getAlt = function(comp, position) {
   return position.coords.altitude;
}

const getDir = function(comp, position) {
   return position.coords.heading;
}

const clearTrip = function (comp) {
   setAutoComp(comp, "distSum", 0);
   comp.lastPos = undefined;
   localStorage.removeItem("acomp.Trip.lastPos");
   comp.value = 0;
   comp.span.innerText = "0.000";
}

const getTrip = function(comp, position) {
   let coord = {latitude: position.coords.latitude, longitude: position.coords.longitude};
   if (!startstop.checked) {
     setAutoComp(comp, "lastPos", coord);
     if ( comp.temp === undefined ) {
        comp.temp = getAutoComp(comp, "distSum", 0);
        return comp.temp;
     }
     return null;
   }
   let old = comp.lastPos;
   if (old === undefined) {
      old = getAutoComp(comp, "lastPos", coord);
   }
   const d = WGS84_distance(coord, old);
   // componentsList["Temp"].span.innerText = d + " " +  JSON.stringify(old);
   let distSum = comp.distSum;
   if (distSum === undefined) {
      distSum = getAutoComp(comp, "distSum", 0);
   }
   if (d < 0.005) return distSum;
   distSum += d;
   setAutoComp(comp, "distSum", distSum);
   setAutoComp(comp, "lastPos", coord);
   return distSum;
}

const clearElap = function(comp) {
   setAutoComp(comp, "elapZero", (new Date()).getTime());
   setAutoComp(comp, "elapSum", 0);
}

const startCounters = function(start) {
   let trip = namedComponents["Trip"];
   let elap = namedComponents["Elap"];
   if (elap) {
       if (start) setAutoComp(elap, "elapZero", (new Date()).getTime());
       else setAutoComp(elap, "elapSum", elap.sum);
   }
}

const msToHMS = function(ms) {
   const h = Math.floor(ms / 1000 / 60 / 60);
   ms -= h* 1000 * 60 *60;
   const m = Math.floor(ms / 1000 / 60);
   ms -= m* 1000 * 60;
   const s = Math.floor(ms / 1000);
   return h + ":" + d2(m) + ":" + d2(s);
}

const getElap = function(comp, now) {
   if (!startstop.checked) {
      if ( comp.temp !== undefined) return null;
      comp.temp = getAutoComp(comp, "elapSum", 0);
      return msToHMS(comp.temp);
   }
   let old = comp.elapZero;
   if (old === undefined) {
      // old = getAutoComp(comp, "elapZero", now, value => new Date(value));
      old = getAutoComp(comp, "elapZero", now.getTime());
   }
   // let diff = now.getTime() - old.getTime();
   let nowt = now.getTime();
   let diff = nowt - old;
   const elapSum = getAutoComp(comp, "elapSum", 0);
   diff += elapSum;
   comp.sum = diff;
   return msToHMS(diff);
}

const getTime = function(comp, now) {
   const time = now.getHours() + ":" + d2(now.getMinutes()) + ":" + d2(now.getSeconds());
   return time;
}



const componentsList = {
  "Speed": {inUse: true,  label: "Nopeus",  unit: "km/h", font: "50px", back: "", len: 5, des: 1,  f: getSpeed, type: 0},
  "Trip":  {inUse: true,  label: "Matka",   unit: "km",   font: "40px", back: "", len:-4, des: 3,  f: getTrip,  type: 0, click: clearTrip},
  "Alt":   {inUse: true,  label: "Korkeus", unit: "m",    font: "30px", back: "", len: 4, des: 0,  f: getAlt,   type: 0},
  "Dir":   {inUse: true,  label: "Suunta",  unit: "deg",  font: "20px", back: "", len: 3, des: 0,  f: getDir,   type: 0},
  "Elap":  {inUse: true,  label: "Aika",    unit: "aika", font: "20px", back: "", len: 3, des: -1, f: getElap,  type: 1, click: clearElap},
  "Time":  {inUse: false, label: "Kello",   unit: "",     font: "20px", back: "", len: 3, des: -1, f: getTime,  type: 1},
//  "Temp":  {inUse: true,  label: "Temp",    unit: "temp", font: "10px", back: "rgba(255, 255, 255, 0.6)", len: 3, des: -1, f: null,     type: 2},
}

let geocomponents = [];
let timecomponents = [];

  // Ks: https://github.com/richtr/NoSleep.js/blob/master/src/index.js
// The wake lock sentinel.
if ('wakeLock' in navigator) { options.hasWakeLock = true; }
let wakeLock = null;

// Function that attempts to request a screen wake lock.
// async // IE11 does not like async, but we manage without it using then and teh fact that this is never called in ie
function requestWakeLock()  {
  // alert('Start Wake Lock 2');
  endWakeLock();
  if (document.visibilityState === "hidden") return;
  try {
    // noinspection JSUnresolvedVariable
    // wakeLock = await navigator.wakeLock.request('screen'); // does not work on ie
    // wakeLock.addEventListener('release', function() {/* alert('Screen Wake Lock was released'); */ });
    // alert('Screen Wake Lock is active');
    navigator.wakeLock.request('screen').then(function(wl) {
      wakeLock = wl;
      wakeLock.addEventListener('release', function() {
        // alert('Screen Wake Lock was released'); */
        });
      document.addEventListener('visibilitychange', handleVisibilityChange);
      // alert('Screen Wake Lock is active');
    });
  } catch (err) {
    alert(err.name + err.message);
  }
}

if ('wakeLock' in navigator) {
  options.hasWakeLock = true;
}

function handleVisibilityChange() {
  if (wakeLock !== null && document.visibilityState === 'visible') {
    requestWakeLock();
  }
}


function startWakeLock() {
  // alert('Start Wake Lock 1');
	requestWakeLock();
}



function endWakeLock() {
   if ( !wakeLock ) return;
   wakeLock.release();
   document.removeEventListener('visibilitychange', handleVisibilityChange);
   wakeLock = null;
   // alert('Wake Lock released');
}


function checkSleep() {
   if ( options.preventSleep && options.hasWakeLock ) { startWakeLock(); }
   if ( !options.preventSleep ) { endWakeLock(); }
}


function isChecked(name) {
    return document.getElementById(name).checked;
}


$(document).ready(function () {
	//$('body').layout({ applyDemoStyles: true });
  initPage();
  $("#menu").menu();
  const routeDiv = $("#routeDiv");
  const routeRaport = $("#routeRaport");
  // noinspection JSValidateTypes
  routeDiv.draggable({handle: ".move"});
  routeDiv.resizable();
  // noinspection JSValidateTypes
  routeRaport.draggable({handle: ".move"});
  routeRaport.resizable();

  $('#editPinLoc').keypress(function(e){
    if(e.keyCode === 13) {
      $('#buttonAddPin').click();
      return false;
    }
   });
 // $(".dragable").draggableTouch();
  closeNav();
  readComponents();
  checkShowComponents();
  adjustComponents();
  prefixHelpLinks();


});
</script>
<script type="text/javascript">

jQuery(window).bind('beforeunload', function(){
    return 'my text';
});


function goodbye(e) {
    if (!e) { // noinspection JSDeprecatedSymbols
      e = window.event;
    }
    //e.cancelBubble is supported by IE - this will kill the bubbling process.
    e.cancelBubble = true;

    //e.stopPropagation works in Firefox.
    if (e.stopPropagation ) {
        e.stopPropagation();
        e.preventDefault();
    }

  const confirmationMessage = 'Haluatko lopettaa?'; //This is displayed on the dialog;

  e.returnValue = confirmationMessage;     // Gecko, Trident, Chrome 34+
  return confirmationMessage;
}

window.onbeforeunload=goodbye;

function getUrlVars()
 {
   let vars = [], hash;
   const hashes = window.location.href.slice(window.location.href.indexOf('?') + 1).split('&');
   for (let i = 0; i < hashes.length; i++) {
        hash = hashes[i].split('=');
        vars.push(hash[0]);
        vars[hash[0]] = hash[1];
    }
    return vars;
 }

const params = getUrlVars();
let map = null;
// let canvasLayer;
let directionsManager = null;
// const geoLocationProvider = null;
let tilelayer;
// const redIcon = "css/pin2/red.png";
const blueIcon = "css/pin2/blue.png";
const blueSelIcon = "css/pin2/blueSel.png";
const greenIcon = "css/pin2/green.png";
const greenSelIcon = "css/pin2/greenSel.png";
const greenDotIcon = "css/pin2/blackGreenDot.png";
const greenDotSelIcon = "css/pin2/blackGreenDotSel.png";
const redDotIcon = "css/pin2/blackRedDot.png";
const redDotSelIcon = "css/pin2/blackRedDotSel.png";
let currentPosPin = null;
let hitPin = null;

const followPinList = {};
const followPolylineList = {};
const followLocationsList = {};
const myLineVertices = [];
let myPolyline;
let trackList = null;


// noinspection JSUnusedGlobalSymbols
function GetMap() {
  // Microsoft.Maps.loadModule('Microsoft.Maps.Themes.BingTheme',{ callback: ContinueGetMap });
  // noinspection JSUnresolvedVariable,JSUnresolvedFunction
  Microsoft.Maps.loadModule("Microsoft.Maps.SpatialMath", function () {
      ContinueGetMap();
    });
 }

let routeOptions = {w:3};

function ContinueGetMap() {
  // Initialize the map
  const pzoom = parseInt(params["zoom"]) || parseInt(localStorage.zoom) || 8;
  const lon = params["lon"] || localStorage.lon || 25.75;
  const lat = params["lat"] || localStorage.lat || 62.25;
  const load = params["load"] || localStorage.load || "";
  const route = params["route"] || localStorage.route || "";
  routeOptions = makeJSON(params["routeoptions"] || localStorage.routeOptions || "", 0, routeOptions);
  const froute = params["froute"] || localStorage.froute || "";
  const opens = params["open"] || "";

  // noinspection JSUnresolvedVariable,JSUnresolvedFunction
  map = new Microsoft.Maps.Map("#mapDiv",{
	  credentials:"Ao_g6EJt65LD09k5BdCLMyDSNnfnLtKjKkrDKTDCp4IvIEyldy5RlHr5gDd6JJQu",
	  culture: 'fi', homeRegion: 'FI',
	  zoom: pzoom,
      mapTypeId: Microsoft.Maps.MapTypeId.road,
	  // mapTypeId: Microsoft.Maps.MapTypeId.mercator,
	  center:new Microsoft.Maps.Location(lat,lon)
	});

   // noinspection JSUnresolvedFunction,JSUnresolvedVariable
  map.setView({ labelOverlay: Microsoft.Maps.LabelOverlay.hidden });
	map.setOptions({disableStreetside: true})

	// Microsoft.Maps.loadModule('Microsoft.Maps.Directions', { callback: directionsModuleLoaded, culture: 'fi', homeRegion: 'FI', theme: new Microsoft.Maps.Themes.BingTheme()  });
	// noinspection JSUnresolvedVariable
	Microsoft.Maps.loadModule('Microsoft.Maps.Directions', directionsModuleLoaded);

  const tileSource = new Microsoft.Maps.TileSource({uriConstructor: getTilePath});
  tilelayer = new Microsoft.Maps.TileLayer({ mercator: tileSource, opacity: 1 });
  // map.entities.push(tilelayer);
  const origo = new Microsoft.Maps.Location(0, 0);
  currentPosPin = newPin(origo,false,"I",greenDotIcon,greenDotSelIcon);
  hitPin = newPin(origo,true,"H",redDotIcon,redDotSelIcon);
  Microsoft.Maps.Events.addHandler(map,'click',mapHit);
  Microsoft.Maps.Events.addHandler(map,'viewchange',mapMove);
  // Microsoft.Maps.Events.addHandler(map,'mousemove',mapHit);  // experiment how pin follows mouse

  let mapName = localStorage.getItem("mapName") || "Bing Maps normal";
  let paramMapName = params["mapName"];
  if ( paramMapName !== undefined ) mapName = paramMapName;
  SelectMapMode(mapName);
  const cb = $('#combobox')[0];
  trackList = $('#tracklog')[0];

  for (let i = 0; i<cb.options.length; i++) {
      if ( cb.options[i].text === mapName ) {
         cb.selectedIndex = i;
         break;
      }
  }

  let i = 1;
  while ( true ) {
    let p = params["p" + i] || false;
    if ( !p ) break;
     p = decodeURIComponent(p) || "";
     addPinAt(p);
     i++;
  }

	// geoLocationProvider = new Microsoft.Maps.GeoLocationProvider(map); // not any more in V8
	// Get the user's current location
    // myPolyline.setOptions({strokeThickness: 3, strokeColor: "orange"});
  showCurrentPosition();

  if ( load ) {
      document.getElementById("editURLTrack").value = load.replaceAll(",", "\n");
      AutoGrowTextArea(document.getElementById("editURLTrack"));
      handleURLTrack();
  }
  if ( route ) {
      document.getElementById("editURLRoute").value = route.replaceAll(",", "\n");
      AutoGrowTextArea(document.getElementById("editURLRoute"));
      handleURLRoute(froute);
  }
  // noinspection PointlessBooleanExpressionJS
  if ( false && froute ) {
      forceRoute(froute);
  }
  checkGeoLocation();

  if ( opens ) {
    const ops = opens.split(",");
    for (let i in ops) {
            openDiv(ops[i].trim());
    }
  }
  checkAreas();
}


function findMyPlace() {
  const center = currentPosPin.getLocation();
  map.setView({center:center});
}

let mapmode;

function copyToUrl() {
  let tr = document.getElementById("editURLTrack").value.trim().replaceAll("\n", ",");
  if ( tr !== "" ) tr = "&load="+tr;
  let ro = document.getElementById("editURLRoute").value.trim().replaceAll("\n", ",");
  if ( ro !== "" ) ro = "&route="+ro;
  const pos = map.getCenter();
  const url = "k.html?" +
    "lat=" + pos.latitude.toFixed(5) +
    "&lon=" + pos.longitude.toFixed(5) +
    "&zoom=" + map.getZoom() +
    "&mapName=" + mapmode +
    tr + ro;
  history.replaceState("object or string", "Title",url);
}

function copyRouteToUrl() {
  const url = "k.html?" +
    "zoom=" + map.getZoom() +
    "&mapName=" + mapmode +
    "&from=" + editFrom.value +
    "&to=" + editTo.value +
    "";
  history.replaceState("object or string", "Title",url);
}


let mouseDown = false;

function mapHit(e)  {
  if ( mouseDown ) { mouseDown = false; return; }
  if (e.targetType !== "map") return;
  const point = new Microsoft.Maps.Point(e.getX(), e.getY());
  const loc = e.target.tryPixelToLocation(point);
  setHitPinLoc(loc);
  DisplayLocPin(hitPin);
  lastHitPoint = loc;
  if ( isChecked("autoAddToRoute")) addToRoute();
  /*
  getElevation(loc.latitude, loc.longitude, function (elev) {
    if (elev === null) return;
    hitPin.setDescription("Korkeus: " + elev.toFixed(2) + " m");
  });
   */
}


let dst;
let lastHitPoint = null;

function setHitPinLoc(loc) {
  hitPin.setLocation(loc);
  calcDistance();
}

let selectedPin = null;

function calcDistance() {
  let d = 0;
  if ( !hitPin ) return;
  if ( !selectedPin ) {
    if (!lastHitPoint) return;
    d = WGS84_distance(lastHitPoint, hitPin.getLocation());
  } else {
    d = WGS84_distance(selectedPin.getLocation(), hitPin.getLocation());
  }
  if (!dst) dst = $("#distance");
  // dst.css( "border" , "3px solid red" );
  dst[0].innerText = "" + d.toFixed(3) + " km";
}


function mapMove() {
  mouseDown = true;
  const pos = map.getCenter();
  localStorage.lon = pos.longitude;
  localStorage.lat = pos.latitude;
  localStorage.zoom = map.getZoom();
  if ( options.HCenter ) {
     setHitPinLoc(map.getCenter());
     DisplayLocPin(hitPin);
  }
}


const belectro = {
  link: "https://tanger.belectro.fi/tiles/mmltopo/v9/256/{0}/{2}/{1}?ref=7f2d",
  ok: false,
  init: function () {
    if (this.ok) return;
    this.ok = true;
    $.ajax({
      url: "https://www.mit.jyu.fi/demowww/cyclo/bbark.php",
      success: function (data) {
        const bbarkObj = JSON.parse(data);
        let url = bbarkObj.base_map_groups[0].maps[0].url;
        url = url.replace("{W}", "256");
        url = url.replace("{Z}", "{0}");
        url = url.replace("{Y}", "{2}");
        url = url.replace("{X}", "{1}");
        belectro.link = url;
      },
      async: false
    })
  }
};


// noinspection CheckImageSize
const mapModes = {
  "Bing Maps normal"   : { f:function(tile) {
	                            return String.format("http://ecn.t1.tiles.virtualearth.net/tiles/r{0}?g=1135",TileXYToQuadKey(tile));
							}, c:""},
	"Bing Maps aerial"   : { f:function(tile) {
	                            return String.format("https://ecn.t1.tiles.virtualearth.net/tiles/h{0}?g=1135",TileXYToQuadKey(tile));
							}, c:""},
	"Google street"      : { f:function(tile) { return String.format("https://mt1.google.com/vt/lyrs=m&z={0}&x={1}&y={2}",tile.zoom ,tile.x, tile.y ); },
	                         c:'(c) <a href="http://maps.google.com/help/terms_maps.html" target="_blank">Google Maps</a>'},
	"Google satellite"   : { f:function(tile) { return String.format("https://mt1.google.com/vt/lyrs=y&z={0}&x={1}&y={2}",tile.zoom ,tile.x, tile.y ); },
	                         c:'(c) <a href="http://maps.google.com/help/terms_maps.html" target="_blank">Google Maps</a>'},
//  "Google Street"      : { f:function(tile) { tile = nokiaConvert(tile); return String.format("https://maps.googleapis.com/maps/api/staticmap?center={1},{2}&zoom={0}&size=256x256&key=AIzaSyCpXjAoV19MUbpGd6e6YD9IketR2Gu-tqc",tile.zoom ,tile.x, tile.y); }, c:""},
//  "Google satellite"   : { f:function(tile) { tile = nokiaConvert(tile); return String.format("https://maps.googleapis.com/maps/api/staticmap?center={1},{2}&zoom={0}&size=256x256&key=AIzaSyCpXjAoV19MUbpGd6e6YD9IketR2Gu-tqc&maptype=hybrid",tile.zoom ,tile.x, tile.y); }, c:""},
//    "Nokia"              : { f:function(tile) { tile = nokiaConvert(tile); return String.format("http://m.nok.it/?app_id=_peU-uCkp-j8ovkzFGNU&app_code=gBoUkAMoxoqIWfxWA5DuMQ&h=256&w=256&ctr={1},{2}&z={0}&t=0&nord",tile.zoom ,tile.x, tile.y); }, c:""},
//	"MapQuest"           : { f:function(tile) { return String.format("http://otile1.mqcdn.com/tiles/1.0.0/map/{0}/{1}/{2}.png",Clip(tile.zoom,0,19) ,tile.x, tile.y); },
//	                         c:'(c) <a href="http://info.mapquest.com/terms-of-use/" target="_blank">MapQuest</a>'},
	"OpenStreet"         : { f:function(tile) { return String.format("https://tile.openstreetmap.org/{0}/{1}/{2}.png",tile.zoom,tile.x,tile.y); },
	                         c:'(c) <a href="http://www.openstreetmap.org/copyright" target="_blank">OpenStreetMap</a>'},
	"OpenCycle"          : //{ f:function(tile) { return String.format("http://a.tile.opencyclemap.org/cycle/{0}/{1}/{2}.png",tile.zoom ,tile.x, tile.y ); },
	                         { f:function(tile) { return String.format("https://tile.thunderforest.com/cycle/{0}/{1}/{2}.png?apikey=4e1589f40d3049469a043e2ec917dc88",tile.zoom ,tile.x, tile.y ); },
	                         c:'(c) <a href="http://www.opencyclemap.org/docs/" target="_blank">OpenCycleMap</a>'},
	"Landscape"          : { f:function(tile) { return String.format("https://tile.thunderforest.com/landscape/{0}/{1}/{2}.png?apikey=4e1589f40d3049469a043e2ec917dc88",tile.zoom ,tile.x, tile.y ); },
	                         c:'(c) <a href="http://www.opencyclemap.org/docs/" target="_blank">OpenCycleMap</a>'},
	"Transport"          : { f:function(tile) { return String.format("https://tile.thunderforest.com/transport/{0}/{1}/{2}.png?apikey=4e1589f40d3049469a043e2ec917dc88",tile.zoom ,tile.x, tile.y ); },
	                         c:'(c) <a href="http://www.opencyclemap.org/docs/" target="_blank">OpenCycleMap</a>'},
	"Outdoors"           : { f:function(tile) { return String.format("https://tile.thunderforest.com/outdoors/{0}/{1}/{2}.png?apikey=4e1589f40d3049469a043e2ec917dc88",tile.zoom ,tile.x, tile.y ); },
	                         c:'(c) <a href="http://www.opencyclemap.org/docs/" target="_blank">OpenCycleMap</a>'},
	/* Ei voi käyttää, koska ei ole enää saatavilla WGS84, vaan vain EPSG:3067
  "Kapsi peruskartta"  : { f:function(tile) { return getKapsiTilePath(tile); },
	                         c:'(c) <a href="http://www.maanmittauslaitos.fi/avoindata_lisenssi_versio1_20120501" target="_blank">Maanmittauslaitos</a>'},
	"Kapsi Tausta"       : { f:function(tile) { return String.format("http://tiles.kartat.kapsi.fi/taustakartta_3067/{0}/{1}/{2}.jpg",tile.zoom ,tile.x, tile.y); },
	                         c:'(c) <a href="http://www.maanmittauslaitos.fi/avoindata_lisenssi_versio1_20120501" target="_blank">Maanmittauslaitos</a>'},
	"Kapsi Ilma"         : { f:function(tile) { return String.format("http://tiles.kartat.kapsi.fi/ortokuva_3067/{0}/{1}/{2}.jpg",tile.zoom ,tile.x, tile.y); },
	                         c:'(c) <a href="http://www.maanmittauslaitos.fi/avoindata_lisenssi_versio1_20120501" target="_blank">Maanmittauslaitos</a>'

                             },
https://avoin-karttakuva.maanmittauslaitos.fi/avoin/wmts/1.0.0/taustakartta/default/WGS84_Pseudo-Mercator/18/72651/149809.png?api-key=
https://avoin-karttakuva.maanmittauslaitos.fi/avoin/wmts/1.0.0/ortokuva/default/WGS84_Pseudo-Mercator/12/1116/2297.png?api-key=
	 */
  "MML maasto"         : {   f:function(tile) { return String.format("https://avoin-karttakuva.maanmittauslaitos.fi/avoin/wmts/1.0.0/maastokartta/default/WGS84_Pseudo-Mercator/{0}/{2}/{1}.png?api-key=4c0b6a7d-aa24-4b2c-913c-66d3823d7445",tile.zoom ,tile.x, tile.y); },
	                         c:'(c) <a href="http://www.maanmittauslaitos.fi/avoindata_lisenssi_versio1_20120501" target="_blank">Maanmittauslaitos</a>'},
  "MML tausta"         : {   f:function(tile) { return String.format("https://avoin-karttakuva.maanmittauslaitos.fi/avoin/wmts/1.0.0/taustakartta/default/WGS84_Pseudo-Mercator/{0}/{2}/{1}.png?api-key=4c0b6a7d-aa24-4b2c-913c-66d3823d7445",tile.zoom ,tile.x, tile.y); },
	                         c:'(c) <a href="http://www.maanmittauslaitos.fi/avoindata_lisenssi_versio1_20120501" target="_blank">Maanmittauslaitos</a>'},
  "MML selko"         : {   f:function(tile) { return String.format("https://avoin-karttakuva.maanmittauslaitos.fi/avoin/wmts/1.0.0/selkokartta/default/WGS84_Pseudo-Mercator/{0}/{2}/{1}.png?api-key=4c0b6a7d-aa24-4b2c-913c-66d3823d7445",tile.zoom ,tile.x, tile.y); },
	                         c:'(c) <a href="http://www.maanmittauslaitos.fi/avoindata_lisenssi_versio1_20120501" target="_blank">Maanmittauslaitos</a>'},
  "MML ilma"           : {   f:function(tile) { return String.format("https://avoin-karttakuva.maanmittauslaitos.fi/avoin/wmts/1.0.0/ortokuva/default/WGS84_Pseudo-Mercator/{0}/{2}/{1}.png?api-key=4c0b6a7d-aa24-4b2c-913c-66d3823d7445",tile.zoom ,tile.x, tile.y); },
	                         c:'(c) <a href="http://www.maanmittauslaitos.fi/avoindata_lisenssi_versio1_20120501" target="_blank">Maanmittauslaitos</a>'},
	"b-bark SuomiTopo"   : { f:function(tile) {
                            return String.format(belectro.link, tile.zoom, tile.x, tile.y);
						               },
	                         c:'<span>Render:</span> <a href="https://www.b-bark.com" target="_blank"><img style="vertical-align:middle" src="css/b_bark_logo.png" width="20%" height="20%"  alt=""/></a><br />(c) <a href="http://www.maanmittauslaitos.fi/avoindata_lisenssi_versio1_20120501" target="_blank">Maanmittauslaitos</a><br />',
                             i: belectro.init },
  "World Topo Map":      {f: function(tile) {
                            return String.format("https://services.arcgisonline.com/ArcGIS/rest/services/World_Topo_Map/MapServer/tile/{0}/{2}/{1}", tile.zoom, tile.x, tile.y);
                          },
                          c: '(c) <a href="https://www.esri.com/" target="_blank">Esri</a>'
                          },
  "World Imagery"      : { f:function(tile) { return String.format("https://services.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{0}/{2}/{1}",tile.zoom ,tile.x, tile.y);},
	                         c:'(c) <a href="http://www.esri.com/~/media/Files/Pdfs/legal/pdfs/e204_e300.pdf" target="_blank">ArgGIS</a>'},
	"Ilmailu merged"      : { f:function(tile) {
                              const airac = "1806";
                              return String.format('https://snapshots.openflightmaps.org/live/' + airac + '/tiles/world/noninteractive/epsg3857/merged/256/latest/{0}/{1}/{2}.png', tile.zoom, tile.x, tile.y);
                              },
	                         c:'(c) <a href="https://openflightmaps.org/live/ef-finland/" target="_blank">openflightmaps.org</a>'},
	"Ilmailu aero"      : { f:function(tile) {
	                             const airac = "1806";
	                             return String.format('https://snapshots.openflightmaps.org/live/' + airac + '/tiles/world/noninteractive/epsg3857/aero/256/latest/{0}/{1}/{2}.png',tile.zoom ,tile.x, tile.y);
	                             },
	                         c:'(c) <a href="https://openflightmaps.org/live/ef-finland/" target="_blank">openflightmaps.org</a>'},
/*
	"Ilmailu base"      : { f:function(tile) {
	                             var airac = "1806";
	                             var url = String.format('https://snapshots.openflightmaps.org/live/' + airac + '/tiles/world/noninteractive/epsg3857/base/256/latest/{0}/{1}/{2}.png',tile.zoom ,tile.x, tile.y);
	                             return url},
	                         c:'(c) <a href="https://openflightmaps.org/live/ef-finland/" target="_blank">openflightmaps.org</a>'},
*/
 };

function SelectMapMode(mode) {
   const mm = mapModes[mode];
   if ( mm === undefined ) return;
   const logo = $(".logo");
   logo.empty();
   mapmode = mode;
   // map.entities.remove(tilelayer);
   map.layers.remove(tilelayer);
   tilelayer = null;
	 map.layers.clear();

	if ( mapmode !== "Bing Maps normal")	{
       // map.entities.push(tilelayer);
     const tileSource = new Microsoft.Maps.TileSource({uriConstructor: getTilePath});
     tilelayer = new Microsoft.Maps.TileLayer({ mercator: tileSource, opacity: 1 });
	   map.layers.insert(tilelayer);
  	 map.setOptions( { mapTypeId: Microsoft.Maps.MapTypeId.mercator, allowHidingLabelsOfRoad : true } );
  	 map.setView({ labelOverlay: Microsoft.Maps.LabelOverlay.hidden });
     // map.setView({ labelOverlay: Microsoft.Maps.LabelOverlay.visible });
	} else {
		map.setOptions( { mapTypeId: Microsoft.Maps.MapTypeId.road, allowHidingLabelsOfRoad : true } );
    map.setView({ labelOverlay: Microsoft.Maps.LabelOverlay.visible });
	}
  logo.append(mm.c);
  if (typeof mm.i !== 'undefined') {
     mm.i();
  }
  mapfunction = mm.f;
  localStorage.setItem("mapName",mode);
}


 // Simulation of C# string.Format, only {n} works.
 if (!String.format) {
  String.format = function(format) {
    const args = Array.prototype.slice.call(arguments, 1);
    return format.replace(/{(\d+)}/g, function(match, number) {
      return typeof args[number] != 'undefined'
        ? args[number]
        : match
      ;
    });
  };
}


// Converts tile XY coordinates into a QuadKey at a specified level of detail.
function TileXYToQuadKey(tile) {
  let quadKey = "";
  for (let i = tile.zoom; i > 0; i--)  {
    let digit = '0';
    const mask = 1 << (i - 1);
    if ((tile.x & mask) !== 0) {
            digit++;
    }
    if ((tile.y & mask) !== 0) {
        digit++;
        digit++;
    }
    quadKey += digit;
  }
  return quadKey;
}

function Clip(n, minValue, maxValue) {
  if ( n < minValue ) return minValue;
  if ( maxValue < n ) return maxValue;
  return n;
}
// Convert Pixel map position to latitude/longitude
function PixelXYToLatLong(pixelX, pixelY, tile) {
  const mapSize = 256 << tile.zoom;
  const x = (Clip(pixelX, 0, mapSize - 1) / mapSize) - 0.5;
  const y = 0.5 - (Clip(pixelY, 0, mapSize - 1) / mapSize);
  tile.x = 90 - 360 * Math.atan(Math.exp(-y * 2 * Math.PI)) / Math.PI;
  tile.y = 360 * x; // tarkista kumminko päin
  return tile;
}

// noinspection JSUnusedGlobalSymbols
function nokiaConvert(tile)  {
  tile.zoom  = Clip(tile.zoom,0,20);
  return PixelXYToLatLong(256 * tile.x + 128, 256 * tile.y + 128,tile);
}

function tileToWMSRect(tile)  {
  const mapSize = 256 << tile.zoom;
  const pixelX = 256 * tile.x + 128;
  const pixelY = 256 * tile.y + 128;
  const x1 = (Clip(pixelX - 128, 0, mapSize - 1) / mapSize) - 0.5;
  const y1 = 0.5 - (Clip(pixelY+128, 0, mapSize - 1) / mapSize);
  const x2 = (Clip(pixelX+128, 0, mapSize - 1) / mapSize) - 0.5;
  const y2 = 0.5 - (Clip(pixelY-128, 0, mapSize - 1) / mapSize);
  return {
      x1 : 90 - 360 * Math.atan(Math.exp(-y1 * 2 * Math.PI)) / Math.PI,
      y1 : 360 * x1,
      x2 : 90 - 360 * Math.atan(Math.exp(-y2 * 2 * Math.PI)) / Math.PI,
      y2 : 360 * x2
  };
}

let extra = params["extra"];
if ( !extra ) extra = getOptionValue("extra");
if ( extra ) {
   mapModes["Merikartta"] = { f:function(tile) {
       const rect = tileToWMSRect(tile);
       return String.format("https://kartta.liikennevirasto.fi/meriliikenne//dgds/wms_ip/merikartta?VERSION=1.1.1&REQUEST=GetMap&WIDTH=256&HEIGHT=256&FORMAT=image/jpeg&SRS=EPSG:4326&BBOX={1},{0},{3},{2}&LAYERS=cells",rect.x1,rect.y1,rect.x2,rect.y2); },
	                         c:'(c) <a href="https://portal.liikennevirasto.fi/sivu/www/f/liikenneverkko/merikartat" target="_blank">Liikennevirasto</a>'};
   setOption("extra", true);
}

mapmode = "Bing map normal";
mapfunction = mapModes[mapmode];

function getTilePath(tile) {
  // noinspection UnnecessaryLocalVariableJS
  const url = mapfunction(tile);
  //console.log(url);
  return url;
}

 function directionsModuleLoaded()
 {
	// Initialize the location provider
	// geoLocationProvider = new Microsoft.Maps.GeoLocationProvider(map); // not anymore in V8
	// Get the user's current location
	showCurrentPosition();
    if ( params["to"] ) {
        if ( params["from"] ) findDriving();

    }
 }


function Ellipsoid(name, a, invf){
  /* constructor */
  this.name=name
  this.a=a
  this.invf=invf
}

const ells = [
  new Ellipsoid("WGS84", 6378.137 / 1.852, 298.257223563),
  new Ellipsoid("FAI sphere", 6371.0 / 1.852, 1000000000.)
];


function getEllipsoid(selection){
//  document.spheroid.major_radius.value=ells[selection.selectedIndex+1].a*1.852
//  document.spheroid.inverse_f.value=ells[selection.selectedIndex+1].invf
  return ells[selection.selectedIndex];
}

function atan2(y,x) {
  let out;
  if (x <0)            { out= Math.atan(y/x)+Math.PI;}
  if ((x >0) && (y>=0)){ out= Math.atan(y/x);}
  if ((x >0) && (y<0)) { out= Math.atan(y/x)+2*Math.PI;}
  if ((x===0) && (y>0)) { out= Math.PI/2;}
  if ((x===0) && (y<0)) { out= 3*Math.PI/2;}
  if ((x===0) && (y===0)) {
  //alert("atan2(0,0) undefined")
      out= 0.
  }
  return out
}

function WGS84_distance(p1,p2) {
  const selection = {selectedIndex: 0};
  const m = Math.PI / 180;
  return crsdist_ell(p1.latitude*m,p1.longitude*m,p2.latitude*m,p2.longitude*m,getEllipsoid(selection));
}

function crsdist_ell(glat1,glon1,glat2,glon2,ellipse){
  // glat1 initial geodetic latitude in radians N positive
  // glon1 initial geodetic longitude in radians E positive
  // glat2 final geodetic latitude in radians N positive
  // glon2 final geodetic longitude in radians E positive
  const a = ellipse.a
  const f = 1/ellipse.invf
  //alert("a="+a+" f="+f)
  let r, tu1, tu2, cu1, su1, cu2, s1, b1, f1;
  let x, sx, cx, sy, cy, y, sa, c2a, cz, e, c, d;
  const EPS = 0.00000000005;
  let s;
  let iter = 1;
  const MAXITER = 100;
  if ((glat1+glat2===0.) && (Math.abs(glon1-glon2)===Math.PI)){
    alert("Course and distance between antipodal points is undefined")
    glat1=glat1+0.00001 // allow algorithm to complete
    }
  if ( glat1===glat2 && (glon1===glon2 || Math.abs(Math.abs(glon1-glon2)-2*Math.PI) <  EPS) ) {
    //alert("Points 1 and 2 are identical- course undefined")
    return 0.0; // don't care???
    // noinspection UnreachableCodeJS
    let out = new MakeArray(0)
    out.d = 0
    out.crs12 = 0
    out.crs21 = Math.PI
    return out
  }
  r = 1 - f
  tu1 = r * Math.tan (glat1)
  tu2 = r * Math.tan (glat2)
  cu1 = 1. / Math.sqrt (1. + tu1 * tu1)
  su1 = cu1 * tu1
  cu2 = 1. / Math.sqrt (1. + tu2 * tu2)
  s1 = cu1 * cu2
  b1 = s1 * tu2
  f1 = b1 * tu1
  x = glon2 - glon1
  d = x + 1 // force one pass
  while ((Math.abs(d - x) > EPS) && (iter < MAXITER))
    {
      iter=iter+1
      sx = Math.sin (x)
//       alert("sx="+sx)
      cx = Math.cos (x)
      tu1 = cu2 * sx
      tu2 = b1 - su1 * cu2 * cx
      sy = Math.sqrt(tu1 * tu1 + tu2 * tu2)
      cy = s1 * cx + f1
      y = atan2 (sy, cy)
      sa = s1 * sx / sy
      c2a = 1 - sa * sa
      cz = f1 + f1
      if (c2a > 0.)
     cz = cy - cz / c2a
      e = cz * cz * 2. - 1.
      c = ((-3. * c2a + 4.) * f + 4.) * c2a * f / 16.
      d = x
      x = ((e * cy * c + cz) * sy * c + y) * sa
      x = (1. - c) * x * f + glon2 - glon1
    }
  x = Math.sqrt ((1 / (r * r) - 1) * c2a + 1)
  x +=1
  x = (x - 2.) / x
  c = 1. - x
  c = (x * x / 4. + 1.) / c
  d = (0.375 * x * x - 1.) * x
  x = e * cy
  s = ((((sy*sy*4.-3.)*(1.-e-e)*cz*d/6.-x)*d/4.+cz)*sy*d+y)*c*a*r

  return s*1.852;
  /*
  let faz, baz;
  faz = modcrs(atan2(tu1, tu2))
  baz = modcrs(atan2(cu1 * sx, b1 * cx - su1 * cu2) + Math.PI)
  out=new MakeArray(0)
  out.d=s
  out.crs12=faz
  out.crs21=baz
  if (Math.abs(iter-MAXITER)<EPS){
    alert("Algorithm did not converge")
  }
  return out
  */
}

let zoom;

function showCurrentPosition()
{
 if ( currentPosPin == null ) return;
  zoom = map.getZoom();
  /*
  geoLocationProvider.getCurrentPosition({
        enableHighAccuracy:true,
        showAccuracyCircle:options.showAccuracy,
        successCallback:displayCenter,
        updateMapView:false,
        //errorCallback: function(object) { alert('Error callback invoked, error code '  + object.errorCode); }
  });
  */
  // getLocation();
}

/*
 var locationStarted = false;
 function getLocation() {
    if ( locationStarted ) return;
    locationStarted = true;
    if (navigator.geolocation) {
        navigator.geolocation.getCurrentPosition(displayCenter, errorCallBack, {enableHighAccuracy: true});
    } else {
        setError("Geolocation is not supported by this browser.");
    }
}
*/

const geo_options = {
  enableHighAccuracy: true,
  maximumAge: 500,
  timeout: 27000
};


let watcher = null;

function getGeoLocation() {
    if ( watcher ) return;
    if (navigator.geolocation) {
        watcher = navigator.geolocation.watchPosition(displayCurrentPosition, errorCallBack, geo_options);
    } else {
        setError("Geolocation is not supported by this browser.");
    }
}


function startGeoLocation(enable) {
   if ( watcher ) navigator.geolocation.clearWatch(watcher);
   watcher = null;
   if ( enable ) getGeoLocation();
}


function checkGeoLocation() {
    startGeoLocation(document.getElementById("readGPS").checked);
}


/*
function setCookie(cname,cvalue,exdays) {
 const d = new Date();
 d.setTime(d.getTime()+(exdays*24*60*60*1000));
 const expires = "expires=" + d.toGMTString();
 document.cookie = cname + "=" + cvalue + "; " + expires; // + ";SameSite=None;";
}


function getCookie(cname) {
 var name = cname + "=";
 var ca = document.cookie.split(';');
 for(var i=0; i<ca.length; i++)
 {
   var c = ca[i].trim();
   if (c.indexOf(name)==0) return c.substring(name.length,c.length);
 }
 return "";
}
*/
const timers = {
 follow : { t:null,f:getfollow,interval:1000 },
 showPosition : { t:null, f:showCurrentPosition,interval:1000},
 send : { t:null,f:sendPosition,interval:5000 },
 resend : { t:null,f:sendPosition,interval:200000 },
 showTime: { t:null,f:setTimeCompsValues,interval:1000 },
};

function checkTimer(timer, clear) {
  // if ( timer=="send" && !options.sendPos) return;
  const tim = timers[timer];
  if ( options[timer] && !clear)
     tim.t = setInterval(function(){ tim.f();	}, tim.interval);
  else
     clearInterval(tim.t);
}


let sending = false;

let lastGPSCoord;

function sendPosition() {
   // checkTimer("send",true);
   // checkTimer("resend",true);
   clearError();
   // getLocation();
   if ( options.send ) {
       if ( lastGPSCoord )
          postPosition(lastGPSCoord);
       else
          navigator.geolocation.getCurrentPosition(postPosition, errorCallBack, geo_options);
   }
 }

 function fixed(d,n) {
    if ( d == null ) return "NaN";
	  return d.toFixed(n);
 }


 function i2(i) {
     if ( i >= 10 ) return "" + i;
     return "0"+i;
 }


const spaces = "                                                                                                                           ";

function fixeds(s,n)  {
  if ( s == null ) s = "";
  if ( n < 0 ) return (s + spaces).substr(0, -n);
  s = spaces + s;
  const l = s.length;
  return s.substr(l-n);
}


function cleanNumbers(s) {
  return s.replace(/[^0-9]/g,'').trim();
}


function sendCyclo(command,f, extra) {
  /*
    $.ajax({
    type: 'POST',
    url: "https://www.mit.jyu.fi/demowww/cyclo/",
    contentType: 'text/plain',
    xhrFields: { withCredentials: false },
     success: function() {
       },
  });
  */
  clearError();
  options.id = cleanNumbers(options.id);
  const params = $.extend({}, command, {id: options.id, e: getEmailTag()});
  $.post( "https://www.mit.jyu.fi/demowww/cyclo/index.php", params )
  .done(function( data ) {
    f(data, extra)
  } );
}


 function getEmailTag() {
   if ( !options.tag ) return options.email;
   return options.email + "+" + options.tag
 }


function getLogname() {
  if ( options.logname ) return options.logname;
  const today = new Date();
  const dd = today.getDate();
  const mm = today.getMonth() + 1; //January is 0!
  const yy = today.getFullYear() - 2000;

  return i2(yy) + i2(mm) + i2(dd);
}

let lastSend = "";

function postPosition(position) {
    if ( sending ) return;
    if ( !options.id || !options.email ) return;
    sending = true;
    // checkTimer("send",true);
    // checkTimer("resend",false);
     /*
        $.ajax({
        type: 'POST',
        url: "https://www.mit.jyu.fi/demowww/cyclo/",
        contentType: 'text/plain',
        xhrFields: { withCredentials: false },
         success: function() {
           },
      });
      */
   clearError();
   // var position ="62.4596956,25.7324266,0,433,41478.4036846991,2.390,254.9,3.0,3.0";
  const pos = fixed(position.coords.latitude, 7) + "," +
    fixed(position.coords.longitude, 7) + "," +
    "0" + "," +
    fixed(((position.coords.altitude) * 3.280839895), 0) + "," +
    fixed((position.timestamp / 1000 / 3600 / 24) + 25569.00, 10) + "," +
    fixed(position.coords.speed, 1) + "," +
    fixed(position.coords.heading, 1) + "," +
    fixed(position.coords.accuracy, 1) + "," +
    fixed(position.coords.altitudeAccuracy, 1);
  const posmsg = fixed(position.coords.latitude, 4) + "," +
    fixed(position.coords.longitude, 4);

  // let tag = "";
  // if ( options.tag ) tag = "+" + options.tag;

   if ( lastSend === posmsg ) {
      setError("");
      // timers["send"].interval = options.interval;
      // checkTimer("send",false);
      // checkTimer("resend",true);
      sending = false;
      return;
   }
   $.post( "https://www.mit.jyu.fi/demowww/cyclo/", { id: options.id, e: getEmailTag(), d : pos, log:getLogname()  })
    .done(function( data ) {
      setError(data);
      // timers["send"].interval = options.interval;
      // checkTimer("send",false);
      // checkTimer("resend",true);
      sending = false;
      lastSend = posmsg;
	  }
	);
  const c = document.getElementById('coord');
  c.innerHTML = " " + posmsg;
}


function errorCallBack() {
    setError("getLocation error");
}


lastGPSCoord = null;

function displayCurrentPosition(position) {
	   lastGPSCoord = position;
	    /*
	    var accuracy = args.position.coords.accuracy;
		// Display the user location when the geo location request returns
		// alert("The user's location is " + args.center);
		if ( accuracy > 500 ) {
		  geoLocationProvider.removeAccuracyCircle();
		  if ( options.showAccuracy )
            geoLocationProvider.addAccuracyCircle(args.center, 500, 500, {polygonOptions:{fillColor:new Microsoft.Maps.Color(50,100,0,0), strokeColor:new Microsoft.Maps.Color(100,255,0,0)}});
		}
        */
		// map.setView({ zoom:zoom });
    if (options.useComps) {
      setGeoCompsValues(position);
    }

		currentPosPin.setLocation(position.coords);
		if ( currentPosPin === selectedPin ) map.setView({center:selectedPin.getLocation()});
		if ( options.followMe ) {
      const curpos = new Microsoft.Maps.Location(position.coords.latitude, position.coords.longitude, position.coords.altitude);
      myLineVertices.push(curpos);
        if (!myPolyline) {
            myPolyline = new Microsoft.Maps.Polyline(myLineVertices);
            map.entities.push(myPolyline);
        }
  		  myPolyline.setLocations(myLineVertices);
		    myPolyline.setOptions({strokeThickness: options.followMeWidth, strokeColor: options.followMeColor});
    }
    // for test draw
 		     // center = new Microsoft.Maps.Location(position.coords.latitude, position.coords.longitude+0.5, position.coords.altitude);
		     // myLineVertices.push(center);
		     // myPolyline.setLocations(myLineVertices);
    if ( options.send ) postPosition(position);

}


 function moveEditTo(edit) {
   const editField = document.getElementById(edit);
   editField.value = getPinText();
   const name = edit.replace("edit", "").toLowerCase();
   setOption(name,editField.value);
   calcDistance();
 }

function pToStr(p, sep) {
  // noinspection UnnecessaryLocalVariableJS
  const s = p.latitude.toFixed(5) + sep + p.longitude.toFixed(5);
  return s;
}


function moveITo(edit) {
  const editField = document.getElementById(edit);
  const p = currentPosPin.getLocation();

  editField.value = pToStr(p, ' ');
  const name = edit.replace("edit", "").toLowerCase();
  setOption(name,editField.value);
  calcDistance();
}


function checkSpecialCoord(s) {
  const su = s.toUpperCase();
  if ( su === "" || su === "I" )
    return pToStr(currentPosPin.getLocation(), ' ');
  if ( su === "H" )
    return pToStr(hitPin.getLocation(), ' ');
  if ( isCoordinate(s) ) return getNormalizedCoordinateString(s, " ");
	return s;
}


function findDriving() {
	// Initialize the DirectionsManager
	if ( directionsManager == null ) directionsManager = new Microsoft.Maps.Directions.DirectionsManager(map);
	// directionsManager.resetDirections();
	directionsManager.clearAll();

	// Create start and end waypoints
  const addrFrom = checkSpecialCoord(document.getElementById('editFrom').value);
  const addrTo = checkSpecialCoord(document.getElementById('editTo').value);
  const modeCB = document.getElementById('RouteMode');


  const startWaypoint = new Microsoft.Maps.Directions.Waypoint({address: addrFrom});
  const endWaypoint = new Microsoft.Maps.Directions.Waypoint({address: addrTo});
  let rMode = Microsoft.Maps.Directions.RouteMode.driving;
  if ( modeCB.checked ) rMode = Microsoft.Maps.Directions.RouteMode.walking;


	directionsManager.addWaypoint(startWaypoint);
	directionsManager.addWaypoint(endWaypoint);
	directionsManager.setRequestOptions({
	  culture: 'fi',
	  distanceUnit: Microsoft.Maps.Directions.DistanceUnit.kilometers,
	  routeMode: rMode,
	  // routeOptimization: Microsoft.Maps.Directions.RouteOptimization.shortestDistance
	  });

	// Set the id of the div to use to display the directions
	directionsManager.setRenderOptions({ itineraryContainer: document.getElementById('itineraryDiv') });

	// Specify a handler for when an error occurs
	Microsoft.Maps.Events.addHandler(directionsManager, 'directionsError', displayError);

	// Calculate directions, which displays a route on the map
	directionsManager.calculateDirections();

}


let searchManager = null;
let searchPins = [];


function getPinText() {
    return document.getElementById('editPinLoc').value.trim();
}

function setPinText(s) {
    document.getElementById('editPinLoc').value = s.trim();
    checkAddPinText();
}

function search() {
    if (!searchManager) {
        //Create an instance of the search manager and perform the search.
        Microsoft.Maps.loadModule('Microsoft.Maps.Search', function () {
            searchManager = new Microsoft.Maps.Search.SearchManager(map);
            search();
        });
    } else {
      //Remove any previous results from the map.
      clearSearchResults();
      //Get the users query and geocode it.
      const query = getPinText();
      geocodeQuery(query);
    }
}

function searchFrom(inputName) {
    document.getElementById('editPinLoc').value = document.getElementById(inputName).value;
    search();
}

function selectSearchPin(t) {
  const s = t.text();
  const v = t.val();
  const i = s.indexOf(')');
  setPinText(s.substr(i+2));
  centerSearchPin(parseInt(v)-1);
}


function centerSearchPin(n) {
  if ( n < 0 ) return;
  if ( n >= searchPins.length ) return;
  const pin = searchPins[n];
  map.setView({center:pin.location});
}

function clearSearchResults() {
  const cb = $('#searchCombo');
  cb.empty();

  for (let i=0; i < searchPins.length; i++) {
      map.entities.remove(searchPins[i]);
  }

  searchPins = [];
  clearError();
  clearMessage();
  closeDiv("searchSpan");
}

// https://mapapi.org/open.php?file=example21&h=4

let dummyRect_ = null;

function dummyRect() {
  if ( !options.useDummyRect ) return null;
  if ( !dummyRect_ )
     dummyRect_ = new Microsoft.Maps.LocationRect(new Microsoft.Maps.Location(39.0, -0.12555), 0.05, 0.05);
       // new Microsoft.Maps.LocationRect(new Microsoft.Maps.Location(62.29995, 25.73246), 0.05, 0.05);
  return dummyRect_;
}

function geocodeQuery(query) {

  if ( isCoordinate(query) ) {
    const loc = getCoordinateFromText(query);
    const pin = new Microsoft.Maps.Pushpin(loc, {
      text: (1) + ''
    });
    searchPins.push(pin);
    map.entities.push([pin]);
    map.setView({center:loc});
    return;
  }

  const searchRequest = {
    where: query,
    bounds: dummyRect(),
    // bounds: new Microsoft.Maps.LocationRect(new Microsoft.Maps.Location(39.0, -0.12555), 0.05, 0.05),
    // bounds: null,
    callback: function (r) {
      if (r && r.results && r.results.length > 0) {
        openDiv("searchSpan");
        // noinspection JSMismatchedCollectionQueryUpdate
        let pin, pins = [], locs = [], output = '';

        for (let i = 0; i < r.results.length; i++) {
          //Create a pushpin for each result.
          pin = new Microsoft.Maps.Pushpin(r.results[i].location, {
            text: (i + 1) + ''
          });
          pins.push(pin);
          pin.location = r.results[i].location;
          locs.push(r.results[i].location);

          output += (i + 1) + ') ' + r.results[i].name + ',';
          const opt = (i + 1) + ') ' + r.results[i].name;
          $('#searchCombo').append(new Option(opt, "" + (i + 1)));
          searchPins.push(pin);
        }

        setMessage("/" + r.results.length);
        //Add the pins to the map
        map.entities.push(pins);

        centerSearchPin(0);

        /*
        //Determine a bounding box to best view the results.
        var bounds;

        if (r.results.length == 1) {
            bounds = r.results[0].bestView;
        } else {
            //Use the locations from the results to calculate a bounding box.
            bounds = Microsoft.Maps.LocationRect.fromLocations(locs);
        }

        map.setView({ bounds: bounds });
        */
      }
    },
    errorCallback: function () {
      //If there is an error, alert the user about it.
      // alert("No results found.");
      setError("Ei löydy! " + query)
    }
  };

  //Make the geocode request.
    searchManager.geocode(searchRequest);
}

function displayError(e) {
	alert(e.message);
}


function DisplayLoc(e) {
	if (e.targetType === 'pushpin') DisplayLocPin(e.target);
}

function DisplayLocPin(pin)
{
  const pinLoc = pin.getLocation();
  const alt = pinLoc.altitude;
  let alts = "";
  if ( !(alt === undefined) ) alts = " " + (alt/3.280839895).toFixed(0) + " m";
  setPinText(pinLoc.latitude.toFixed(5) + " " + pinLoc.longitude.toFixed(5) + " " + pin.getText() + alts);
  calcDistance();
}

function ddmmssToDeg(s)
{
  if ( s.length !== 6 ) return 0;
  if ( s.indexOf(",") >= 0 ) return 0;
  if ( s.indexOf(".") >= 0 ) return 0;
  const dd = parseFloat(s.substr(0, 2));
  const mm = parseFloat(s.substr(2, 2));
  const ss = parseFloat(s.substr(4, 2));
  return dd + mm/60 + ss/3600;
}


function sToDeg(s) {
   // s can be:
   //    623025  = ddmmss
   //    63.5017 = dd.dddd
   //    63.30'25 = dd.mm'ss
   //    63.30'25" = dd.mm'ss"
   //    63.3017' = dd.mm.mm'
  const c = String.fromCharCode(65533); // asteen merkki?
  s = s.replaceAll(c, ".");
  const im = s.indexOf("'");
  const id = s.indexOf(".");
  if ( id < 0 ) return ddmmssToDeg(s);
  if ( im < 0 ) return parseFloat(s);
  if ( im < s.length-1 ) return ddmmssToDeg(s.replace("'","").replace('"','').replace('.',''));
  s = s.replace("'","");
  const dd = parseFloat(s.substr(0, id));
  const mm = parseFloat("0." + s.substr(id + 1)) * 100.0 / 60.0;
  return dd + mm;
}

function d2(d) {
	  d = Math.round(d);
	  if ( d < 10 ) return "0" + d;
	  return ""+d;
}


function toDDMMSS(d) {
  const t = {dd: 0, mm: 0, ss: 0};
  let sign = 1;
  if ( d < 0 ) { sign = -1; d = -d; }
  let b = Math.round(d * 360000);
  t.ss  = (b % 6000)/100;
  b  = Math.floor(b / 6000);
  t.mm  = b % 60;
  t.dd  = Math.floor(b / 60);
  t.dd  = sign * t.dd;
  return t;
}


function ddmmss(d) {
  let sign = '';
  if ( d < 0 ) { sign = "-"; d = -d; }
  const t = toDDMMSS(d);
  return sign + d2(t.dd) + '.' + d2(t.mm) + "'" + d2(t.ss) + '"';
}

let pinNr = 1;

// noinspection JSUnusedGlobalSymbols
function clearEdit(id) {
     document.getElementById(id).value = "";
 }


function addPin() {
   const s = getPinText().trim();
   if (s === "") return;
   if ( !isCoordinate(s) ) return search();
   const pin = addPinAt(s);
   if (options.selectNewPin) {
     selectActivePin(pin, true);
     const loc = new Microsoft.Maps.Location(pin.geometry.y, pin.geometry.x);
     map.setView({center:loc});
   }
}


function isCoordinate(s) {
     if ( s === "" ) return false;
     return "0123456789-".indexOf(s[0]) >= 0;
}


function checkAddPinText() {
   let text = "Lisää pinni";
   if ( !isCoordinate(getPinText()) ) text = "Etsi";
   document.getElementById('buttonAddPin').innerText = text;
}


function getCoordinateFromText(s) {
  if (s === "") return null;
  const latLongArray = (s).split(/[\s,]+/);
  const lats = latLongArray[0];
  const lons = latLongArray[1];

  const latVal = sToDeg(lats);
  const longVal = Microsoft.Maps.Location.normalizeLongitude(sToDeg(lons));
  return new Microsoft.Maps.Location(latVal, longVal);
}

/*
function getCoordinate() {
    return getCoordinateFromText(getPinText());
}
*/

function getNormalizedCoordinateString(s, sep) {
  const pos = getCoordinateFromText(s);
  if ( pos == null ) return "";
  return pos.latitude + sep + pos.longitude;
}


function addPinAt(pinLoc) {
  let center = hitPin.getLocation();
  let name = "" + pinNr;
  if ( pinLoc !== "" ) {
    const latLongArray = (pinLoc).split(/[\s,]+/);
    center = getCoordinateFromText(pinLoc);
    name = latLongArray[2];
    if ( name === undefined || name === "H" || name === "" ) name = ""+pinNr++;
  }
  else pinNr++;

  return newPin(center, true, name, blueIcon, blueSelIcon);
}


let myLayout;

function checkClosed(name,def) {
   let val = params[name + "Closed"] || localStorage[name + "Closed"] || def;
   if ( val === "true" ) val = true;
   if ( val === "false" ) val = false;
   return val;
 }


//=================================================================
// Functions to handle components:
//=================================================================

let compsdiv = null;
let startstop = {checked: false};  // Matki checkboxia jos ei luotu

function checkShowComponents() {
   let cb = options.useComps;
   let setDiv = document.getElementById("showCompsSettings");
   let useDiv = document.getElementById("showComps");
   if (!cb) {
      setDiv.style.display = "none";
      useDiv.style.display = "none";
   } else {
      setDiv.style.display = "block";
      useDiv.style.display = "block";
   }
}

function adjustComponents() {
   saveComponents();
   const compsdiv = document.getElementById("showComps");
   compsdiv.style.backgroundColor = document.getElementById("editCompsBackground").value;
   compsdiv.style.color = document.getElementById("editCompsColor").value;
   createComps();
   checkTimer("showTime", timecomponents.length === 0 || !options.useComps);
}

function readComponents() {
  let bs = localStorage.getItem("editCompsBackground");
  if (bs) document.getElementById("editCompsBackground").value = bs;

  bs = localStorage.getItem("editCompsColor");
  if (bs) document.getElementById("editCompsColor").value = bs;

  for (const name in componentsList) {
     const comp = componentsList[name];
     let s = localStorage.getItem(name);
     if ( s ) comp.editFont.value = s;
     s = localStorage.getItem(name + "Col");
     if ( s !== null ) comp.editCol.value = s;
     s = localStorage.getItem(name + "Cb");
     if ( s !== null) {
       comp.cbUse.checked = s === "1";
       comp.inUse = comp.cbUse.checked;
     }
   }
}

function saveComponents() {
  localStorage.setItem("editCompsBackground", document.getElementById("editCompsBackground").value);
  localStorage.setItem("editCompsColor", document.getElementById("editCompsColor").value);
  for (const name in componentsList) {
     const comp = componentsList[name];
     localStorage.setItem(name, comp.editFont.value);
     localStorage.setItem(name + "Col", comp.editCol.value);
     localStorage.setItem(name + "Cb",  comp.cbUse.checked ? "1" : "0");
     comp.inUse = comp.cbUse.checked;
   }
}

function addTD(tr, text) {
     const td = document.createElement("td");
     td.innerText = text;
     tr.appendChild(td);
}

function addTDInput(tr) {
  const td = document.createElement("td");
  tr.appendChild(td);
  // <input type="text" id="editSpeed" value="50px" size="3" /></td><td><input type="text" id="editSpeedCol" value="rgba(255, 255, 255, 0.6)" size="20" />
  const input = document.createElement("input");
  td.appendChild(input);
  return input;
}

function addTDCB(tr) {
     const cb = addTDInput(tr);
     cb.setAttribute("type", "checkbox");
     return cb;
}

function addTDEdit(tr, name, size, text) {
     // <input type="text" id="editSpeed" value="50px" size="3" /></td><td><input type="text" id="editSpeedCol" value="rgba(255, 255, 255, 0.6)" size="20" />
     const edit = addTDInput(tr);
     edit.setAttribute("id", "edit"+name);
     edit.setAttribute("size", size);
     edit.setAttribute("value", text);
     edit.innerHTML = text;
     return edit;
}

function createCompsSettings() {

  compsdiv = document.getElementById("showComps");
  const table = document.getElementById("tableCompsSettings");
  table.innerHTML = "<tr><td></td><td>Mittari</td><td>Fontti</td><td>Taustan väri</td></tr>";

  for (const name in componentsList) {
     const comp = componentsList[name];
     const tr = document.createElement("tr");
     const cbUse = addTDCB(tr);
     cbUse.checked = comp.inUse;
     addTD(tr, comp.label);
     const editFont = addTDEdit(tr, name, 3, comp.font);
     const editCol = addTDEdit(tr, name + "Col", 20, comp.back);
     comp.cbUse = cbUse;
     comp.editFont = editFont;
     comp.editCol = editCol;
     comp.div = null;
     comp.span = null;
     comp.name = name;
     comp.value = 0;
     table.appendChild(tr);
  }
  createComps();
}

function showCompsDiv(show) {
   if (show) {
     compsdiv.style.display = "inherit";
     if (compsWindow) compsWindow.show();
   } else {
     compsdiv.style.display = "none";
     if (compsWindow) compsWindow.hide();
   }
}


let compsWindow = null;

function readWindowPos(w) {
   if (w === null ) return;
   const s = localStorage.getItem(w.id + 'Pos');
   if ( s === null ) return;
   let xywh = s.split(";");
   w.x = parseInt(xywh[0]);
   w.y = parseInt(xywh[1]);
   w.width = parseInt(xywh[2]);
   w.height = parseInt(xywh[3]);
   w.move(w.x, w.y);
   w.resize(w.width, w.height);
}

function saveWindowPos(w) {
   if (w === null ) return;
   const s = `${w.x};${w.y};${w.width};${w.height}`;
   localStorage.setItem(w.id + 'Pos', s);
}


function createComps() {
  readComponents();
  if (options.useCompsWindow && compsWindow === null) {
    compsWindow = new WinBox("Mittarit", {
      id: "compsWindow",
      mount: document.getElementById("showComps"),
      height: 310,
      width: 150,
      y: "bottom",
      onresize: function(w,h) { saveWindowPos(compsWindow); },
      onmove: function(x,y) { saveWindowPos(compsWindow); },
      onclose: function(force) { compsWindow = null; return false; },
      // background: document.getElementById("editCompsBackground").value,
    });
    readWindowPos(compsWindow);
    // compsWindow.onmove = function(x,y) { saveWindowPos(compsWindow); };
    // compsWindow.onresize = function(w,h) { saveWindowPos(compsWindow); };
  }
  if (!options.useCompsWindow && compsWindow !== null) {
      compsWindow.close(true);
      compsWindow = null;
  }

  if ( compsWindow !== null ) {
     const sheet = document.styleSheets[4]; // TODO: keksi oikea tapa löytää
     let bc = document.getElementById("editCompsBackground").value;
     if (bc.startsWith("rgba(") || bc.startsWith("hsla(") ) {
         bc = bc.replace(/,[^,]*\)/, ",1)");
     }
     if (sheet && sheet.cssRules) {
       if (sheet.cssRules[0].cssText.startsWith("#compsWindow .wb-body")) sheet.deleteRule(0);
       sheet.insertRule(`#compsWindow .wb-body {background: ${bc}}`, 0);
     }
  }

  geocomponents = [];
  timecomponents = [];
  compsdiv.innerHTML = '<span style="top: 0px;  position: absolute" onclick="showCompsDiv(false)"><</span>'+
          ''  ; //'<br />';

  startstop = document.createElement("input");
  startstop.setAttribute("type", "checkbox");
  startstop.onclick = function() {
    localStorage.setItem("startstop", startstop.checked ? "1": "0");
    startCounters(startstop.checked);
  }
  startstop.checked = localStorage.getItem("startstop") !== "0"; // oletus päällä
  compsdiv.appendChild(startstop);

  for (const name in componentsList) {
    const comp = componentsList[name];
    comp.div = null;
    comp.span = null;
  }


  for (const name in componentsList) {
      const comp = componentsList[name];
      if (!comp.inUse) continue;
      const compdiv = document.createElement("div");
      compdiv.setAttribute("id", "div" + name);
      compdiv.style.backgroundColor = comp.editCol.value;
      compdiv.classList.add("comp");
      compdiv.style.display = "inline-block"
      compsdiv.appendChild(compdiv);
      comp.div = compdiv;
      if (comp.unit) {
        const labelspan = document.createElement("span");
        labelspan.innerHTML = comp.unit;
        compdiv.appendChild(labelspan);
        compdiv.appendChild(document.createElement("br"));
      }
      const compspan = document.createElement("span");
      compspan.setAttribute("id", name.toLowerCase() + "Comp");
      compspan.style.fontSize = comp.editFont.value;
      compspan.classList.add("data");
      compspan.innerText = comp.value;
      if (comp.click) compspan.onclick = () => comp.click(comp);
      compdiv.appendChild(compspan);
      comp.span = compspan;
      if ( comp.type === 0)  geocomponents.push(comp);
      if ( comp.type === 1)  timecomponents.push(comp);
      namedComponents[name] = comp;
      // const space = document.createElement("span");
      // space.innerHTML = "&nbsp;&nbsp;"
      // compsdiv.appendChild(space);
  }
}

function setTimeCompsValues() {
    const now = new Date();
    for (let comp of timecomponents) {
        let v = comp.f(comp, now);
        if (v === null) continue;
        comp.span.innerText = v;
        comp.value = v;
    }
}


function setGeoCompsValues(position) {
    // componentsList["Speed"].span.innerHTML = Math.round(position.coords.speed * 3.6 * 10) / 10;
    // componentsList["Alt"].span.innerHTML = Math.round(position.coords.altitude);
    // componentsList["Dir"].span.innerHTML = Math.round(position.coords.heading);
    for (let comp of geocomponents) {
        let v = comp.f(comp, position);
        if (v === null) continue;
        let d = comp.len;
        if (d < 0) {
           let s = v.toPrecision(-d).substr(0,-d+1);
           comp.span.innerText = s;
           comp.value = s;
           continue;
        }
        let des = comp.des;
        if (des < 0) {
           comp.span.innerText = v;
           comp.value = v;
           continue;
        }
        let s = v.toFixed(des);
        while (s.length < d) s = "\u2000" + s;
        // s = s.replace(/ /g, "&nbsp;")
        comp.span.innerText = s;
        comp.value = s;
    }
}

//=================================================================
// Functions to handle components ends
//=================================================================


function initPage() {
  // noinspection JSUnusedLocalSymbols

  params.forEach(function(element, index, array) {
    params[element] = decodeURIComponent(params[element]);
  });

  // const browser = navigator.userAgent;
  // alert(browser);
  // const isiPad = browser.match(/iPad/i) != null;
  // const isWP = browser.match(/Windows Phone/i) != null;
  if ( !(window.File && window.FileReader && window.FileList && window.Blob ) ) // || isiPad || isWP )
	   $("#getLogFile").hide();

  /*
   // ei tarvii koska getXoption hoitaa
    var followusers = params["followusers"] || "";
    var logname = params["logname"] || "";

    if ( logname ) setOption("logname", logname);
    if ( followusers ) setOption("usersTofollow", followusers);

    // setCBOption("follow", params["follow"]);
    // setCBOption("send", params["send"]);
    // setCBOption("readGPS", params["gps"]);
  */
  //GetMap();
  checkSavedValues();
  createCompsSettings();
  if ( options.id !== "" )
	  $("#accountArea").hide();
	else
	  $("#followArea").hide();

  const northClosed = checkClosed("north", false);
  const southClosed = checkClosed("south", false);
  let eastClosed = checkClosed("east", true);
  const westClosed = true; // checkClosed("west", true);
  if ( eastClosed && params["to"] ) eastClosed = false;

  const w = window.innerWidth;
  myLayout = $("body").layout({
      onclose : function(name) {
        localStorage[name+"Closed"] = true;
      },
      onopen : function(name) {
        localStorage[name+"Closed"] = false;
      },
	   // applyDemoStyles: true,
	   defaults: {
		  fxName:               "slide",
	      fxSpeed:               "1",
	      spacing_closed:        0,
	      spacing_open:        0,
	      initClosed:            false,
	   },
	   east: {
	      size: w*0.3,
	      initClosed:            eastClosed
	   },
	   west: {
	      size: w*0.1,
	      initClosed:            westClosed
	   },
	   north: {
	      spacing_closed:        0,
	      spacing_open:        0,
	      initClosed:            northClosed,
	      //togglerLength_closed:  "10%"
	   },
	   south: {
	      initClosed:            southClosed,
	      //togglerLength_closed:  "50%"
	   }
	});

  // myLayout.bindButton('#showRoutePane', 'toggle', 'east');
  // myLayout.bindButton('#showOptionsPane', 'toggle', 'west');
	// myLayout.bindButton('#showInstructionsPane', 'toggle', 'south');
  document.getElementById('logFile').addEventListener('change', handleFileSelect, false);
  document.getElementById('routeFile').addEventListener('change', handleFileSelect, false);

	// noinspection JSUnusedLocalSymbols
  $.each(mapModes, function(val, text) {
      $('#combobox').append( new Option(val,val) );
    });

	$('#combobox').change(function() {
    const t = $('#combobox :selected').text();
    SelectMapMode(t);
    });

	$('#searchCombo').click(function() {
    const t = $('#searchCombo :selected');
    selectSearchPin(t);
    });

  // Handler for send new id -button
	// noinspection JSUnusedLocalSymbols
  $("#getId").on("click", function(event) { orderId(); } );

	checkTimer("send",false);
	checkTimer("resend",false);
  // sendPosition();
}


function orderId() {
  const url = window.location.href.split("?");
  const returl = url[0] + "?open=settings&email=" + options.email + "&id=";
  // noinspection JSUnusedLocalSymbols
  sendCyclo({order:1,returl:returl}, function(d, n){ $("#idMsg").text(d) }, null);
}

function setOption(name,value) {
  options[name] = value;
  localStorage.setItem(name,value);
}


function setOptionInt(name,value,def) {
  const val = parseInt(value) || def;
  options[name] = val;
  localStorage.setItem(name, val);
}


function getOptionValue(name) {
  return localStorage[name];
}


function getOption(name,editName) {
  const edit = $("#" + editName);
  options[name] = params[name] || localStorage.getItem(name) || "";
	if (options[name] !== "")
	  edit.val(options[name]); //document.getElementById(edit).value = options[name];
	// noinspection JSUnusedLocalSymbols
  edit.on("change", function(event) {
	  setOption(name,this.value);
	} );
    setOption(name,edit[0].value);
}


function getOptionInt(name,editName, def) {
  const edit = $("#" + editName);
  const val = parseInt(localStorage.getItem(name)) || def;
  options[name] = params[name] || val || def;
  if (options[name] !== "")
    edit.val(options[name]); //document.getElementById(edit).value = options[name];
  // noinspection JSUnusedLocalSymbols
  edit.on("change", function(event) { setOptionInt(name,this.value, def);  } );
  setOptionInt(name,edit[0].value,def);
}


function getBoolean(s) {
   if (typeof(s) === typeof true) return s;
   if ( s === '1') return true;
   s = s.toUpperCase();
   if ( s === "TRUE") return true;
   return s === "YES";

}


function setCBOption(name,value) {
  if ( value === undefined ) return;
  value = getBoolean(value);
  options[name] = value;
  localStorage.setItem(name,value);
}


function getCBOption(name,f) {
  const cb = document.getElementById(name);
  let value = params[name];
  if ( value === undefined ) value = getBoolean(localStorage.getItem(name) || options[name] || false);
  else value = getBoolean(value);
  options[name]= value;
  if (options[name]) {
     cb.checked = true;
     options[name] = true; // ??? ei kai tarviisi
  } else options[name] = false;

  // noinspection JSUnusedLocalSymbols
  cb.addEventListener("click", function(event) {
    setCBOption(name, this.checked);
    if (typeof f !== "undefined") f(this.checked);
  });
  setCBOption(name,cb.checked);
}


function checkSavedValues() {
  if ( !options.hasWakeLock ) {
    const s = document.getElementById("preventSleepSpan").style;
    s.visibility = "hidden";
  }

  getOption("followMeColor","editFollowMeColor");
  getOptionInt("followMeWidth","editFollowMeWidth", 3);

  getOption("email","editEmail");
  getOption("id","editId");
  getOption("usersTofollow","editUsersTofollow");
  getOption("to","editTo");
  getOption("from","editFrom");
  getOption("tpR","editTPR");

  getOption("tag","editTag");
  getOption("logname","editLog");
  getOption("interval","editInterval");
  getOption("trackColors","editTrackColors");
  getOption("routeColors","editRouteColors");

  getCBOption("follow",function(checked) { checkTimer("follow", !checked); } );
  getCBOption("followMe",function() { /*checkTimer("followMe");*/ } );
  getCBOption("selectNewPin",function() { /*checkTimer("followMe");*/ } );
  // getCBOption("useDummyRect",function() { /*checkTimer("followMe");*/ } );
  getCBOption("preventSleep",function() { checkSleep(); } );
  getCBOption("smallRaport",function() { changeRaportView(); } );
  // getCBOption("showAccuracy");
  getCBOption("HCenter");
  getCBOption("send"); // ,sendPosition);
  getCBOption("drawLogLine");
  // getCBOption("readGPS",function() { checkTimer("readGPS"); });
  getCBOption("readGPS",function() { checkGeoLocation(); });
  getCBOption("useComps",function() { checkShowComponents(); });
  getCBOption("useCompsWindow");

  const cb1 = document.getElementById('area1cb');
  const cb2 = document.getElementById('area1cbCopy');



  for (let area of areaDatas) {
    getCBOption(area.cb, function() { checkArea(area);});
    getCBOption(area.cb+ "Own", function() { checkAreaColor(area);});
    getOption(area.cb + "Opt", area.cb + "Opt")
  }

  // Sync the two checkboxes
  cb1.addEventListener('change', syncCheckboxes);
  cb2.addEventListener('change', syncCheckboxes);
  function syncCheckboxes(e) {
      cb1.checked = cb2.checked = e.target.checked;
      if (e.target === cb2) {
        // Trigger cb1's change event so all logic runs
        cb1.dispatchEvent(new Event('click', { bubbles: true }));
      }
  }
  cb2.checked = cb1.checked;

  checkTimer("follow", !options.follow);
  // checkTimer("readGPS");
  changeRaportView();

  checkSleep(); // check if use wakw lock or not

  /*
  options.follow=getCookie("follow"); if (options.follow=="true") { document.getElementById('follow').checked = true; options.follow = true; } else options.follow = false;
  options.showAccuracy=getCookie("showAccuracy"); if (options.showAccuracy=="true") { document.getElementById('showAccuracy').checked = true; options.showAccuracy = true; } else options.showAccuracy = false;
  options.HCenter=getCookie("HCenter"); if (options.HCenter=="true") { document.getElementById('HCenter').checked = true; options.HCenter = true; } else options.HCenter = false;
  options.showAccuracy=getCookie("showAccuracy"); if (options.showAccuracy=="true") { document.getElementById('showAccuracy').checked = true; options.showAccuracy = true; } else options.showAccuracy = false;
  checkTimer("follow");
  */
}


/*
function saveCookies()  {
  const ex = 365;
  options.follow = document.getElementById('follow').checked; setCookie("follow",options.follow,ex);
  options.showAccuracy = document.getElementById('showAccuracy').checked; setCookie("showAccuracy",options.showAccuracy,ex);
  options.HCenter = document.getElementById('HCenter').checked; setCookie("HCenter",options.HCenter,ex);
  options.showAccuracy = document.getElementById('showAccuracy').checked; setCookie("showAccuracy",options.showAccuracy,ex);
}
*/


function getfollow()  {
  /*
    $.ajax({
    type: 'POST',
    url: "https://www.mit.jyu.fi/demowww/cyclo/",
    contentType: 'text/plain',
    xhrFields: { withCredentials: false },
     success: function() {
       },
  });
  */
  if ( !options.id || !options.email ) return;

  clearError();
  $.post( "https://www.mit.jyu.fi/demowww/cyclo/", { id: options.id, e: getEmailTag(), f : options.usersTofollow  })
  .done(function( data ) { setPins(data) });
}


function setPins(data) {
  const lines = data.split("\n");
  for (let i=0; i <lines.length; i++)
     setPin(lines[i]);
}


function setErrorGen(name, s) {
  const e = document.getElementById(name);
  e.innerHTML += " " + s;
  return s;
}


function clearErrorGen(name) {
  const e = document.getElementById(name);
  e.innerHTML = "";
	return "";
}

function setMessage(s) { return setErrorGen('searchMsg', s); }
function setError(s) { return setErrorGen('errorMsg', s); }
function setErrorTrack(s) { return setErrorGen('errorMsgTrack', s); }
// function setErrorRoute(s) { return setErrorGen('errorMsgRoute', s); }

function clearMessage() { return clearErrorGen('searchMsg'); }
function clearError() { return clearErrorGen('errorMsg'); }
function clearErrorTrack() { return clearErrorGen('errorMsgTrack'); }
function clearErrorRoute() { return clearErrorGen('errorMsgRoute'); }


 function newPin(center,drag,text, icon,iconsel) {
   const pin = new Microsoft.Maps.Pushpin(center, {
     draggable: drag,
     text: text,
     icon: icon,
     height: 48,
     width: 48,
     anchor: new Microsoft.Maps.Point(24, 48),
   });
   pin["selectedIcon"] = iconsel;
   Microsoft.Maps.Events.addHandler(pin, 'mouseup', DisplayLoc);
   Microsoft.Maps.Events.addHandler(pin,'click',selectPin);
   map.entities.push(pin);
   return pin;
}

function setPin(line) {
  line = line.trim();
  if ( line === "" ) return;
  if ( line[0] !== 'D' )  return setError(line);
  const parts = line.split(":");
  const n = parts[1].split("=");
  const name = n[0];
  const d = n[1].split(",");
  const latVal = parseFloat(d[0]);
  const longVal = Microsoft.Maps.Location.normalizeLongitude(parseFloat(d[1]));
  const alt = parseFloat(d[3]);
  const center = new Microsoft.Maps.Location(latVal, longVal, alt);
  center.altitude = alt;
  let pin;
  let pline;
  let lineVertices;
  if ( name in followPinList ) {
    pin = followPinList[name];
    pline = followPolylineList[name];
    lineVertices = followLocationsList[name];
    const len = lineVertices.length;
    const last = lineVertices[len - 1];
    const same = last.latitude === center.latitude && last.longitude === center.longitude;
    if (!same ) {
      if (options.drawLogLine) lineVertices.push(center);
      else pline.getLocations().length = 0;
      pin.setLocation(center);
      if (lineVertices.length % 1 === 0) // To let it draw also with big zoom factors
        pline.setLocations(lineVertices);
    }
  }
  else {
    // var pinInfobox = new Microsoft.Maps.Infobox(center, {title: name, visible: false});
    pin = newPin(center,false,name.substring(0,4),greenIcon,greenSelIcon);
    lineVertices = new Array(center);
    pline = new Microsoft.Maps.Polyline(lineVertices);
    followPinList[name] = pin;
    followPolylineList[name] = pline;
    followLocationsList[name] = lineVertices;
    map.entities.push(pin);
    map.entities.push(pline);
    // map.entities.push(pinInfobox);
  }
  if ( pin === selectedPin ) map.setView({center:center});
}

let loadedTracks = [];
let trackLines = [];


function parseRegFloat(re, line) {
  const r = re.exec(line);
  if ( r == null ) return null;
  return parseFloat(r[1]);
}


function parseZTime(re, line) { // 2018-07-06T08:58:36.218Z
   const r = re.exec(line);
   if ( r == null ) return null;
   return Date.parse(r[1]);
}


function showTrack(data, type, colors) {
  let line;
  const ei = data.indexOf("Error:");
  if ( data.indexOf("ERROR:") >= 0 || 0 <= ei && ei <= 100 ) {
     setErrorTrack(data);
     return;
  }
  const color = colors[loadedTracks.length % colors.length];
  closeDiv("loadTrack");
  let lines;
  let reLat = /.*/;
  let reLng = /.*/;
  let reHr = /.*/;
  // const reSpeed = /.*/;
  let reEle = /.*/;
  let reCad = /.*/;
  let reTime = /.*/;

  if ( type === "tcx") {
     lines = data.split("<Trackpoint>");
     reLat = /.*<LatitudeDegrees>(.*)<\/LatitudeDegrees>.*/
     reLng = /.*<LongitudeDegrees>(.*)<\/LongitudeDegrees>.*/
     reHr = /.*<HeartRateBpm><Value>(.*)<\/Value><\/HeartRateBpm>.*/
     reEle = /.*<AltitudeMeters>(.*)<\/AltitudeMeters>.*/
     reCad = /.*<Cadence>(.*)<\/Cadence>.*/
     reTime = /.*<Time>(.*)<\/Time>.*/
  }
  else if ( type === "gpx") {
     lines = data.split("<trkpt ");
     reLat = /.*lat="([^"]*)".*/
     reLng = /.*lon="([^"]*)".*/
     reEle = /.*<ele>(.*)<\/ele>.*/
     reTime = /.*<time>(.*)<\/time>.*/
  }
  else
    lines = data.split("\n");

  const lineVertices = [];
  let nr = 0;
  let trackText = "";
  for (let i=0; i<lines.length; i++) {
    line = lines[i].trim();
    let lat = 0;
    let lng = 0;
    let latVal = 0;
    let longVal = 0;
    let time = 0;
    let ele = 0;
    const speed = 0;
    let hr = 0;
    let cad = 0;
    if ( line === "" ) continue;
    if ( type === "cyc" ) {
      const p = line.split(",");
      lat = p[0];
      lng = p[1];
      latVal = parseFloat(lat);
      longVal = Microsoft.Maps.Location.normalizeLongitude(parseFloat(lng));
    }
    if ( type === "igc" ) {
      // 0        1         2         3
      // 0123456789012345678901234567890123456789
      //  hhmmssddmmmmm dddmmmmm  pppppgggggspeed
      // B1337166226608N02550102EA0091800913046
      // B1323366227150N02548221EA0000000444
      if ( line[0] !== "B" ) continue;
      latVal = parseFloat(line.substr(7,2)) + parseFloat("0."+line.substr(9,4))*100.0/60.0;
      longVal = parseFloat(line.substr(15,3)) + parseFloat("0."+line.substr(18,4))*100.0/60.0;
      if ( line[14] !== "N" ) latVal = - latVal;
      if ( line[23] !== "E" ) longVal = - longVal;
    }
    if ( type === "tcx" ) {
      // <Trackpoint><Time>2018-07-06T08:58:36.218Z</Time>
      // <Position><LatitudeDegrees>62.29965</LatitudeDegrees><LongitudeDegrees>25.73255667</LongitudeDegrees></Position>
      // <AltitudeMeters>112.015</AltitudeMeters>
      // <HeartRateBpm><Value>90</Value></HeartRateBpm>
      // <Cadence>0</Cadence><SensorState>Present</SensorState></Trackpoint>
      latVal =  parseRegFloat(reLat, line);
      longVal =  parseRegFloat(reLng, line);
      if ( latVal == null || longVal == null ) continue;
      ele =  parseRegFloat(reEle, line);
      hr =  parseRegFloat(reHr, line);
      cad =  parseRegFloat(reCad, line);
      time = parseZTime(reTime,line);
    }
    if ( type === "gpx" ) {
      // <trkpt lat="62.29948333" lon="25.741695"><ele>135.0</ele><time>2018-07-06T09:03:32.218Z</time></trkpt>
      latVal =  parseRegFloat(reLat, line);
      longVal =  parseRegFloat(reLng, line);
      if ( latVal == null || longVal == null ) continue;
      time = parseZTime(reTime,line);
    }
    const pt = new Microsoft.Maps.Location(latVal, longVal);
    pt.time = time;
    pt.hr = hr;
    pt.speed = speed;
    pt.ele = ele;
    pt.cad = cad;
    lineVertices.push(pt);
    trackText += ""+nr+"\n"
    nr++;
  }
  line = new Microsoft.Maps.Polyline(lineVertices);
  line.setOptions({strokeThickness: 3, strokeColor: color});
  map.entities.push(line);
  loadedTracks.push(line);
  trackLines.push(lineVertices);
  trackList.innerText = trackText;
}

function logMapEntities() {
  return;
  console.log("Number of entities:", map.entities.getLength());
  for (let i = 0; i < map.entities.getLength(); i++) {
      console.log("Entity", i, map.entities.get(i));
  }
}

const loadedRoutes = [];

function removePolys(polys) {
  if ( !polys ) return;
  logMapEntities();

  for (let i=0; i < polys.length; i++) {
     const p = polys[i];
     map.entities.remove(p);
  }
}


function removePins(pins) {
  if ( !pins ) return;
  for (let i=0; i <pins.length; i++) {
     const p = pins[i];
     map.entities.remove(p);
  }
}


function removeRoute(name) {
  for (let i=0; i < loadedRoutes.length; i++) {
    const r = loadedRoutes[i];
    if ( r.name === name ) {
        map.entities.remove(r.line);
        removePolys(r.polys);
        removePolys(r.pins);
        loadedRoutes.splice(i, 1);
        return;
    }
  }
}


function isErrorOnData(data) {
  const ei = data.indexOf("Error:");
  return data.indexOf("ERROR:") >= 0 || 0 <= ei && ei <= 100;
}

function parseBool(val) {
    if ((val.toLowerCase() === 'true' || val.toLowerCase() === 'yes'))
        return true;
    if ((val.toLowerCase() === 'false' || val.toLowerCase() === 'no'))
        return false;

    return null;
}

function makeJSON(line, start, def) {
   const p = line.split(",");
   if (p.length < start) return null;
   let jso = {};
   if (def) jso = JSON.parse(JSON.stringify(def));
   for (let i=start; i < p.length; i++) {
       const nv = p[i].split(":");
       if (nv.length < 2) continue;
       let sval = nv[1];
       let val = sval;
       let ival = parseInt(sval);  // tarvitaan, riittääkö float?
       if (!isNaN(ival)) val = ival;
       let fval = parseFloat(sval);
       if (!isNaN(fval)) val = fval;
       let bval = parseBool(sval);
       if (bval != null) val = bval;
       jso[nv[0]] = val;
   }
   if (jso && Object.keys(jso).length > 0) return jso;
   return null;
}

function colorWithAlpha(color, alpha) {
    // Luo väliaikainen elementti
    const temp = document.createElement("div");
    temp.style.color = color;
    document.body.appendChild(temp);
    // Selaimen normalisoima väri
    const computed = getComputedStyle(temp).color;
    document.body.removeChild(temp);

    // Etsi rgb-arvot
    const m = computed.match(/^rgb\((\d+),\s*(\d+),\s*(\d+)\)$/);
    if (m) {
        return `rgba(${m[1]},${m[2]},${m[3]},${alpha})`;
    }
    // Jos jo rgba, korvaa alpha
    const m2 = computed.match(/^rgba\((\d+),\s*(\d+),\s*(\d+),\s*[\d.]+\)$/);
    if (m2) {
        return `rgba(${m2[1]},${m2[2]},${m2[3]},${alpha})`;
    }
    // Palauta alkuperäinen, jos ei tunnistettu
    return color;
}

function colorFromString(s) {
  if (!s) return null;
  let p = (""+s).split("/");
  if (p.length < 2) return s;
  return colorWithAlpha(p[0], parseFloat(p[1]) / 100);
}


function updateXctrackLink(routename) {
  const link = document.getElementById("xctrackLink");
  if (!link) return;
  routename = forcePathToRouteName(routename);
  link.href = "https://www.mit.jyu.fi/demowww/cyclo/xc.php?t=" + routename;
  link.innerText = "XCTrack: " + stripRouteName(routename);
}


// returns lastPin
function showRoute(routename, data, type, colors, drawpins, froute) {
  const lines = (data+"\n-\n").split("\n"); // lisätään lopussa - merkki, jotta viimeinen polygon piirretään
  if (lines.length === 0) return;

  logMapEntities();

  let line = lines[0].trim();
  let color = colors[loadedRoutes.length % colors.length];;
  let linewidth = 3;
  let fillArea = "";
  let outside = 0;
  let rad = 0;
  let name = "";
  removeRoute(routename);
  if ( isErrorOnData(data) ) {
     setErrorTrack(data);
     setError(data);
     return;
  }
  let dists = "";
  const rline = "==============================================================";
  const raport = ["nr  Nimi              säde      km yht km   käännepiste", rline];
  const sraport = ["nr säde  km    käännepiste"];

  // L   HOYSTO350                    0.0 % 61.54'24", 26.11'07"
  closeDiv("loadRoute");

  let sum = 0;
  let minLeg = 10000000;
  let sep = "";


  // const lineVertices = [];
  // Muutettu: useita polygoneja
  const allLineVertices = [];
  let lineVertices = [];
  allLineVertices.push(lineVertices);

  const polys = [];
  const pins = [];
  let prevPt = null;
  let prevOutside;
  let prevRad = 0;
  let firstPt = null;
  let lastPin = null;
  let vertices = 0;

  for (let i=0; i < lines.length; i++) {
    line = lines[i].trim();
    if (line === "") continue;
    if (line[0] === "-") {
      // Aloita uusi polygon
      if (lineVertices.length === 0) continue;

      // Piirrä edellinen polyline
      if (!fillArea) {
        let polyline = new Microsoft.Maps.Polyline(lineVertices);
        polyline.setOptions({strokeThickness: linewidth, strokeColor: color});
        map.entities.push(polyline);
        polys.push(polyline);
      }
      if (fillArea) {
        const area = new Microsoft.Maps.Polygon(lineVertices);
        area.setOptions({strokeThickness: linewidth, strokeColor: color, fillColor: fillArea});
        map.entities.push(area);
        polys.push(area);
      }

      lineVertices = [];
      allLineVertices.push(lineVertices);
      prevPt = null;
      prevRad = 0;
      prevOutside = undefined;
      continue;
    }

    let lat = 0;
    let lng = 0;
    let latVal = 0;
    let longVal = 0;
    if ( type === "txt" ) {
        // 62.4666234473693,22.4589770156482,EFKJ,0.4,0,0,0
        // 62.15'38,22.58'25,Niskos15,5,0,0,0
        // 62.5382468805446,22.6579360294378,Kihniö15,0.4,0,0,0
      const p = line.split(",");
      if ( p.length < 4) continue;
      lat = p[0];
      lng = p[1];
      outside = parseFloat(p[4]);
      rad = parseFloat(p[3]);
      name = p[2];
      latVal = sToDeg(lat);
      longVal = Microsoft.Maps.Location.normalizeLongitude(sToDeg(lng));
    }
    const jso = makeJSON(line, 7, null);
    if (jso) {
        if (jso?.c != null) color = colorFromString(jso.c);
        if (jso?.w != null) linewidth = parseInt(jso.w);
        if (isNaN(linewidth)) linewidth = 3;
        if (jso?.p != null) drawpins = jso.p === "t";
        if (jso?.f != null) fillArea = colorFromString(jso.f);
    }
    const pt = new Microsoft.Maps.Location(latVal, longVal);
    if ( rad > 0 ) {
      const path = Microsoft.Maps.SpatialMath.getRegularPolygon(pt, rad * 1000, 36, Microsoft.Maps.SpatialMath.Meters);
      const poly = new Microsoft.Maps.Polygon(path);
      poly.setOptions({strokeThickness: 2, strokeColor: color});
      let fillColor = color;
      if ( outside ) {
          fillColor = new Microsoft.Maps.Color(10, 128, 128, 128);
          fillColor.a = 0.1;
          poly.setOptions({strokeThickness: 2, strokeColor: color, fillColor: fillColor});
      }
      map.entities.push(poly);
      polys.push(poly)
    }
    lineVertices.push(pt);
    vertices++;
    let rtext = "";
    let srtext = "";
    if ( prevPt ) {
      let d = WGS84_distance(prevPt, pt) - prevRad - rad;
      if ( prevOutside ) d = prevOutside - rad;
      if ( outside ) {
         d = rad - prevRad;
         prevOutside = rad;
      }
      if ( d < minLeg ) minLeg = d;
      if (name) dists += sep + d.toFixed(3);
      sum += d;
      sep = " + ";
      rtext = "" + (lineVertices.length-1) + " " + fixeds(name,-20) + fixeds(rad.toFixed(1),4) + " "
                  + fixeds(d.toFixed(1),7)  + fixeds(sum.toFixed(1),6)
                 + "  " + ddmmss(latVal) + " " + ddmmss(longVal);
      srtext = "" + (lineVertices.length-1) + " " + fixeds(rad.toFixed(1),4) + " "
                 + fixeds(d.toFixed(1),5)
                 + " " + ddmmss(latVal) + " " + ddmmss(longVal);
    } else {
        firstPt = pt;
        rtext = "L" + " " + fixeds(name,-20) + fixeds(rad.toFixed(1),4) + " "
                   + fixeds("",7) + fixeds("",6)
                   + "  " + ddmmss(latVal) + " " + ddmmss(longVal);
        srtext = "L" + " " + fixeds(rad.toFixed(1),4) + " "
                   +  fixeds("",5)
                   + " " + ddmmss(latVal) + " " + ddmmss(longVal);
    }
    raport.push(rtext);
    // raport.push("");
    sraport.push(srtext);
    prevPt = pt;
    prevRad = rad;
    if ( drawpins && name ) {
      const pin = newPin(pt, false, name, blueIcon, blueSelIcon);
      pins.push(pin);
      lastPin = pin;
    }
  }

  if ( vertices === 0 ) return;

  const route = {name: routename, line: line, polys: polys, pins: pins, data: data};
  loadedRoutes.push(route);
  const dst = $("#distance");
  let pross = "";
  if ( allLineVertices[0].length === 4 ) { // kolmio
      pross = " " + (minLeg/sum*100).toFixed(1) + "%"
      raport[2] = raport[2].substr(0,34) + pross + raport[2].substr(40);
  }
  if (froute && froute !== getName(routename)) return;
  dst[0].innerText = dists + " = " + sum.toFixed(3) + " km" + pross;
  const editRaport = document.getElementById('editRaport');
  updateXctrackLink(routename);
  const editSmallRaport = document.getElementById('editSmallRaport');
  raport[raport.length-1] = "M" + raport[raport.length-1].substr(1);
  sraport[sraport.length-1] = "M" + sraport[sraport.length-1].substr(1);
  //raport[raport.length-1] = rline;
  editRaport.value = raport.join("\n");
  editSmallRaport.value = sraport.join("\n");

  logMapEntities();

  return lastPin;
}

function showArea(name, geojson, opts) {
    if (!geojson || !geojson.features) return;
    const polys = [];
    let color = 'blue';
    let linewidth = 2;
    let fillArea = 'rgba(0, 128, 255, 0.3)';
    if (opts) {
      const jso = makeJSON(opts, 0, null);
      if (jso) {
          if (jso?.c != null) color = colorFromString(jso.c);
          if (jso?.w != null) linewidth = parseInt(jso.w);
          if (isNaN(linewidth)) linewidth = 2;
          if (jso?.f != null) fillArea = colorFromString(jso.f);
      }
    }
    for (const feature of geojson.features) {
        if (feature.geometry.type !== "Polygon") continue;
        if (feature.properties.active === false &&
           feature.properties.becomingActive === false) continue; // Skip inactive areas

        let fillcolor = fillArea;
        let strokeColor = color
        let strokeThickness = linewidth;
        if (feature.properties.airspaceclass === "Restricted") {
            // Use a different color for restricted areas
            fillcolor = 'rgba(255, 0, 0, 0.3)';
            strokeColor = 'red';
            strokeThickness = 2;
        } else if (feature.properties.airspaceclass === "Prohibited") {
            // Use a different color for prohibited areas
            fillcolor = 'rgba(255, 0, 0, 0.5)';
            strokeColor = 'darkred';
            strokeThickness = 5;
        }

        for (const ring of feature.geometry.coordinates) {
            // GeoJSON: [lng, lat]
            const locations = ring.map(coord => new Microsoft.Maps.Location(coord[1], coord[0]));
            let polygonOptions = {strokeThickness: strokeThickness,
                                  strokeColor: "transparent",
                                  fillColor: "transparent"};
            if (fillcolor) polygonOptions.fillColor = fillcolor;
            if (strokeColor) polygonOptions.strokeColor = strokeColor;
            const polygon = new Microsoft.Maps.Polygon(locations, polygonOptions);
            map.entities.push(polygon);
            polys.push(polygon);
        }
    }
    const route = {name: name, line: null, polys: polys, pins: null, data: null};
    loadedRoutes.push(route);
}

function getArea(area) {
  fetch(area.url)
    .then(response => {
      if (!response.ok) throw new Error('Network response was not ok');
      return response.json();
    })
    .then(data => {
      // Use your JSON data here
      let opts = null;
      if (options[area.cb + "Own"]) {
        opts = document.getElementById(area.cb + "Opt").value;
      }
      showArea(area.name, data, opts);
    })
    .catch(error => {
      console.error('Fetch error:', error);
    });
}

function checkArea(area) {
  if (options[area.cb]) {
    getArea(area);
  } else {
    removeRoute(area.name);
  }
}

function checkAreaColor(area) {
  if (!options[area.cb]) return;
  removeRoute(area.name);
  getArea(area);
}

function checkAreas() {
   for (let area of areaDatas) {
      const cb = document.getElementById(area.cb);
      if (!cb) continue;
      cb.nextSibling.nodeValue = area.name;
      if (options[area.cb]) {
        getArea(area);
      }
   }
}

function removeTracks() {
  for (let i=0; i<loadedTracks.length; i++) {
     map.entities.remove(loadedTracks[i]);
  }
  loadedTracks = [];
  trackLines = [];
}


function addToRoute() {
  const s = getPinText();
  const t = document.getElementById('editRoute');
  let tx = t.value.trim();
  const n = tx.split("\n").length;
  let name = "start";
  if ( n > 0 && tx !== "" ) {
    tx = tx + "\n";
    name = "kp" + n;
  }
  const sp = s.split(" ");
  if ( sp.length < 2) return;
  if ( sp.length >= 3 && sp[2] !== "H" ) name = sp[2];
  const line = sp[0] + "," + sp[1] + "," + name + "," + getTPR() + ",0,0,0";
  t.value = tx + line;
  const pin = drawRouteFromDialog(true);
  if ( pin ) selectActivePin(pin, false);
}


function findRoute(rname) {
   for (let i=0; i < loadedRoutes.length; i++ ) {
       const r = loadedRoutes[i];
       if ( r.name === rname ) return r;
   }
   return null;
}


function findPinIndex(route) {
   for (let i=0; i < route.pins.length; i++) {
       const p = route.pins[i];
       if ( p === selectedPin ) return i;
   }
   return -1;
}


function getRouteName() {
   return document.getElementById('editRouteName').value;
}

function setRouteName(name) {
   document.getElementById('editRouteName').value = name;
}

function moveRoutePoint() {
  const rname = getRouteName();
  let route = findRoute(rname);
  if ( route == null ) return;

  const pinIndex = findPinIndex(route);

  if ( pinIndex < 0 ) return;
  const t = document.getElementById('editRoute');
  const tx = t.value.trim();
  const lines = tx.split("\n");
  const n = lines.length;
  if ( pinIndex >= n ) return addToRoute();

  let s = getPinText();

  const oldItems = lines[pinIndex].split(",");

  const sp = s.split(" ");
  if ( sp.length < 2) return;
  if ( sp.length >= 3 && sp[2] !== "H"  && oldItems.length >= 3 ) oldItems[2] = sp[2];

  oldItems[0] = sp[0];
  oldItems[1] = sp[1];

  lines[pinIndex] = oldItems.join();

  t.value = lines.join("\n");
  drawRouteFromDialog(true);
  route = findRoute(rname);
  selectPin(route.pins[pinIndex]);
}


function changeRoute() {
  const rname = getRouteName();
  const route = findRoute(rname);
  if ( route == null ) return;
  const t = document.getElementById('editRoute');
  t.value = route.data;
}


function forceRoute(name) {
  const route = findRoute(name);
  if ( route == null ) return;
  setRouteName(name);
  const t = document.getElementById('editRoute');
  t.value = route.data;
}


function deleteRoutePoint() {
  const rname = getRouteName();
  let route = findRoute(rname);
  if ( route == null ) return;

  const pinIndex = findPinIndex(route);

  if ( pinIndex < 0 ) return;
  const t = document.getElementById('editRoute');
  const tx = t.value.trim();
  const lines = tx.split("\n");
  const n = lines.length;
  if ( pinIndex >= n ) return;

  lines.splice(pinIndex, 1);

  t.value = lines.join("\n");
  const lastPin = drawRouteFromDialog(true);
  route = findRoute(rname);
  let pin = route.pins[pinIndex];
  if ( !pin ) pin = lastPin;
  selectPin(pin);
}


function closeRoute() {
  drawRouteFromDialog();
  const t = document.getElementById('editRoute');
  const tx = t.value.trim();
  const lines = tx.split("\n");
  t.value = tx + "\n" + lines[0];
  drawRouteFromDialog(true);
}

function stripRouteName(routename) {
  const ind = routename.lastIndexOf("/");
  if ( ind >= 0 ) routename = routename.substr(ind + 1);
  const ext = '.txt';
  if ( routename.indexOf(ext) >= 0 ) routename = routename.substr(0, routename.length - ext.length);
  return routename;
}

function forcePathToRouteName(routename) {
  const ind = routename.lastIndexOf("/");
  let path = document.getElementById('editLog').value.trim() + "/";
  if ( ind >= 0 ) path = "";
  let ext = '.txt'
  if (path === "/") path = options.email + "/";
  if ( routename.indexOf(ext) >= 0 ) ext = "";
  return path + routename + ext;
}

function saveRoute() {
  const t = document.getElementById('editRoute');
  const tx = t.value.trim();
  let name = document.getElementById('editRouteName').value.trim();
  name = forcePathToRouteName(name);
  // noinspection JSUnusedLocalSymbols
  sendCyclo({saveRoute: name, file: tx}, function (data, extra) {
    setError(data);
   }, null);
  updateXctrackLink(name);
}


function drawRouteFromDialog(drawpins) {
  return showRoute(getRouteName(), document.getElementById('editRoute').value, 'txt', getRouteColors(), drawpins);
}


function removeRoutes() {
  for (let i=0; i<loadedRoutes.length; i++) {
     const r = loadedRoutes[i];
     map.entities.remove(r.line);
     removePolys(r.polys);
     removePins(r.pins);
  }
  loadedTracks = [];
 }


let oldIcon = null;

function selectActivePin(pin, calcDist) {
  if ( selectedPin != null ) {
    // selectedPin.setOptions({state:Microsoft.Maps.EntityState.none});
    selectedPin.setOptions({ icon: oldIcon });
  }
  if ( selectedPin === pin ) {
    selectedPin = null;
    oldIcon = null;
    return;
  }
  selectedPin = pin;
  oldIcon = selectedPin.getIcon();
  // selectedPin.setOptions({state:Microsoft.Maps.EntityState.highlighted});
  selectedPin.setOptions({ icon: selectedPin.selectedIcon});
  if ( calcDist ) calcDistance();
}


function selectPin(e)  {
  if ( !e ) return;
  let pin = e;
  if ( e.target ) pin = e.target;
  selectActivePin(pin, true);
}


function showRoutePane() {
   myLayout.toggle('east');
}


 /*
  function handleFileSelect(evt) {
    var files = evt.target.files; // FileList object

    // files is a FileList of File objects. List some properties.
    var output = [];
    for (var i = 0, f; f = files[i]; i++) {
      output.push('<li><strong>', escape(f.name), '</strong> (', f.type || 'n/a', ') - ',
                  f.size, ' bytes, last modified: ',
                  f.lastModifiedDate ? f.lastModifiedDate.toLocaleDateString() : 'n/a',
                  '</li>');
    }
    document.getElementById('list').innerHTML = '<ul>' + output.join('') + '</ul>';
  }
*/

function getName(f) {
  let s = f;
  let i = s.lastIndexOf("\\");
  if ( i < 0 )  i = s.lastIndexOf("/");
  s = s.substr(i+1);
  i = s.lastIndexOf(".");
  if ( i >= 0 ) s = s.substr(0,i);
  return s;
}


const knowTypes = ["cyc", "igc", "txt", "tcx", "gpx"];


function handleFileSelect(evt) {
  const files = evt.target.files; // FileList object
  const re = /(?:\.([^.]+))?$/; // find last .XXX

  // files is a FileList of File objects. List some properties.
  const f = files[0];
  if ( !f ) return;
  const type = re.exec(f.name)[1];
  if ( knowTypes.indexOf(type) < 0 ) {
    alert("Tunnetaan vain tiedostotyypit " + knowTypes);
    return;
  }

  const reader = new FileReader();
  reader.onload = (function(theFile) {
    if ( type === "txt") {
      const data = theFile.target.result;
      const name = getName(f.name);
      try {
        showRoute(name, data, type, getRouteColors());
      } catch (e) {
      }
      moveToDialog(name, data);
    } else
      showTrack(theFile.target.result,type, getTrackColors());
   });
  reader.readAsText(f);
}


function getQuery(url, extra, f) {
   $.get(url, function (data) {
       f(data, extra);
     });
}


let colors = ["blue", "red", "brown", "orange", "green", "black"];


function getColors(name, editName) {
  if (!options[name] ) {
    options[name] = "blue,red,brown,orange,green,black";
    document.getElementById(editName).value = options[name];
  }
  const colors = [];
  const sc = options[name].split(",");
  for (let i=0; i < sc.length; i++) {
    const col = sc[i].trim();
    if ( !col ) continue;
    colors.push(col);
  }
  return colors;
}

function getTrackColors() {  return getColors('trackColors', 'editTrackColors'); }
function getRouteColors() {  return getColors('routeColors', 'editRouteColors'); }

function getTPR() {
    return options.tpR;
}

function handleURLTrack() {
  const colors = getTrackColors();
  clearErrorTrack();
  let lastpath = "";
  const urlTracks = document.getElementById('editURLTrack').value.replaceAll(",", "\n").split("\n");
  for (let i=0; i<urlTracks.length; i++) {
    const urlTrack = urlTracks[i].trim();
    if ( !urlTrack ) continue;
    let ext = "igc";
    const ind = urlTrack.lastIndexOf("/");
    if ( ind >= 0 ) lastpath = urlTrack.substr(0, ind);
    if ( urlTrack.substr(ind+1) === "*" ) continue;
    let url = urlTrack;
    if (urlTrack.indexOf("@") >= 0) {
      // url = "https://www.mit.jyu.fi/demowww/cyclo/index.php?e=" + options.email + "&id=" + options.id + "&getlog=" + urlTrack;
      //url = encodeURI(url);
      ext = "cyc"
      sendCyclo({getlog: urlTrack, f: options.usersTofollow}, function (data, extra) {
        showTrack(data, "cyc", extra);
       }, colors);
      continue;
     }
    if ( ind < 0 ) url = lastpath + "/" + urlTrack;
    url = "https://www.mit.jyu.fi/demowww/cyclo/igc.php?u=" + url;
    const re = /(?:\.([^.]+))?$/;
    ext = re.exec(url)[1];
    if ( !ext ) ext = "igc";
    getQuery(url, {colors: colors, ext: ext}, function (data, extra) {
      showTrack(data, extra.ext, extra.colors);
     });
  }
}


function moveToDialog(name, data) {
     if ( isErrorOnData(data) ) return;
     document.getElementById('editRouteName').value = name;
     document.getElementById('editRoute').value = data;
}

function handleURLRoute(froute) {
  const colors = getRouteColors();
  clearErrorRoute();
  let lastpath = options.logname;
  const urlTracks = document.getElementById('editURLRoute').value.split("\n");
  for (let i=0; i<urlTracks.length; i++) {
    let urlTrack = urlTracks[i].trim();
    if ( !urlTrack ) continue;
    let ext = "txt";
    const ind = urlTrack.lastIndexOf("/");
    if ( ind >= 0 ) lastpath = urlTrack.substr(0, ind);
    if ( urlTrack.substr(ind+1) === "*" ) continue;
    let url = urlTrack;
    let name = getName(urlTrack);
    if (urlTrack.indexOf("txt") < 0) {
      ext = "txt"
      if ( ind < 0 ) name = lastpath + "/" + name;
      else name = urlTrack;
      urlTrack = name;
      name = name + ".txt";
      sendCyclo({getRoute: name}, function (data, extra) {
        const n = getName(extra.name);
        try {
          showRoute(extra.name, data, "txt", extra.colors, false, froute);
        } catch (e) {
          console.log("Error showing route:", e);
        }
        if (!froute || froute===n) moveToDialog(extra.name, data); // TODO: korjaa nimi useita dialogeja varten
       }, {name: urlTrack, colors: colors});
      continue;
    }
    if ( ind < 0 ) url = lastpath + "/" + urlTrack;
    url = "https://www.mit.jyu.fi/demowww/cyclo/igc.php?u=" + url;
    getQuery(url, {colors:colors, name: name}, function (data, extra) {
      const n = getName(extra.name);
      showRoute(n, data, "txt", extra.colors, false, froute);
      if (!froute || froute===n) moveToDialog(n, data);
     });
  }
}


let menuOpen = false;

function openNav() {
  if ( menuOpen ) { closeNav(); return; }
  let s = document.getElementById("mySidenav").style;
  s.width = "300px";
  s.height = "290px";
  s.visibility = "visible";
  s = document.getElementById("menu").style;
  s.visibility = "visible";
  menuOpen = true;
}


function closeNav() {
  let s = document.getElementById("mySidenav").style;
  s.visibility = "hidden";
  s = document.getElementById("menu").style;
  s.visibility = "hidden";
  menuOpen = false;
}


/*
function openSettings() {
   myLayout.toggle('west');
   closeNav();
}
*/


function toggleDiv(name) {
  closeNav();
  const s = document.getElementById(name).style;
  if ( !s ) return;
  if (s.visibility === "visible")  s.visibility = "hidden";
  else s.visibility = "visible";
}


function closeDiv(name) {
  closeNav();
  const s = document.getElementById(name).style;
  if ( s ) s.visibility = "hidden";
}


function openDiv(name) {
  closeNav();
  const s = document.getElementById(name).style;
  if ( s ) s.visibility = "visible";
}


function AutoGrowTextArea(textField) {
  if (textField.clientHeight < textField.scrollHeight) {
    textField.style.height = textField.scrollHeight + "px";
    if (textField.clientHeight < textField.scrollHeight) {
      textField.style.height = (textField.scrollHeight * 2 - textField.clientHeight) + "px";
    }
  }
}


function changeRaportView() {
  //  return;
  const sb = document.getElementById("editRaport").style;
  const ss = document.getElementById("editSmallRaport").style;
  if ( options.smallRaport ) {
  //      closeDiv("editRaport");
  //      openDiv("editSmallRaport");
    sb.height = "0px";
    sb.visibility = "hidden";
    ss.height = "auto";
    ss.visibility = "inherit";
  } else {
    //      openDiv("editRaport");
    //      closeDiv("editSmallRaport");
    ss.height = "0px";
    ss.visibility = "hidden";
    sb.height = "auto";
    sb.visibility = "inherit";
  }
}


function googleDirections() {
  let s = getPinText();
  if (isCoordinate(s)) {
    s = getNormalizedCoordinateString(s, ",")
  }
  // const url = "https://www.google.com/maps/search/?api=1&query=" + s;
    const url = "https://www.google.com/maps/dir/?api=1" +
                "&destination=" + encodeURIComponent(s) + "&travelmode=driving";
  const win = window.open(url, '_blank');
  win.focus();
}

function showQrInDiv(text) {
    // Remove existing QR div if present
    const oldDiv = document.getElementById("qrDiv");
    if (oldDiv) oldDiv.remove();

    // Create the container div with the same class as route window
    const div = document.createElement("div");
    div.id = "qrDiv";
    div.className = "dragable";
    div.style.top = "50px";
    div.style.left = "30px";
    div.style.width = "300px";
    div.style.height = "320px";
    div.style.position = "absolute";
    div.style.background = "#fff";
    div.style.zIndex = 2000;

    // Move handle
    const handle = document.createElement("div");
    handle.className = "move";
    handle.innerHTML = "&nbsp;QR-koodi";
    div.appendChild(handle);

    // Close button
    const closeBtn = document.createElement("label");
    closeBtn.className = "closebtn";
    closeBtn.style.top = "-10px";
    closeBtn.innerHTML = "&times;";
    closeBtn.onclick = function() { div.remove(); };
    div.appendChild(closeBtn);

    // QR code container
    const qrDiv = document.createElement("div");
    qrDiv.style.margin = "20px";
    div.appendChild(qrDiv);

    document.body.appendChild(div);

    // Make draggable
    $(div).draggable({ handle: ".move" });

    // Generate QR code
    new QRCode(qrDiv, {
        text: text,
        width: 256,
        height: 256,
        correctLevel: QRCode.CorrectLevel.L
    });
}

// Example usage:

function showQrInNewWindow() {
    let text = document.getElementById('editRoute').value;
    // text = new TextDecoder("utf-8").decode(new TextEncoder().encode(text)); // Ensure text is properly encoded
    // text = encodeURIComponent(text);
    const xctJson = routeTxtToXCTSK(text);
    showQrInDiv(xctJson);
}

function getElevation(lat, lon, callback) {
    // const url = `https://avoin-karttakuva.maanmittauslaitos.fi/maastopalvelu/elevation?lat=${lat}&lon=${lon}`;
    const url = `https://api.open-elevation.com/api/v1/lookup?locations=${lat},${lon}`;
    fetch(url)
        .then(response => response.json())
        .then(data => {
            // The elevation is in data.elevation
            callback(data.results[0].elevation);
        })
        .catch(err => {
            console.error("Elevation fetch error:", err);
            callback(null);
        });
}

function encodeNum(num) {
    num = Math.round(num);
    let pnum = num << 1;
    if (num < 0) {
        pnum = ~pnum;
    }
    let result = [];
    if (pnum === 0) {
        result.push(String.fromCharCode(63));
    } else {
        while (pnum > 0x1F) {
            result.push(String.fromCharCode(((pnum & 0x1F) | 0x20) + 63));
            pnum >>= 5;
        }
        result.push(String.fromCharCode(pnum + 63));
    }
    return result.join('');
}

function encodeCompetitionTurnpoint(lon, lat, alt, radius) {
    return (
        encodeNum(Math.round(lon * 1e5)) +
        encodeNum(Math.round(lat * 1e5)) +
        encodeNum(alt) +
        encodeNum(radius)
    );
}

function asciiJSONStringify(obj) {
    return JSON.stringify(obj).replace(/[\u007F-\uFFFF]/g, function(c) {
        return '\\u' + ('0000' + c.charCodeAt(0).toString(16)).slice(-4);
    });
}

function routeTxtToXCTSK(txt) {

    const lines = txt.trim().split("\n");
    const t = [];
    for (let i = 0; i < lines.length; i++) {
        const [lat, lon, name, radius, out] = lines[i].split(",");
        const obj = {
            z: encodeCompetitionTurnpoint(parseFloat(lon), parseFloat(lat), 154, parseFloat(radius)*1000),
            n: name
        };
        if (out && parseInt(out) === 1) obj.out = 1; // lisää out vain jos 1
        // Set SSS and ESS types by order or name if needed
        if (i === 0) { // tehdään kopio ensimmäisestä
          const startObj = {...obj};
          t.push(startObj);
          obj.t = 2;
        } // SSS
        if (i === lines.length - 1) obj.t = 3; // ESS
        t.push(obj);
    }
    const xctsk = {
        version: 2,
        taskType: "CLASSIC",
        t: t,
        s: { t: 2, d: 2, g: ["06:00:00Z"] },
        g: { t: 2, d: "20:00:00Z" }
    };
    return "XCTSK:" + asciiJSONStringify(xctsk);
}


// Skriptien loppu ========================================================================================
</script>

<link rel="stylesheet" href="https://code.jquery.com/ui/1.12.1/themes/base/jquery-ui.css">

<!--suppress CssUnusedSymbol -->
    <style>
.ui-menu {
   width: 250px;
   margin-left: 25px;
   margin-top: 40px;
}

html, body {
   /* background-color:#b0c4de; */
    height: 100%;
}

.link {
  color: blue;
  text-decoration: underline;
}

.errorClass {
  color:#ff0000;
  font-weight: bold;
}

div#mapDiv {
}

#qrDiv {
  display: block !important;
  visibility: visible !important;
  opacity: 1 !important;
}

.navigateButton {
  float: right;
}

.logo {
   position: absolute;
   bottom:0;
   margin-bottom: -3px;
 }

.area1CBcopy {
   position: absolute;
   top: 0px;
   right: 0px;
   background-color: white;
 }

 .mapType {
   position: absolute;
   top:0;
   margin-left: -8px;
   margin-top: -2px;
 }

 .coord {
    font-size: 8pt;
 }
 .settings {
    font-size: 10pt;
 }

  .overlay {
    position: fixed;
    width: 100%;
    height: 100%;
    left: 0;
    top: 0;
    background: rgba(51,51,51,0.7);
    z-index: 10;
  }

.popup {
    padding: 5%;
    position: absolute;
    z-index: 400;
    background-color: lightyellow;
    visibility: hidden;
    top: 30pt;
    left: 5%;
    /*width: calc(100% - 72px);
    height: calc(100% - 120px);*/
	  right: 5%;
	  bottom: 10pt;
    border-color: steelblue;
    border-radius: 20px;
    border-style: solid;
    max-width: 800px;
	  /* overflow:auto; */
}

.popupIn {
    padding: 5%;
    position: absolute;
    top: 0;
    left: 0;
	  right: 0;
	  bottom: 0;
	  overflow:auto;
    border-radius: 20px;
}

.driving {
    padding: 0;
    top: 0;
    left: 0;
	  right: 0;
	  bottom: 0;
	  overflow:auto;
    border-radius: 0;
}

.directionsPanel {
    padding: 0;
    top: 0;
    left: 0;
	  right: 0;
	  bottom: 0;
	  overflow: auto;
    border-radius: 0;
}

.hamburgerSpace {
   margin-left: 35px;
}

.closebtn {
    z-index: 1000;
    position: absolute;
    top: 0;
    width: 20px;
    right: 5px;
    font-size: 36px;
    /*margin-left: 50px; */
}

.closebtn2 {
    z-index: 1000;
    width: 20px;
    font-size: 25px;
    /*margin-left: 50px; */
}
.close {
    margin-top: 20px;
}

.dragable {
    left: 35px;
    z-index: 501;
    top: 35px;
    width: fit-content;
    /* flex-grow: 1; */
    border-style: solid;
    border-width: 1px;
    border-radius: 10px;
    background-color: white;
    visibility: hidden;
}

#routeDiv {
    width: 550px;
}

.routeTextArea {
   width: 98%;
   height: 50%;
}

.raportTextArea {
   width: 95%;
   /* position: absolute; */
   top: 0;
   // bottom: 0;
}


.move {
    width: 100%;
    border-top-left-radius: 10px;
    border-top-right-radius: 10px;
    height: 20px;
    background-color: lightskyblue;
}

.inner {
  display: inline-block;
}

.clearButton {
   margin-left: -1em;
}

.comp {
  display: inline-block;
  text-align: center;
  padding: 0px 7px 0px 7px;
  line-height: 0.9;
  font-size: x-small;
}

.data {
    font-family: sans-serif;
    font-weight: bold;
}

textarea#tracklog {
    right: 0;
    bottom: 0;
    height: 100%;
    width: 100%;
}

li a.help {
    padding: unset !important;
    display: inline !important;
    /* float: right; */
    position: absolute !important;
    right: 30px;
}

a.help {
    text-decoration: none !important;
}

li.ui-menu-item {
    line-height: 1.5em;
}

.popup {
      z-index: 600;
      top: 0;
      bottom: 0;
      padding-top: 0;
}

.popupIn {
    padding-top: 0;
}


@media only screen and (max-width: 850px) {
  .popup {
      left: 2pt;
	    right: 2pt;
  }
}
@media only screen and (max-width: 600px) {
  #routeDiv {
    width: 98%;
    left: 0;
  }
}

@media only screen and (max-width: 500px) {
  .popup {
      z-index: 600;
      top: 0;
      padding-left: 2px;
      bottom: 0;
      left: 0;
	    right: 0;
  }
  .popupIn {
      padding-top: 0;
      padding-left: 2px;
  }
}

</style>

</head>
<body >
<!--
<div class="ui-layout-north">North</div>
<div class="ui-layout-west">west</div>
-->
<div id="mySidenavHamburger" style="top: 0; left: 0; width: 30px; height: 35px; position: absolute; z-index:1600;  background-color: lightgray;">
  <span style="font-size:30px;cursor:pointer" onclick="openNav()">&#9776;<br></span>
  <span style="font-size:30px;cursor:pointer" onclick="findMyPlace()">&#9737;</span>
</div>



<div id="mySidenav" style="top: 0; left: 0;  position: absolute; z-index:1500;  background-color: lightgray;" onclick="closeNav()">
  <label class="closebtn" style="visibility: hidden" onclick="closeNav()">&times;</label>

  <ul id="menu" style="visibility: hidden">
  <li><span onclick="toggleDiv('settings');">Asetukset...</span> <a class="help" href="#settings"></a></li>
  <li><span onclick="myLayout.toggle('north'); closeNav();">Pinnien lisääminen...</span> <a class="help" href="#addpins"></a></li>
  <li><span onclick="showRoutePane(); closeNav()">Ajo-ohjeet...</span> <a class="help" href="#directions"></a></li>
  <li><span onclick="toggleDiv('loadTrack'); ">Lataa track-tiedosto...</span> <a class="help" href="#loadtrack"></a></li>
  <li><span onclick="myLayout.toggle('west'); ">Näytä track-tiedot</span> <a class="help" href="#showtrackdetails"></a></li>
  <li><span onclick="toggleDiv('loadRoute'); ">Lataa reittitiedosto...</span>  <a class="help" href="#loadroute"></a></li>
  <li><span onclick="toggleDiv('routeDiv'); ">Reitin suunnittelu...</span> <a class="help" href="#routeplan"></a></li>
  <li><span onclick="toggleDiv('routeRaport'); ">Reittiraportti...</span> <a class="help" href="#routeraport"></a></li>
  <li><span onclick="toggleDiv('loadAreas'); ">Alueet...</span>  <a class="help" href="#areas"></a></li>
  <li><span onclick="googleDirections();">Ajo-ohjeet Google Mapsillä</span> <a class="help" href="#googledirections"></a></li>
  <li><span onclick="openFullscreen(document.documentElement)">Fullscreen</span></li>
  <li><span onclick="toggleDiv('about'); ">Pika-apu...</span></li>
  </ul>
  <!--Muista muuttaa korkeus openNav  (tai tee tähän tyyli automaattiseksi) -->
</div>


<div class="popup" id="loadTrack" style=" ">
  <label class="closebtn" onclick="toggleDiv('loadTrack')">&times;</label>
  <div class="popupIn">

  <h2>Track-tiedoston hakeminen</h2>
  <p>Track tiedosto voidaan hakea joko laitteelta tai netistä
    (esim <a href="https://www.xcontest.org/finland/lennot/paivan-tulokset/" target="_blank">XContest</a>:
    avaa lennon tiedot ja raahaa tai kopioi .igc tiedoston osoite)</p>
  <p>Värilista: <input name="editTrackColors" id="editTrackColors" size="50" value="blue,red,brown,orange,green,black"></p>
  <button type="button" onclick="removeTracks()" >Poista kartalla olevat trackit</button>
  <hr />
  <div>
  <p>Tiedoston hakeminen laitteelta, valitse alta laitteessa oleva .igc tai .cyc -tiedosto:</p>
	<div id="getLogFile"><label for="logFile">Track tiedosto: </label><input type="file" id="logFile" name="logFile"  /></div>
  </div>
  <hr />
  <div>
    <p>Tiedoston hakeminen netistä.  Kirjoita tai raahaa alle IGC-tiedoston URL-osoite:</p>
   	<textarea  name="editURLTrack" id="editURLTrack" cols="60" onkeyup="AutoGrowTextArea(this)"  ></textarea>
	  <button type="button" onclick="handleURLTrack()" >Lataa track</button>
  </div>
	<p class="errorClass" id="errorMsgTrack"></p>

   <button class="close" onclick="toggleDiv('loadTrack')">Sulje</button>
  </div>
</div>


<div class="popup" id="loadRoute" style=" ">
  <label class="closebtn" onclick="toggleDiv('loadRoute')">&times;</label>
  <div class="popupIn">
  <h2>Reittitiedoston hakeminen</h2>
  <p>Reittitiedosto voidaan hakea joko laitteelta tai netistä.  Reittitiedoston tulee olla Riippuliito-ohjelman
  syntaksin mukainen.</p>
  <p>Värilista: <input name="editRouteColors" id="editRouteColors" size="50" value="blue,red,brown,orange,green,black"></p>
  <button type="button" onclick="removeRoutes()" >Poista kartalla olevat retit</button>
  <hr />
  <div>
  <p>Tiedoston hakeminen laitteelta, valitse alta laitteessa oleva reitin .txt -tiedosto:</p>
	<div id="getRouteFile"><label for="routeFile">Reittitiedosto: </label><input type="file" id="routeFile" name="routeFile"  /></div>
  </div>
  <hr />
  <div>
    <p>Tiedoston hakeminen netistä.  Kirjoita tai raahaa alle reitin .txt-tiedoston URL-osoite:</p>
   	<textarea  name="editURLRoute" id="editURLRoute" cols="60" onkeyup="AutoGrowTextArea(this)"  ></textarea>
   	<!-- <input type="text" name="editURLRoute" id="editURLRoute" value="" size="35"  /> -->
	  <button type="button" onclick="handleURLRoute()" >Lataa reitti</button>
  </div>
	<p class="errorClass" id="errorMsgRoute"></p>

   <button class="close" onclick="toggleDiv('loadRoute')">Sulje</button>
  </div>
</div>


<div class="popup" id="about" style=" ">
  <label class="closebtn" onclick="toggleDiv('about')">&times;</label>
  <div class="popupIn">
  <h2>Pika-ohjeet</h2>
  <p>Dataa tähän karttaan voit lähettää <a href="https://trac.cc.jyu.fi/projects/dotnet/wiki/CycloLite">CycloLite</a>llä,
  <a href="https://play.google.com/store/apps/details?id=jyu.sendpos&hl=en_IE">SendPos Androidilla</a>
    tai <a href="s.html">Lähetys-sivulla</a>.</p>
  <p>
    Tunnukset voit tehdä <a href="javascript:void(0)" onclick="toggleDiv('about'); toggleDiv('settings')">asetuksista</a> tai
  <a href="account.html">tilien hallinta</a>-sivulla.
  </p>
  <p>
  <a href="https://tim.jyu.fi/view/users/vesal/riippu/cyclo/kartta" target="blank">Ohjeet</a>.
  </p>
   <button class="close" onclick="toggleDiv('about')">Sulje</button>
  </div>
</div>


<div class="popup" id="settings" style="">
  <label class="closebtn" onclick="toggleDiv('settings'); adjustComponents()">&times;</label>
  <div class="popupIn">
    <h2>Asetukset</h2>
    <input type="checkbox" id="HCenter" value="HCenter"  />Pidä H keskellä <a class="help" href="#othersettings"></a><br />
    <!-- <input type="checkbox" id="showAccuracy" value="showAccuray"  />Näytä tarkkuusympyrä<br /> -->
    <input type="checkbox" id="readGPS" value="readGPS"  />Lue GPS:ää<br />
    <input type="checkbox" name="followMe" id="followMe" value="followMe"  />Piirrä oma jälki
    <input type="text" name="editFollowMeColor" id="editFollowMeColor" value="orange" size="8" />
    <input type="text" name="editFollowMeWidth" id="editFollowMeWidth" value="3" size="1" /> pt<br />
    <input type="checkbox" name="selectNewPin" id="selectNewPin" value="selectNewPin"  />Valitse uusi pin aktiiviseksi<br />
    <!-- <input type="checkbox" name="useDummyRect" id="useDummyRect" value="useDummyRect"  />Käytä tyhjää hakualuetta (jos ei osaa hakea)<br /> -->
    <span id="preventSleepSpan"><input type="checkbox" name="preventSleep" id="preventSleep" value="preventSleep"  />Estä näytön sammuminen</span>
    <br /><br />


    <div class="ui-widget" id="followDiv">
      <div id="followArea">
        <button type="button" onclick="$('#followArea').toggle(); $('#accountArea').toggle();" >Tilaa käyttäjätunnus (ID)...</button><a class="help" href="#userid"></a>
        <hr>
        <div id="accountArea2"><p><b>Oman paikan lähettäminen ja muiden seuraaminen:</b><a class="help" href="#followsettings"></a></p>
          <label for="editTag">Kartalla näkyvä tunnus: </label><input type="text" name="editTag" id="editTag" value="" size="5" /><br>
          <label for="editLog">logname: </label><input type="text" name="editLog" id="editLog" value="" size="12" /><br>
          <label for="editInterval">interval/ms: </label><input type="text" name="editInterval" id="editInterval" value="5000" size="8" /><br>
          <label for="editUsersTofollow">Seurattavat käyttäjät: </label><input type="text" name="editUsersTofollow" id="editUsersTofollow" value="" size="15"   /><br />
        </div>
        <br />
        <button type="button" onclick="getfollow(); closeDiv('settings');">Hae muiden paikka</button> (jos automaatti ei ole päällä)<br />
        <br />
        <input type="checkbox" name="follow" id="follow" value="follow"  />Seuraa muita automaattisesti<br />
        <input type="checkbox" name="drawLogLine" id="drawLogLine" value="drawLogLine"  />Piirrä viivaa seurattavista<br />
        <input type="checkbox" id="send" value="send"  />Lähetä omaa paikkaa<br />
        <hr>
        <div id="compArea"><p><b>Mittareiden arvot</b> <a class="help" href="#gauges"></a></p>
          <input type="checkbox" name="useComps" id="useComps" value="useComps"  />Näytä mittarit<br />
          <div id="showCompsSettings">
            <input type="checkbox" id="useCompsWindow" value="useCompsWindow"  />Näytä ikkunassa<br />
            <span><br>Taustan väri: </span> <input type="text" id="editCompsBackground" value="rgba(0,0,0,1.0)"  /><br />
            <span><br>Fontin väri: </span> <input type="text" id="editCompsColor" value="white"  /><br />
            <span style="font-size: 10px">Ruksi mittarit joita haluat käyttää</span>
            <table id="tableCompsSettings">
            </table>
          </div>
        </div>
        <button class="close" onclick="toggleDiv('settings'); adjustComponents()">Sulje</button>
      </div>
      <div id="accountArea">
        <br />

        <label for="editEmail">Email: </label><input type="text" name="editEmail" id="editEmail" value="" size="25" /><a class="help" href="#userid"></a><br />
        <label for="editId">id: </label><input type="text" name="editId" id="editId" value="" size="15" /><br />
        <br />
        <button id="getId">Hae uusi ID</button><a class="help" href="#userid"></a>
        <br />
        <br />
        <span class="idMsg" id = "idMsg"></span>
        <br />
        <button type="button" onclick="$('#followArea').toggle(); $('#accountArea').toggle();" >Palaa seuranta-asetuksiin...</button>
      </div>
    </div>
  </div>

</div>


<div id="routeDiv" class="dragable">
    <label class="closebtn" style="top: -10px" onclick="closeDiv('routeDiv');">&times;</label>
    <div id="routeDivHanlde" class="move" >
      &nbsp;Reitin muokkaus
    </div>
    <div id="routeDivIn">
      <div id="editRouteButtons">
        <label>Reitin nimi: </label>
        <input class=".input" type="text" name="editRouteName" id="editRouteName" value="1" size="10" onkeyup="changeRoute()" />
        <input type="text" name="editTPR" id="editTPR" value="0.0" size="2" title="KP säde km" />
        <button type="button" onclick="addToRoute()" >Lisää reittiin</button>
        <button type="button" onclick="moveRoutePoint()" >Siirrä</button>
        <button type="button" onclick="deleteRoutePoint()" >Poista</button>
        <button type="button" onclick="closeRoute()" >Sulje reitti</button>
      </div>
      <textarea  name="editRoute" id="editRoute" class="routeTextArea"  rows="5"   >
      </textarea><br>
      <button type="button" onclick="drawRouteFromDialog(true);" >Piirrä reitti</button>
      <button type="button" onclick="saveRoute();" >Tallenna reitti</button>
      <button type="button" onclick="removeRoutes();" >Poista reitit</button>
      <input type="checkbox" name="autoAddToRoute" id="autoAddToRoute" value="autoAdd" />Lisää klikkaamalla
      <button type="button" onclick="toggleDiv('routeRaport'); ">Raportti</button>
    </div>
</div>

<div id="routeRaport" class="dragable" style="top: 80px; width: 550px;">
    <label class="closebtn" style="top: -10px; left: 20%; " onclick="closeDiv('routeRaport');">&times;</label>
    <div id="routeRaportHanlde" class="move" >
      &nbsp;Reittiraportti
    </div>
    <div id="routeRaportIn">
      <input type="checkbox" name="smallRaport" id="smallRaport" value="smallRapoprt" />Pieni raportti&nbsp;
      <a id="xctrackLink" target="_blank" rel="noopener noreferrer" href="Tallenna_tehtava_ensin"></a>&nbsp;
      <a id="xctrackQR"  href="javascript:void(0)" onclick="showQrInNewWindow()">QR</a>
      <a class="help" href="#routeraport"></a>
      <br>
      <textarea  name="editRaport" id="editRaport" class="raportTextArea"  rows="10"   >
      </textarea>
      <textarea  name="editSmallRaport" id="editSmallRaport" class="raportTextArea"  rows="7" style='height: 0; visibility: hidden'  >
      </textarea>
   </div>
</div>


<div class="popup" id="loadAreas" style=" ">
  <label class="closebtn" onclick="toggleDiv('loadAreas')">&times;</label>
  <div class="popupIn">
    <h2>Alueet</h2>
    <p>Valitse mitä alueita haluat käyttää</p>
    <div id="loadAreasIn">
      <table>
        <tr><th>Alue</th><th>Oma väritys</th><th>Optiot</th></tr>
        <tr><td><label><input type="checkbox" name="area1cb" id="area1cb" value="area1" />Alue 1</label></td>
            <td><input type="checkbox" name="area1cbOwn" id="area1cbOwn" value="area1" /></td>
            <td><input type="text" name="area1cbOpt" id="area1cbOpt" value="c:gray/60,w:8,f:" /></td>
        </tr>
        <tr><td><label><input type="checkbox" name="area2cb" id="area2cb" value="area2" />Alue 1</label></td>
            <td><input type="checkbox" name="area2cbOwn" id="area2cbOwn" value="area2" /></td>
            <td><input type="text" name="area2cbOpt" id="area2cbOpt" value="c:red/60,w:8,f:red/30" /></td>
        </tr>
        <tr><td><label><input type="checkbox" name="area3cb" id="area3cb" value="area3" />Alue 1</label></td>
            <td><input type="checkbox" name="area3cbOwn" id="area3cbOwn" value="area3" /></td>
            <td><input type="text" name="area3cbOpt" id="area3cbOpt" value="c:red/80,w:8,f:red/30" /></td>
        </tr>
      </table>
      <br>
      <p>Tarkista kuitenkin alueiden korkeudet ja voimassaoloajat <a id="flykLink" href="https://flyk.com/map?lang=fi&pilot#p=7.11/60.837/27.172" target="flyk">FLYK-kartasta</a>!</p>
      <!--
      <p>Muut alueet: (kirjoita URL-osoiteet, joista saadaan ladattua alueiden JSONit)</p>
      <textarea  name="editRaport" id="editLoadAreas" class="loadAreasTextArea"  rows="10">
      </textarea>
      -->
   </div>
  </div>
</div>


<div class="ui-layout-north">
  <label class="closebtn" style="top: -10px" onclick="myLayout.toggle('north')">&times;</label>
  <div id="pinDiv" style="margin-left: 35px">
    <!-- <label class="hamburgerSpace"> </label> -->
    <input type="text" name="editPinLoc" id="editPinLoc" value="" size="35" onkeyup="checkAddPinText()" />
    <span class ="clearButton" id="buttonClearText" onclick="setPinText('')">x</span>
    <button type="button" id="buttonAddPin" onclick="addPin()">Etsi</button>
    <a class="help" href="#find"></a>
    <span id="searchSpan" style="visibility: hidden">
      <select id="searchCombo" ></select>
      <span class="searchClass" id="searchMsg"></span>
      <label class="closebtn2" style="margin-top: 10px;" onclick="clearSearchResults()">&times;</label>
    </span>
    <span class="errorClass" id="errorMsg"></span>
  </div>
</div>


<div class="ui-layout-center">
  <div id='mapDiv' ></div>
  <div class="logo"></div>
  <div class="mapType">
    <div class="ui-widget">
      <label class="hamburgerSpace"> </label>&nbsp;
      <select id="combobox"></select> <span style="background: white;" id="distance">0 km</span>
    </div>
  </div>
  <div class="area1CBcopy">
    <label for="area1cbCopy">✈️</label><br><input type="checkbox" title="Ilmatilat" id="area1cbCopy" name="area1cbCopy" value="area1cbCopy" />
  </div>
</div>


<div class="ui-layout-west settings" id="trackarea">
    <textarea id="tracklog" ></textarea>
</div>


<div class="ui-layout-east" style="border-style: solid; border-width: thin;">
  <label class="closebtn"  style="top: -13px;" onclick="showRoutePane();">&times;</label>
  <div class="popupIn">
    <div id='addressDiv'>
      Ajo-ohjeet, kirjoita osoitteet tai koordinaatit:<br />
      <input type="text" name="editFrom" id="editFrom" value="Tontuntie 11, Jyväskylä" size="40"  />
      <span class="inner">
      <button class="inner" type="button" title="Laita nykypiste lähtöpisteeksi" onclick='moveEditTo("editFrom")'>S</button>
      <button class="inner" type="button" title="Laita oma paikka lähtöpisteeksi" onclick='moveITo("editFrom")'>I</button>
      <button class="inner" type="button" title="Etsi tämä paikka" onclick='searchFrom("editFrom")'>E</button>
      </span>
      <br />
      =&gt;
      <input type="text" name="editTo" id="editTo" value="Mattilanniemi 2, Jyväskylä" size="40"  />
      <span class="inner">
      <button class="inner" type="button" title="Laita nykypiste loppupisteeksi" onclick='moveEditTo("editTo")'>S</button>
      <button class="inner" type="button" title="Etsi tämä paikka" onclick='searchFrom("editTo")'>E</button>
      </span>
      <br />
      <input type="checkbox" name="RouteMode" id="RouteMode" value="walk" />Kävely
      <button type="button" onclick="findDriving()">Etsi reitti</button>
        <a class="link" onclick="copyRouteToUrl()">Laita&nbsp;URLiin</a>
    </div>
    <div class="driving">
      <div id='itineraryDiv'></div>
    </div>
  </div>
</div>


<div class="ui-layout-south">
</div>

 <div id="openShowComps"  style="bottom: 3em; left: 0; position: absolute; z-index:390" onclick="showCompsDiv(true)">
   <span style="font-size: 30px;">></span>
 </div>
 <div id="showComps" class="showComps" style="z-index: 500; bottom: 0px; left: 0; position: absolute; z-index:390">
 </div>

 <div style="bottom: 0; right: 0; position: absolute; z-index:370; background-color: white;">
   	<span class="coord" id="coord"></span>
   <a class="link" onclick="copyToUrl()">Laita&nbsp;URLiin</a>
 </div>


</body>
</html>
